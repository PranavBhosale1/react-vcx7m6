{"ast":null,"code":"import { PaperLayer } from '../PaperLayer.mjs';\nimport { isFunction, isString, defaults, omit, assign, merge } from '../../util/index.mjs';\nimport V from '../../V/index.mjs';\nexport const GridLayer = PaperLayer.extend({\n  style: {\n    'pointer-events': 'none'\n  },\n  _gridCache: null,\n  _gridSettings: null,\n  init() {\n    PaperLayer.prototype.init.apply(this, arguments);\n    const {\n      options: {\n        paper\n      }\n    } = this;\n    this._gridCache = null;\n    this._gridSettings = [];\n    this.listenTo(paper, 'transform resize', this.updateGrid);\n  },\n  setGrid(drawGrid) {\n    this._gridSettings = this.getGridSettings(drawGrid);\n    this.renderGrid();\n  },\n  getGridSettings(drawGrid) {\n    const gridSettings = [];\n    if (drawGrid) {\n      const optionsList = Array.isArray(drawGrid) ? drawGrid : [drawGrid || {}];\n      optionsList.forEach(item => {\n        gridSettings.push(...this._resolveDrawGridOption(item));\n      });\n    }\n    return gridSettings;\n  },\n  removeGrid() {\n    const {\n      _gridCache: grid\n    } = this;\n    if (!grid) return;\n    grid.root.remove();\n    this._gridCache = null;\n  },\n  renderGrid() {\n    const {\n      options: {\n        paper\n      }\n    } = this;\n    const {\n      _gridSettings: gridSettings\n    } = this;\n    this.removeGrid();\n    if (gridSettings.length === 0) return;\n    const gridSize = paper.options.drawGridSize || paper.options.gridSize;\n    if (gridSize <= 1) {\n      return;\n    }\n    const refs = this._getGridRefs();\n    gridSettings.forEach((gridLayerSetting, index) => {\n      const id = this._getPatternId(index);\n      const options = merge({}, gridLayerSetting);\n      const {\n        scaleFactor = 1\n      } = options;\n      options.width = gridSize * scaleFactor || 1;\n      options.height = gridSize * scaleFactor || 1;\n      let vPattern;\n      if (!refs.exist(id)) {\n        vPattern = V('pattern', {\n          id: id,\n          patternUnits: 'userSpaceOnUse'\n        }, V(options.markup));\n        refs.add(id, vPattern);\n      } else {\n        vPattern = refs.get(id);\n      }\n      if (isFunction(options.render)) {\n        options.render(vPattern.node.firstChild, options, paper);\n      }\n      vPattern.attr({\n        width: options.width,\n        height: options.height\n      });\n    });\n    refs.root.appendTo(this.el);\n    this.updateGrid();\n  },\n  updateGrid() {\n    const {\n      _gridCache: grid,\n      _gridSettings: gridSettings,\n      options: {\n        paper\n      }\n    } = this;\n    if (!grid) return;\n    const {\n      root: vSvg,\n      patterns\n    } = grid;\n    const {\n      x,\n      y,\n      width,\n      height\n    } = paper.getArea();\n    vSvg.attr({\n      x,\n      y,\n      width,\n      height\n    });\n    for (const patternId in patterns) {\n      const vPattern = patterns[patternId];\n      vPattern.attr({\n        x: -x,\n        y: -y\n      });\n    }\n    gridSettings.forEach((options, index) => {\n      if (isFunction(options.update)) {\n        const vPattern = patterns[this._getPatternId(index)];\n        options.update(vPattern.node.firstChild, options, paper);\n      }\n    });\n  },\n  _getPatternId(index) {\n    return `pattern_${this.options.paper.cid}_${index}`;\n  },\n  _getGridRefs() {\n    let {\n      _gridCache: grid\n    } = this;\n    if (grid) return grid;\n    const defsVEl = V('defs');\n    const svgVEl = V('svg', {\n      width: '100%',\n      height: '100%'\n    }, [defsVEl]);\n    grid = this._gridCache = {\n      root: svgVEl,\n      patterns: {},\n      add: function (id, patternVEl) {\n        const rectVEl = V('rect', {\n          width: '100%',\n          height: '100%',\n          fill: `url(#${id})`\n        });\n        defsVEl.append(patternVEl);\n        svgVEl.append(rectVEl);\n        this.patterns[id] = patternVEl;\n      },\n      get: function (id) {\n        return this.patterns[id];\n      },\n      exist: function (id) {\n        return this.patterns[id] !== undefined;\n      }\n    };\n    return grid;\n  },\n  _resolveDrawGridOption(opt) {\n    var namespace = this.options.patterns;\n    if (isString(opt) && Array.isArray(namespace[opt])) {\n      return namespace[opt].map(function (item) {\n        return assign({}, item);\n      });\n    }\n    var options = opt || {\n      args: [{}]\n    };\n    var isArray = Array.isArray(options);\n    var name = options.name;\n    if (!isArray && !name && !options.markup) {\n      name = 'dot';\n    }\n    if (name && Array.isArray(namespace[name])) {\n      var pattern = namespace[name].map(function (item) {\n        return assign({}, item);\n      });\n      var args = Array.isArray(options.args) ? options.args : [options.args || {}];\n      defaults(args[0], omit(opt, 'args'));\n      for (var i = 0; i < args.length; i++) {\n        if (pattern[i]) {\n          assign(pattern[i], args[i]);\n        }\n      }\n      return pattern;\n    }\n    return isArray ? options : [options];\n  }\n});","map":{"version":3,"names":["PaperLayer","isFunction","isString","defaults","omit","assign","merge","V","GridLayer","extend","style","_gridCache","_gridSettings","init","prototype","apply","arguments","options","paper","listenTo","updateGrid","setGrid","drawGrid","getGridSettings","renderGrid","gridSettings","optionsList","Array","isArray","forEach","item","push","_resolveDrawGridOption","removeGrid","grid","root","remove","length","gridSize","drawGridSize","refs","_getGridRefs","gridLayerSetting","index","id","_getPatternId","scaleFactor","width","height","vPattern","exist","patternUnits","markup","add","get","render","node","firstChild","attr","appendTo","el","vSvg","patterns","x","y","getArea","patternId","update","cid","defsVEl","svgVEl","patternVEl","rectVEl","fill","append","undefined","opt","namespace","map","args","name","pattern","i"],"sources":["C:/react-vcx7m6/node_modules/@joint/core/src/dia/layers/GridLayer.mjs"],"sourcesContent":["import { PaperLayer } from '../PaperLayer.mjs';\nimport {\n    isFunction,\n    isString,\n    defaults,\n    omit,\n    assign,\n    merge,\n} from '../../util/index.mjs';\nimport V from '../../V/index.mjs';\n\nexport const GridLayer = PaperLayer.extend({\n\n    style: {\n        'pointer-events': 'none'\n    },\n\n    _gridCache: null,\n    _gridSettings: null,\n\n    init() {\n        PaperLayer.prototype.init.apply(this, arguments);\n        const { options: { paper }} = this;\n        this._gridCache = null;\n        this._gridSettings = [];\n        this.listenTo(paper, 'transform resize', this.updateGrid);\n    },\n\n    setGrid(drawGrid) {\n        this._gridSettings = this.getGridSettings(drawGrid);\n        this.renderGrid();\n    },\n\n    getGridSettings(drawGrid) {\n        const gridSettings = [];\n        if (drawGrid) {\n            const optionsList = Array.isArray(drawGrid) ? drawGrid : [drawGrid || {}];\n            optionsList.forEach((item) => {\n                gridSettings.push(...this._resolveDrawGridOption(item));\n            });\n        }\n        return gridSettings;\n    },\n\n    removeGrid() {\n        const { _gridCache: grid } = this;\n        if (!grid) return;\n        grid.root.remove();\n        this._gridCache = null;\n    },\n\n    renderGrid() {\n\n        const { options: { paper }} = this;\n        const { _gridSettings: gridSettings } = this;\n\n        this.removeGrid();\n\n        if (gridSettings.length === 0) return;\n\n        const gridSize = paper.options.drawGridSize || paper.options.gridSize;\n        if (gridSize <= 1) {\n            return;\n        }\n\n        const refs = this._getGridRefs();\n\n        gridSettings.forEach((gridLayerSetting, index) => {\n\n            const id = this._getPatternId(index);\n            const options = merge({}, gridLayerSetting);\n            const { scaleFactor = 1 } = options;\n            options.width = gridSize * scaleFactor || 1;\n            options.height = gridSize * scaleFactor || 1;\n\n            let vPattern;\n            if (!refs.exist(id)) {\n                vPattern = V('pattern', { id: id, patternUnits: 'userSpaceOnUse' }, V(options.markup));\n                refs.add(id, vPattern);\n            } else {\n                vPattern = refs.get(id);\n            }\n\n            if (isFunction(options.render)) {\n                options.render(vPattern.node.firstChild, options, paper);\n            }\n            vPattern.attr({\n                width: options.width,\n                height: options.height\n            });\n        });\n\n        refs.root.appendTo(this.el);\n        this.updateGrid();\n    },\n\n    updateGrid() {\n\n        const { _gridCache: grid, _gridSettings: gridSettings, options: { paper }} = this;\n        if (!grid) return;\n        const { root: vSvg, patterns } = grid;\n        const { x, y, width, height } = paper.getArea();\n        vSvg.attr({ x, y, width, height });\n        for (const patternId in patterns) {\n            const vPattern = patterns[patternId];\n            vPattern.attr({ x: -x, y: -y });\n        }\n        gridSettings.forEach((options, index) => {\n            if (isFunction(options.update)) {\n                const vPattern = patterns[this._getPatternId(index)];\n                options.update(vPattern.node.firstChild, options, paper);\n            }\n        });\n    },\n\n    _getPatternId(index) {\n        return `pattern_${this.options.paper.cid}_${index}`;\n    },\n\n    _getGridRefs() {\n        let { _gridCache: grid } = this;\n        if (grid) return grid;\n        const defsVEl = V('defs');\n        const svgVEl = V('svg', { width: '100%', height: '100%' }, [defsVEl]);\n        grid = this._gridCache = {\n            root: svgVEl,\n            patterns: {},\n            add: function(id, patternVEl) {\n                const rectVEl = V('rect', { width: '100%', height: '100%', fill: `url(#${id})` });\n                defsVEl.append(patternVEl);\n                svgVEl.append(rectVEl);\n                this.patterns[id] = patternVEl;\n            },\n            get: function(id) {\n                return this.patterns[id];\n            },\n            exist: function(id) {\n                return this.patterns[id] !== undefined;\n            }\n        };\n        return grid;\n    },\n\n    _resolveDrawGridOption(opt) {\n\n        var namespace = this.options.patterns;\n        if (isString(opt) && Array.isArray(namespace[opt])) {\n            return namespace[opt].map(function(item) {\n                return assign({}, item);\n            });\n        }\n\n        var options = opt || { args: [{}] };\n        var isArray = Array.isArray(options);\n        var name = options.name;\n\n        if (!isArray && !name && !options.markup) {\n            name = 'dot';\n        }\n\n        if (name && Array.isArray(namespace[name])) {\n            var pattern = namespace[name].map(function(item) {\n                return assign({}, item);\n            });\n\n            var args = Array.isArray(options.args) ? options.args : [options.args || {}];\n\n            defaults(args[0], omit(opt, 'args'));\n            for (var i = 0; i < args.length; i++) {\n                if (pattern[i]) {\n                    assign(pattern[i], args[i]);\n                }\n            }\n            return pattern;\n        }\n\n        return isArray ? options : [options];\n    },\n\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}