{"ast":null,"code":"import { CellView } from './CellView.mjs';\nimport { Link } from './Link.mjs';\nimport V from '../V/index.mjs';\nimport { addClassNamePrefix, merge, assign, isObject, isFunction, clone, isPercentage, result, isEqual } from '../util/index.mjs';\nimport { Point, Line, Path, normalizeAngle, Rect, Polyline } from '../g/index.mjs';\nimport * as routers from '../routers/index.mjs';\nimport * as connectors from '../connectors/index.mjs';\nimport { env } from '../env/index.mjs';\nconst Flags = {\n  TOOLS: CellView.Flags.TOOLS,\n  RENDER: 'RENDER',\n  UPDATE: 'UPDATE',\n  LABELS: 'LABELS',\n  SOURCE: 'SOURCE',\n  TARGET: 'TARGET',\n  CONNECTOR: 'CONNECTOR'\n};\n\n// Link base view and controller.\n// ----------------------------------------\n\nexport const LinkView = CellView.extend({\n  className: function () {\n    var classNames = CellView.prototype.className.apply(this).split(' ');\n    classNames.push('link');\n    return classNames.join(' ');\n  },\n  _labelCache: null,\n  _labelSelectors: null,\n  _V: null,\n  _dragData: null,\n  // deprecated\n\n  metrics: null,\n  decimalsRounding: 2,\n  initialize: function () {\n    CellView.prototype.initialize.apply(this, arguments);\n\n    // `_.labelCache` is a mapping of indexes of labels in the `this.get('labels')` array to\n    // `<g class=\"label\">` nodes wrapped by Vectorizer. This allows for quick access to the\n    // nodes in `updateLabelPosition()` in order to update the label positions.\n    this._labelCache = {};\n\n    // a cache of label selectors\n    this._labelSelectors = {};\n\n    // cache of default markup nodes\n    this._V = {};\n\n    // connection path metrics\n    this.cleanNodesCache();\n  },\n  presentationAttributes: {\n    markup: [Flags.RENDER],\n    attrs: [Flags.UPDATE],\n    router: [Flags.UPDATE],\n    connector: [Flags.CONNECTOR],\n    labels: [Flags.LABELS],\n    labelMarkup: [Flags.LABELS],\n    vertices: [Flags.UPDATE],\n    source: [Flags.SOURCE, Flags.UPDATE],\n    target: [Flags.TARGET, Flags.UPDATE]\n  },\n  initFlag: [Flags.RENDER, Flags.SOURCE, Flags.TARGET, Flags.TOOLS],\n  UPDATE_PRIORITY: 1,\n  confirmUpdate: function (flags, opt) {\n    opt || (opt = {});\n    if (this.hasFlag(flags, Flags.SOURCE)) {\n      if (!this.updateEndProperties('source')) return flags;\n      flags = this.removeFlag(flags, Flags.SOURCE);\n    }\n    if (this.hasFlag(flags, Flags.TARGET)) {\n      if (!this.updateEndProperties('target')) return flags;\n      flags = this.removeFlag(flags, Flags.TARGET);\n    }\n    const {\n      paper,\n      sourceView,\n      targetView\n    } = this;\n    if (paper && (sourceView && !paper.isViewMounted(sourceView) || targetView && !paper.isViewMounted(targetView))) {\n      // Wait for the sourceView and targetView to be rendered\n      return flags;\n    }\n    if (this.hasFlag(flags, Flags.RENDER)) {\n      this.render();\n      this.updateHighlighters(true);\n      this.updateTools(opt);\n      flags = this.removeFlag(flags, [Flags.RENDER, Flags.UPDATE, Flags.LABELS, Flags.TOOLS, Flags.CONNECTOR]);\n      if (env.test('isSafari')) {\n        this.__fixSafariBug268376();\n      }\n      return flags;\n    }\n    let updateHighlighters = false;\n    const {\n      model\n    } = this;\n    const {\n      attributes\n    } = model;\n    let updateLabels = this.hasFlag(flags, Flags.LABELS);\n    if (updateLabels) {\n      this.onLabelsChange(model, attributes.labels, opt);\n      flags = this.removeFlag(flags, Flags.LABELS);\n      updateHighlighters = true;\n    }\n    const updateAll = this.hasFlag(flags, Flags.UPDATE);\n    const updateConnector = this.hasFlag(flags, Flags.CONNECTOR);\n    if (updateAll || updateConnector) {\n      if (!updateAll) {\n        // Keep the current route and update the geometry\n        this.updatePath();\n        this.updateDOM();\n      } else if (opt.translateBy && model.isRelationshipEmbeddedIn(opt.translateBy)) {\n        // The link is being translated by an ancestor that will\n        // shift source point, target point and all vertices\n        // by an equal distance.\n        this.translate(opt.tx, opt.ty);\n      } else {\n        this.update();\n      }\n      this.updateTools(opt);\n      flags = this.removeFlag(flags, [Flags.UPDATE, Flags.TOOLS, Flags.CONNECTOR]);\n      updateLabels = false;\n      updateHighlighters = true;\n    }\n    if (updateLabels) {\n      this.updateLabelPositions();\n    }\n    if (updateHighlighters) {\n      this.updateHighlighters();\n    }\n    if (this.hasFlag(flags, Flags.TOOLS)) {\n      this.updateTools(opt);\n      flags = this.removeFlag(flags, Flags.TOOLS);\n    }\n    return flags;\n  },\n  __fixSafariBug268376: function () {\n    // Safari has a bug where any change after the first render is not reflected in the DOM.\n    // https://bugs.webkit.org/show_bug.cgi?id=268376\n    const {\n      el\n    } = this;\n    const childNodes = Array.from(el.childNodes);\n    const fragment = document.createDocumentFragment();\n    for (let i = 0, n = childNodes.length; i < n; i++) {\n      el.removeChild(childNodes[i]);\n      fragment.appendChild(childNodes[i]);\n    }\n    el.appendChild(fragment);\n  },\n  requestConnectionUpdate: function (opt) {\n    this.requestUpdate(this.getFlag(Flags.UPDATE), opt);\n  },\n  isLabelsRenderRequired: function (opt = {}) {\n    const previousLabels = this.model.previous('labels');\n    if (!previousLabels) return true;\n\n    // Here is an optimization for cases when we know, that change does\n    // not require re-rendering of all labels.\n    if ('propertyPathArray' in opt && 'propertyValue' in opt) {\n      // The label is setting by `prop()` method\n      var pathArray = opt.propertyPathArray || [];\n      var pathLength = pathArray.length;\n      if (pathLength > 1) {\n        // We are changing a single label here e.g. 'labels/0/position'\n        var labelExists = !!previousLabels[pathArray[1]];\n        if (labelExists) {\n          if (pathLength === 2) {\n            // We are changing the entire label. Need to check if the\n            // markup is also being changed.\n            return 'markup' in Object(opt.propertyValue);\n          } else if (pathArray[2] !== 'markup') {\n            // We are changing a label property but not the markup\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  },\n  onLabelsChange: function (_link, _labels, opt) {\n    // Note: this optimization works in async=false mode only\n    if (this.isLabelsRenderRequired(opt)) {\n      this.renderLabels();\n    } else {\n      this.updateLabels();\n    }\n  },\n  // Rendering.\n  // ----------\n\n  render: function () {\n    this.vel.empty();\n    this.unmountLabels();\n    this._V = {};\n    this.renderMarkup();\n    // rendering labels has to be run after the link is appended to DOM tree. (otherwise <Text> bbox\n    // returns zero values)\n    this.renderLabels();\n    this.update();\n    return this;\n  },\n  renderMarkup: function () {\n    var link = this.model;\n    var markup = link.get('markup') || link.markup;\n    if (!markup) throw new Error('dia.LinkView: markup required');\n    if (Array.isArray(markup)) return this.renderJSONMarkup(markup);\n    if (typeof markup === 'string') return this.renderStringMarkup(markup);\n    throw new Error('dia.LinkView: invalid markup');\n  },\n  renderJSONMarkup: function (markup) {\n    var doc = this.parseDOMJSON(markup, this.el);\n    // Selectors\n    this.selectors = doc.selectors;\n    // Fragment\n    this.vel.append(doc.fragment);\n  },\n  renderStringMarkup: function (markup) {\n    // A special markup can be given in the `properties.markup` property. This might be handy\n    // if e.g. arrowhead markers should be `<image>` elements or any other element than `<path>`s.\n    // `.connection`, `.connection-wrap`, `.marker-source` and `.marker-target` selectors\n    // of elements with special meaning though. Therefore, those classes should be preserved in any\n    // special markup passed in `properties.markup`.\n    var children = V(markup);\n    // custom markup may contain only one children\n    if (!Array.isArray(children)) children = [children];\n    this.vel.append(children);\n  },\n  _getLabelMarkup: function (labelMarkup) {\n    if (!labelMarkup) return undefined;\n    if (Array.isArray(labelMarkup)) return this.parseDOMJSON(labelMarkup, null);\n    if (typeof labelMarkup === 'string') return this._getLabelStringMarkup(labelMarkup);\n    throw new Error('dia.linkView: invalid label markup');\n  },\n  _getLabelStringMarkup: function (labelMarkup) {\n    var children = V(labelMarkup);\n    var fragment = document.createDocumentFragment();\n    if (!Array.isArray(children)) {\n      fragment.appendChild(children.node);\n    } else {\n      for (var i = 0, n = children.length; i < n; i++) {\n        var currentChild = children[i].node;\n        fragment.appendChild(currentChild);\n      }\n    }\n    return {\n      fragment: fragment,\n      selectors: {}\n    }; // no selectors\n  },\n  // Label markup fragment may come wrapped in <g class=\"label\" />, or not.\n  // If it doesn't, add the <g /> container here.\n  _normalizeLabelMarkup: function (markup) {\n    if (!markup) return undefined;\n    var fragment = markup.fragment;\n    if (!(markup.fragment instanceof DocumentFragment) || !markup.fragment.hasChildNodes()) throw new Error('dia.LinkView: invalid label markup.');\n    var vNode;\n    var childNodes = fragment.childNodes;\n    if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== 'G') {\n      // default markup fragment is not wrapped in <g />\n      // add a <g /> container\n      vNode = V('g').append(fragment);\n    } else {\n      vNode = V(childNodes[0]);\n    }\n    vNode.addClass('label');\n    return {\n      node: vNode.node,\n      selectors: markup.selectors\n    };\n  },\n  renderLabels: function () {\n    var cache = this._V;\n    var vLabels = cache.labels;\n    var labelCache = this._labelCache = {};\n    var labelSelectors = this._labelSelectors = {};\n    var model = this.model;\n    var labels = model.attributes.labels || [];\n    var labelsCount = labels.length;\n    if (labelsCount === 0) {\n      if (vLabels) vLabels.remove();\n      return this;\n    }\n    if (vLabels) {\n      vLabels.empty();\n    } else {\n      // there is no label container in the markup but some labels are defined\n      // add a <g class=\"labels\" /> container\n      vLabels = cache.labels = V('g').addClass('labels');\n      if (this.options.labelsLayer) {\n        vLabels.addClass(addClassNamePrefix(result(this, 'className')));\n        vLabels.attr('model-id', model.id);\n      }\n    }\n    for (var i = 0; i < labelsCount; i++) {\n      var label = labels[i];\n      var labelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(label.markup));\n      var labelNode;\n      var selectors;\n      if (labelMarkup) {\n        labelNode = labelMarkup.node;\n        selectors = labelMarkup.selectors;\n      } else {\n        var builtinDefaultLabel = model._builtins.defaultLabel;\n        var builtinDefaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(builtinDefaultLabel.markup));\n        var defaultLabel = model._getDefaultLabel();\n        var defaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(defaultLabel.markup));\n        var defaultMarkup = defaultLabelMarkup || builtinDefaultLabelMarkup;\n        labelNode = defaultMarkup.node;\n        selectors = defaultMarkup.selectors;\n      }\n      labelNode.setAttribute('label-idx', i); // assign label-idx\n      vLabels.append(labelNode);\n      labelCache[i] = labelNode; // cache node for `updateLabels()` so it can just update label node positions\n\n      var rootSelector = this.selector;\n      if (selectors[rootSelector]) throw new Error('dia.LinkView: ambiguous label root selector.');\n      selectors[rootSelector] = labelNode;\n      labelSelectors[i] = selectors; // cache label selectors for `updateLabels()`\n    }\n    if (!vLabels.parent()) {\n      this.mountLabels();\n    }\n    this.updateLabels();\n    return this;\n  },\n  mountLabels: function () {\n    const {\n      el,\n      paper,\n      model,\n      _V,\n      options\n    } = this;\n    const {\n      labels: vLabels\n    } = _V;\n    if (!vLabels || !model.hasLabels()) return;\n    const {\n      node\n    } = vLabels;\n    if (options.labelsLayer) {\n      paper.getLayerView(options.labelsLayer).insertSortedNode(node, model.get('z'));\n    } else {\n      if (node.parentNode !== el) {\n        el.appendChild(node);\n      }\n    }\n  },\n  unmountLabels: function () {\n    const {\n      options,\n      _V\n    } = this;\n    if (!_V) return;\n    const {\n      labels: vLabels\n    } = _V;\n    if (vLabels && options.labelsLayer) {\n      vLabels.remove();\n    }\n  },\n  findLabelNodes: function (labelIndex, selector) {\n    const labelRoot = this._labelCache[labelIndex];\n    if (!labelRoot) return [];\n    const labelSelectors = this._labelSelectors[labelIndex];\n    return this.findBySelector(selector, labelRoot, labelSelectors);\n  },\n  findLabelNode: function (labelIndex, selector) {\n    const [node = null] = this.findLabelNodes(labelIndex, selector);\n    return node;\n  },\n  // merge default label attrs into label attrs (or use built-in default label attrs if neither is provided)\n  // keep `undefined` or `null` because `{}` means something else\n  _mergeLabelAttrs: function (hasCustomMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs) {\n    if (labelAttrs === null) return null;\n    if (labelAttrs === undefined) {\n      if (defaultLabelAttrs === null) return null;\n      if (defaultLabelAttrs === undefined) {\n        if (hasCustomMarkup) return undefined;\n        return builtinDefaultLabelAttrs;\n      }\n      if (hasCustomMarkup) return defaultLabelAttrs;\n      return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs);\n    }\n    if (hasCustomMarkup) return merge({}, defaultLabelAttrs, labelAttrs);\n    return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs, labelAttrs);\n  },\n  // merge default label size into label size (no built-in default)\n  // keep `undefined` or `null` because `{}` means something else\n  _mergeLabelSize: function (labelSize, defaultLabelSize) {\n    if (labelSize === null) return null;\n    if (labelSize === undefined) {\n      if (defaultLabelSize === null) return null;\n      if (defaultLabelSize === undefined) return undefined;\n      return defaultLabelSize;\n    }\n    return merge({}, defaultLabelSize, labelSize);\n  },\n  updateLabels: function () {\n    if (!this._V.labels) return this;\n    var model = this.model;\n    var labels = model.get('labels') || [];\n    var canLabelMove = this.can('labelMove');\n    var builtinDefaultLabel = model._builtins.defaultLabel;\n    var builtinDefaultLabelAttrs = builtinDefaultLabel.attrs;\n    var defaultLabel = model._getDefaultLabel();\n    var defaultLabelMarkup = defaultLabel.markup;\n    var defaultLabelAttrs = defaultLabel.attrs;\n    var defaultLabelSize = defaultLabel.size;\n    for (var i = 0, n = labels.length; i < n; i++) {\n      var labelNode = this._labelCache[i];\n      labelNode.setAttribute('cursor', canLabelMove ? 'move' : 'default');\n      var selectors = this._labelSelectors[i];\n      var label = labels[i];\n      var labelMarkup = label.markup;\n      var labelAttrs = label.attrs;\n      var labelSize = label.size;\n      var attrs = this._mergeLabelAttrs(labelMarkup || defaultLabelMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs);\n      var size = this._mergeLabelSize(labelSize, defaultLabelSize);\n      this.updateDOMSubtreeAttributes(labelNode, attrs, {\n        rootBBox: new Rect(size),\n        selectors: selectors\n      });\n    }\n    return this;\n  },\n  // remove vertices that lie on (or nearly on) straight lines within the link\n  // return the number of removed points\n  removeRedundantLinearVertices: function (opt) {\n    const SIMPLIFY_THRESHOLD = 0.001;\n    const link = this.model;\n    const vertices = link.vertices();\n    const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor];\n    const numRoutePoints = routePoints.length;\n\n    // put routePoints into a polyline and try to simplify\n    const polyline = new Polyline(routePoints);\n    polyline.simplify({\n      threshold: SIMPLIFY_THRESHOLD\n    });\n    const polylinePoints = polyline.points.map(point => point.toJSON()); // JSON of points after simplification\n    const numPolylinePoints = polylinePoints.length; // number of points after simplification\n\n    // shortcut if simplification did not remove any redundant vertices:\n    if (numRoutePoints === numPolylinePoints) return 0;\n\n    // else: set simplified polyline points as link vertices\n    // remove first and last polyline points again (= source/target anchors)\n    link.vertices(polylinePoints.slice(1, numPolylinePoints - 1), opt);\n    return numRoutePoints - numPolylinePoints;\n  },\n  getEndView: function (type) {\n    switch (type) {\n      case 'source':\n        return this.sourceView || null;\n      case 'target':\n        return this.targetView || null;\n      default:\n        throw new Error('dia.LinkView: type parameter required.');\n    }\n  },\n  getEndAnchor: function (type) {\n    switch (type) {\n      case 'source':\n        return new Point(this.sourceAnchor);\n      case 'target':\n        return new Point(this.targetAnchor);\n      default:\n        throw new Error('dia.LinkView: type parameter required.');\n    }\n  },\n  getEndConnectionPoint: function (type) {\n    switch (type) {\n      case 'source':\n        return new Point(this.sourcePoint);\n      case 'target':\n        return new Point(this.targetPoint);\n      default:\n        throw new Error('dia.LinkView: type parameter required.');\n    }\n  },\n  getEndMagnet: function (type) {\n    switch (type) {\n      case 'source':\n        var sourceView = this.sourceView;\n        if (!sourceView) break;\n        return this.sourceMagnet || sourceView.el;\n      case 'target':\n        var targetView = this.targetView;\n        if (!targetView) break;\n        return this.targetMagnet || targetView.el;\n      default:\n        throw new Error('dia.LinkView: type parameter required.');\n    }\n    return null;\n  },\n  // Updating.\n  // ---------\n\n  update: function () {\n    this.updateRoute();\n    this.updatePath();\n    this.updateDOM();\n    return this;\n  },\n  translate: function (tx = 0, ty = 0) {\n    const {\n      route,\n      path\n    } = this;\n    if (!route || !path) return;\n    // translate the route\n    const polyline = new Polyline(route);\n    polyline.translate(tx, ty);\n    this.route = polyline.points;\n    // translate source and target connection and anchor points.\n    this.sourcePoint.offset(tx, ty);\n    this.targetPoint.offset(tx, ty);\n    this.sourceAnchor.offset(tx, ty);\n    this.targetAnchor.offset(tx, ty);\n    // translate the geometry path\n    path.translate(tx, ty);\n    this.updateDOM();\n  },\n  updateDOM() {\n    const {\n      el,\n      model,\n      selectors\n    } = this;\n    this.cleanNodesCache();\n    // update SVG attributes defined by 'attrs/'.\n    this.updateDOMSubtreeAttributes(el, model.attr(), {\n      selectors\n    });\n    // update the label position etc.\n    this.updateLabelPositions();\n    // *Deprecated*\n    // Local perpendicular flag (as opposed to one defined on paper).\n    // Could be enabled inside a connector/router. It's valid only\n    // during the update execution.\n    this.options.perpendicular = null;\n  },\n  updateRoute: function () {\n    const {\n      model\n    } = this;\n    const vertices = model.vertices();\n    // 1. Find Anchors\n    const anchors = this.findAnchors(vertices);\n    const sourceAnchor = this.sourceAnchor = anchors.source;\n    const targetAnchor = this.targetAnchor = anchors.target;\n    // 2. Find Route\n    const route = this.findRoute(vertices);\n    this.route = route;\n    // 3. Find Connection Points\n    var connectionPoints = this.findConnectionPoints(route, sourceAnchor, targetAnchor);\n    this.sourcePoint = connectionPoints.source;\n    this.targetPoint = connectionPoints.target;\n  },\n  updatePath: function () {\n    const {\n      route,\n      sourcePoint,\n      targetPoint\n    } = this;\n    // 4. Find Connection\n    const path = this.findPath(route, sourcePoint.clone(), targetPoint.clone());\n    this.path = path;\n  },\n  findAnchorsOrdered: function (firstEndType, firstRef, secondEndType, secondRef) {\n    var firstAnchor, secondAnchor;\n    var firstAnchorRef, secondAnchorRef;\n    var model = this.model;\n    var firstDef = model.get(firstEndType);\n    var secondDef = model.get(secondEndType);\n    var firstView = this.getEndView(firstEndType);\n    var secondView = this.getEndView(secondEndType);\n    var firstMagnet = this.getEndMagnet(firstEndType);\n    var secondMagnet = this.getEndMagnet(secondEndType);\n\n    // Anchor first\n    if (firstView) {\n      if (firstRef) {\n        firstAnchorRef = new Point(firstRef);\n      } else if (secondView) {\n        firstAnchorRef = secondMagnet;\n      } else {\n        firstAnchorRef = new Point(secondDef);\n      }\n      firstAnchor = this.getAnchor(firstDef.anchor, firstView, firstMagnet, firstAnchorRef, firstEndType);\n    } else {\n      firstAnchor = new Point(firstDef);\n    }\n\n    // Anchor second\n    if (secondView) {\n      secondAnchorRef = new Point(secondRef || firstAnchor);\n      secondAnchor = this.getAnchor(secondDef.anchor, secondView, secondMagnet, secondAnchorRef, secondEndType);\n    } else {\n      secondAnchor = new Point(secondDef);\n    }\n    var res = {};\n    res[firstEndType] = firstAnchor;\n    res[secondEndType] = secondAnchor;\n    return res;\n  },\n  findAnchors: function (vertices) {\n    var model = this.model;\n    var firstVertex = vertices[0];\n    var lastVertex = vertices[vertices.length - 1];\n    if (model.target().priority && !model.source().priority) {\n      // Reversed order\n      return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);\n    }\n\n    // Usual order\n    return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);\n  },\n  findConnectionPoints: function (route, sourceAnchor, targetAnchor) {\n    var firstWaypoint = route[0];\n    var lastWaypoint = route[route.length - 1];\n    var model = this.model;\n    var sourceDef = model.get('source');\n    var targetDef = model.get('target');\n    var sourceView = this.sourceView;\n    var targetView = this.targetView;\n    var paperOptions = this.paper.options;\n    var sourceMagnet, targetMagnet;\n\n    // Connection Point Source\n    var sourcePoint;\n    if (sourceView && !sourceView.isNodeConnection(this.sourceMagnet)) {\n      sourceMagnet = this.sourceMagnet || sourceView.el;\n      var sourceConnectionPointDef = sourceDef.connectionPoint || paperOptions.defaultConnectionPoint;\n      var sourcePointRef = firstWaypoint || targetAnchor;\n      var sourceLine = new Line(sourcePointRef, sourceAnchor);\n      sourcePoint = this.getConnectionPoint(sourceConnectionPointDef, sourceView, sourceMagnet, sourceLine, 'source');\n    } else {\n      sourcePoint = sourceAnchor;\n    }\n    // Connection Point Target\n    var targetPoint;\n    if (targetView && !targetView.isNodeConnection(this.targetMagnet)) {\n      targetMagnet = this.targetMagnet || targetView.el;\n      var targetConnectionPointDef = targetDef.connectionPoint || paperOptions.defaultConnectionPoint;\n      var targetPointRef = lastWaypoint || sourceAnchor;\n      var targetLine = new Line(targetPointRef, targetAnchor);\n      targetPoint = this.getConnectionPoint(targetConnectionPointDef, targetView, targetMagnet, targetLine, 'target');\n    } else {\n      targetPoint = targetAnchor;\n    }\n    return {\n      source: sourcePoint,\n      target: targetPoint\n    };\n  },\n  getAnchor: function (anchorDef, cellView, magnet, ref, endType) {\n    var isConnection = cellView.isNodeConnection(magnet);\n    var paperOptions = this.paper.options;\n    if (!anchorDef) {\n      if (isConnection) {\n        anchorDef = paperOptions.defaultLinkAnchor;\n      } else {\n        if (this.options.perpendicular) {\n          // Backwards compatibility\n          // See `manhattan` router for more details\n          anchorDef = {\n            name: 'perpendicular'\n          };\n        } else {\n          anchorDef = paperOptions.defaultAnchor;\n        }\n      }\n    }\n    if (!anchorDef) throw new Error('Anchor required.');\n    var anchorFn;\n    if (typeof anchorDef === 'function') {\n      anchorFn = anchorDef;\n    } else {\n      var anchorName = anchorDef.name;\n      var anchorNamespace = isConnection ? 'linkAnchorNamespace' : 'anchorNamespace';\n      anchorFn = paperOptions[anchorNamespace][anchorName];\n      if (typeof anchorFn !== 'function') throw new Error('Unknown anchor: ' + anchorName);\n    }\n    var anchor = anchorFn.call(this, cellView, magnet, ref, anchorDef.args || {}, endType, this);\n    if (!anchor) return new Point();\n    return anchor.round(this.decimalsRounding);\n  },\n  getConnectionPoint: function (connectionPointDef, view, magnet, line, endType) {\n    var connectionPoint;\n    var anchor = line.end;\n    var paperOptions = this.paper.options;\n    if (!connectionPointDef) return anchor;\n    var connectionPointFn;\n    if (typeof connectionPointDef === 'function') {\n      connectionPointFn = connectionPointDef;\n    } else {\n      var connectionPointName = connectionPointDef.name;\n      connectionPointFn = paperOptions.connectionPointNamespace[connectionPointName];\n      if (typeof connectionPointFn !== 'function') throw new Error('Unknown connection point: ' + connectionPointName);\n    }\n    connectionPoint = connectionPointFn.call(this, line, view, magnet, connectionPointDef.args || {}, endType, this);\n    if (!connectionPoint) return anchor;\n    return connectionPoint.round(this.decimalsRounding);\n  },\n  // combine default label position with built-in default label position\n  _getDefaultLabelPositionProperty: function () {\n    var model = this.model;\n    var builtinDefaultLabel = model._builtins.defaultLabel;\n    var builtinDefaultLabelPosition = builtinDefaultLabel.position;\n    var defaultLabel = model._getDefaultLabel();\n    var defaultLabelPosition = this._normalizeLabelPosition(defaultLabel.position);\n    return merge({}, builtinDefaultLabelPosition, defaultLabelPosition);\n  },\n  // if label position is a number, normalize it to a position object\n  // this makes sure that label positions can be merged properly\n  _normalizeLabelPosition: function (labelPosition) {\n    if (typeof labelPosition === 'number') return {\n      distance: labelPosition,\n      offset: null,\n      angle: 0,\n      args: null\n    };\n    return labelPosition;\n  },\n  // expects normalized position properties\n  // e.g. `this._normalizeLabelPosition(labelPosition)` and `this._getDefaultLabelPositionProperty()`\n  _mergeLabelPositionProperty: function (normalizedLabelPosition, normalizedDefaultLabelPosition) {\n    if (normalizedLabelPosition === null) return null;\n    if (normalizedLabelPosition === undefined) {\n      if (normalizedDefaultLabelPosition === null) return null;\n      return normalizedDefaultLabelPosition;\n    }\n    return merge({}, normalizedDefaultLabelPosition, normalizedLabelPosition);\n  },\n  updateLabelPositions: function () {\n    if (!this._V.labels) return this;\n    var path = this.path;\n    if (!path) return this;\n\n    // This method assumes all the label nodes are stored in the `this._labelCache` hash table\n    // by their indices in the `this.get('labels')` array. This is done in the `renderLabels()` method.\n\n    var model = this.model;\n    var labels = model.get('labels') || [];\n    if (!labels.length) return this;\n    var defaultLabelPosition = this._getDefaultLabelPositionProperty();\n    for (var idx = 0, n = labels.length; idx < n; idx++) {\n      var labelNode = this._labelCache[idx];\n      if (!labelNode) continue;\n      var label = labels[idx];\n      var labelPosition = this._normalizeLabelPosition(label.position);\n      var position = this._mergeLabelPositionProperty(labelPosition, defaultLabelPosition);\n      var transformationMatrix = this._getLabelTransformationMatrix(position);\n      labelNode.setAttribute('transform', V.matrixToTransformString(transformationMatrix));\n      this._cleanLabelMatrices(idx);\n    }\n    return this;\n  },\n  _cleanLabelMatrices: function (index) {\n    // Clean magnetMatrix for all nodes of the label.\n    // Cached BoundingRect does not need to updated when the position changes\n    // TODO: this doesn't work for labels with XML String markups.\n    const {\n      metrics,\n      _labelSelectors\n    } = this;\n    const selectors = _labelSelectors[index];\n    if (!selectors) return;\n    for (let selector in selectors) {\n      const {\n        id\n      } = selectors[selector];\n      if (id && id in metrics) delete metrics[id].magnetMatrix;\n    }\n  },\n  updateEndProperties: function (endType) {\n    const {\n      model,\n      paper\n    } = this;\n    const endViewProperty = `${endType}View`;\n    const endDef = model.get(endType);\n    const endId = endDef && endDef.id;\n    if (!endId) {\n      // the link end is a point ~ rect 0x0\n      this[endViewProperty] = null;\n      this.updateEndMagnet(endType);\n      return true;\n    }\n    const endModel = paper.getModelById(endId);\n    if (!endModel) throw new Error('LinkView: invalid ' + endType + ' cell.');\n    const endView = endModel.findView(paper);\n    if (!endView) {\n      // A view for a model should always exist\n      return false;\n    }\n    this[endViewProperty] = endView;\n    this.updateEndMagnet(endType);\n    return true;\n  },\n  updateEndMagnet: function (endType) {\n    const endMagnetProperty = `${endType}Magnet`;\n    const endView = this.getEndView(endType);\n    if (endView) {\n      let connectedMagnet = endView.getMagnetFromLinkEnd(this.model.get(endType));\n      if (connectedMagnet === endView.el) connectedMagnet = null;\n      this[endMagnetProperty] = connectedMagnet;\n    } else {\n      this[endMagnetProperty] = null;\n    }\n  },\n  _getLabelPositionProperty: function (idx) {\n    return this.model.label(idx).position || {};\n  },\n  _getLabelPositionAngle: function (idx) {\n    var labelPosition = this._getLabelPositionProperty(idx);\n    return labelPosition.angle || 0;\n  },\n  _getLabelPositionArgs: function (idx) {\n    var labelPosition = this._getLabelPositionProperty(idx);\n    return labelPosition.args;\n  },\n  _getDefaultLabelPositionArgs: function () {\n    var defaultLabel = this.model._getDefaultLabel();\n    var defaultLabelPosition = defaultLabel.position || {};\n    return defaultLabelPosition.args;\n  },\n  // merge default label position args into label position args\n  // keep `undefined` or `null` because `{}` means something else\n  _mergeLabelPositionArgs: function (labelPositionArgs, defaultLabelPositionArgs) {\n    if (labelPositionArgs === null) return null;\n    if (labelPositionArgs === undefined) {\n      if (defaultLabelPositionArgs === null) return null;\n      return defaultLabelPositionArgs;\n    }\n    return merge({}, defaultLabelPositionArgs, labelPositionArgs);\n  },\n  // Add default label at given position at end of `labels` array.\n  // Four signatures:\n  // - obj, obj = point, opt\n  // - obj, num, obj = point, angle, opt\n  // - num, num, obj = x, y, opt\n  // - num, num, num, obj = x, y, angle, opt\n  // Assigns relative coordinates by default:\n  // `opt.absoluteDistance` forces absolute coordinates.\n  // `opt.reverseDistance` forces reverse absolute coordinates (if absoluteDistance = true).\n  // `opt.absoluteOffset` forces absolute coordinates for offset.\n  // Additional args:\n  // `opt.keepGradient` auto-adjusts the angle of the label to match path gradient at position.\n  // `opt.ensureLegibility` rotates labels so they are never upside-down.\n  addLabel: function (p1, p2, p3, p4) {\n    // normalize data from the four possible signatures\n    var localX;\n    var localY;\n    var localAngle = 0;\n    var localOpt;\n    if (typeof p1 !== 'number') {\n      // {x, y} object provided as first parameter\n      localX = p1.x;\n      localY = p1.y;\n      if (typeof p2 === 'number') {\n        // angle and opt provided as second and third parameters\n        localAngle = p2;\n        localOpt = p3;\n      } else {\n        // opt provided as second parameter\n        localOpt = p2;\n      }\n    } else {\n      // x and y provided as first and second parameters\n      localX = p1;\n      localY = p2;\n      if (typeof p3 === 'number') {\n        // angle and opt provided as third and fourth parameters\n        localAngle = p3;\n        localOpt = p4;\n      } else {\n        // opt provided as third parameter\n        localOpt = p3;\n      }\n    }\n\n    // merge label position arguments\n    var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n    var labelPositionArgs = localOpt;\n    var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n\n    // append label to labels array\n    var label = {\n      position: this.getLabelPosition(localX, localY, localAngle, positionArgs)\n    };\n    var idx = -1;\n    this.model.insertLabel(idx, label, localOpt);\n    return idx;\n  },\n  // Add a new vertex at calculated index to the `vertices` array.\n  addVertex: function (x, y, opt) {\n    // accept input in form `{ x, y }, opt` or `x, y, opt`\n    var isPointProvided = typeof x !== 'number';\n    var localX = isPointProvided ? x.x : x;\n    var localY = isPointProvided ? x.y : y;\n    var localOpt = isPointProvided ? y : opt;\n    var vertex = {\n      x: localX,\n      y: localY\n    };\n    var idx = this.getVertexIndex(localX, localY);\n    this.model.insertVertex(idx, vertex, localOpt);\n    return idx;\n  },\n  // Send a token (an SVG element, usually a circle) along the connection path.\n  // Example: `link.findView(paper).sendToken(V('circle', { r: 7, fill: 'green' }).node)`\n  // `opt.duration` is optional and is a time in milliseconds that the token travels from the source to the target of the link. Default is `1000`.\n  // `opt.direction` is optional and it determines whether the token goes from source to target or other way round (`reverse`)\n  // `opt.connection` is an optional selector to the connection path.\n  // `callback` is optional and is a function to be called once the token reaches the target.\n  sendToken: function (token, opt, callback) {\n    function onAnimationEnd(vToken, callback) {\n      return function () {\n        vToken.remove();\n        if (typeof callback === 'function') {\n          callback();\n        }\n      };\n    }\n    var duration, isReversed, selector;\n    if (isObject(opt)) {\n      duration = opt.duration;\n      isReversed = opt.direction === 'reverse';\n      selector = opt.connection;\n    } else {\n      // Backwards compatibility\n      duration = opt;\n      isReversed = false;\n      selector = null;\n    }\n    duration = duration || 1000;\n    var animationAttributes = {\n      dur: duration + 'ms',\n      repeatCount: 1,\n      calcMode: 'linear',\n      fill: 'freeze'\n    };\n    if (isReversed) {\n      animationAttributes.keyPoints = '1;0';\n      animationAttributes.keyTimes = '0;1';\n    }\n    var vToken = V(token);\n    var connection;\n    if (typeof selector === 'string') {\n      // Use custom connection path.\n      connection = this.findNode(selector);\n    } else {\n      // Select connection path automatically.\n      var cache = this._V;\n      connection = cache.connection ? cache.connection.node : this.el.querySelector('path');\n    }\n    if (!(connection instanceof SVGPathElement)) {\n      throw new Error('dia.LinkView: token animation requires a valid connection path.');\n    }\n    vToken.appendTo(this.paper.cells).animateAlongPath(animationAttributes, connection);\n    setTimeout(onAnimationEnd(vToken, callback), duration);\n  },\n  findRoute: function (vertices) {\n    vertices || (vertices = []);\n    var namespace = this.paper.options.routerNamespace || routers;\n    var router = this.model.router();\n    var defaultRouter = this.paper.options.defaultRouter;\n    if (!router) {\n      if (defaultRouter) router = defaultRouter;else return vertices.map(Point); // no router specified\n    }\n    var routerFn = isFunction(router) ? router : namespace[router.name];\n    if (!isFunction(routerFn)) {\n      throw new Error('dia.LinkView: unknown router: \"' + router.name + '\".');\n    }\n    var args = router.args || {};\n    var route = routerFn.call(this,\n    // context\n    vertices,\n    // vertices\n    args,\n    // options\n    this // linkView\n    );\n    if (!route) return vertices.map(Point);\n    return route;\n  },\n  // Return the `d` attribute value of the `<path>` element representing the link\n  // between `source` and `target`.\n  findPath: function (route, sourcePoint, targetPoint) {\n    var namespace = this.paper.options.connectorNamespace || connectors;\n    var connector = this.model.connector();\n    var defaultConnector = this.paper.options.defaultConnector;\n    if (!connector) {\n      connector = defaultConnector || {};\n    }\n    var connectorFn = isFunction(connector) ? connector : namespace[connector.name];\n    if (!isFunction(connectorFn)) {\n      throw new Error('dia.LinkView: unknown connector: \"' + connector.name + '\".');\n    }\n    var args = clone(connector.args || {});\n    args.raw = true; // Request raw g.Path as the result.\n\n    var path = connectorFn.call(this,\n    // context\n    sourcePoint,\n    // start point\n    targetPoint,\n    // end point\n    route,\n    // vertices\n    args,\n    // options\n    this // linkView\n    );\n    if (typeof path === 'string') {\n      // Backwards compatibility for connectors not supporting `raw` option.\n      path = new Path(V.normalizePathData(path));\n    }\n    return path;\n  },\n  // Public API.\n  // -----------\n\n  getConnection: function () {\n    var path = this.path;\n    if (!path) return null;\n    return path.clone();\n  },\n  getSerializedConnection: function () {\n    var path = this.path;\n    if (!path) return null;\n    var metrics = this.metrics;\n    if (metrics.hasOwnProperty('data')) return metrics.data;\n    var data = path.serialize();\n    metrics.data = data;\n    return data;\n  },\n  getConnectionSubdivisions: function () {\n    var path = this.path;\n    if (!path) return null;\n    var metrics = this.metrics;\n    if (metrics.hasOwnProperty('segmentSubdivisions')) return metrics.segmentSubdivisions;\n    var subdivisions = path.getSegmentSubdivisions();\n    metrics.segmentSubdivisions = subdivisions;\n    return subdivisions;\n  },\n  getConnectionLength: function () {\n    var path = this.path;\n    if (!path) return 0;\n    var metrics = this.metrics;\n    if (metrics.hasOwnProperty('length')) return metrics.length;\n    var length = path.length({\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n    metrics.length = length;\n    return length;\n  },\n  getPointAtLength: function (length) {\n    var path = this.path;\n    if (!path) return null;\n    return path.pointAtLength(length, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  },\n  getPointAtRatio: function (ratio) {\n    var path = this.path;\n    if (!path) return null;\n    if (isPercentage(ratio)) ratio = parseFloat(ratio) / 100;\n    return path.pointAt(ratio, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  },\n  getTangentAtLength: function (length) {\n    var path = this.path;\n    if (!path) return null;\n    return path.tangentAtLength(length, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  },\n  getTangentAtRatio: function (ratio) {\n    var path = this.path;\n    if (!path) return null;\n    return path.tangentAt(ratio, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  },\n  getClosestPoint: function (point) {\n    var path = this.path;\n    if (!path) return null;\n    return path.closestPoint(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  },\n  getClosestPointLength: function (point) {\n    var path = this.path;\n    if (!path) return null;\n    return path.closestPointLength(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  },\n  getClosestPointRatio: function (point) {\n    var path = this.path;\n    if (!path) return null;\n    return path.closestPointNormalizedLength(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  },\n  // Get label position object based on two provided coordinates, x and y.\n  // (Used behind the scenes when user moves labels around.)\n  // Two signatures:\n  // - num, num, obj = x, y, options\n  // - num, num, num, obj = x, y, angle, options\n  // Accepts distance/offset options = `absoluteDistance: boolean`, `reverseDistance: boolean`, `absoluteOffset: boolean`\n  // - `absoluteOffset` is necessary in order to move beyond connection endpoints\n  // Additional options = `keepGradient: boolean`, `ensureLegibility: boolean`\n  getLabelPosition: function (x, y, p3, p4) {\n    var position = {};\n\n    // normalize data from the two possible signatures\n    var localAngle = 0;\n    var localOpt;\n    if (typeof p3 === 'number') {\n      // angle and opt provided as third and fourth argument\n      localAngle = p3;\n      localOpt = p4;\n    } else {\n      // opt provided as third argument\n      localOpt = p3;\n    }\n\n    // save localOpt as `args` of the position object that is passed along\n    if (localOpt) position.args = localOpt;\n\n    // identify distance/offset settings\n    var isDistanceRelative = !(localOpt && localOpt.absoluteDistance); // relative by default\n    var isDistanceAbsoluteReverse = localOpt && localOpt.absoluteDistance && localOpt.reverseDistance; // non-reverse by default\n    var isOffsetAbsolute = localOpt && localOpt.absoluteOffset; // offset is non-absolute by default\n\n    // find closest point t\n    var path = this.path;\n    var pathOpt = {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    };\n    var labelPoint = new Point(x, y);\n    var t = path.closestPointT(labelPoint, pathOpt);\n\n    // DISTANCE:\n    var labelDistance = path.lengthAtT(t, pathOpt);\n    if (isDistanceRelative) labelDistance = labelDistance / this.getConnectionLength() || 0; // fix to prevent NaN for 0 length\n    if (isDistanceAbsoluteReverse) labelDistance = -1 * (this.getConnectionLength() - labelDistance) || 1; // fix for end point (-0 => 1)\n    position.distance = labelDistance;\n\n    // OFFSET:\n    // use absolute offset if:\n    // - opt.absoluteOffset is true,\n    // - opt.absoluteOffset is not true but there is no tangent\n    var tangent;\n    if (!isOffsetAbsolute) tangent = path.tangentAtT(t);\n    var labelOffset;\n    if (tangent) {\n      labelOffset = tangent.pointOffset(labelPoint);\n    } else {\n      var closestPoint = path.pointAtT(t);\n      var labelOffsetDiff = labelPoint.difference(closestPoint);\n      labelOffset = {\n        x: labelOffsetDiff.x,\n        y: labelOffsetDiff.y\n      };\n    }\n    position.offset = labelOffset;\n\n    // ANGLE:\n    position.angle = localAngle;\n    return position;\n  },\n  _getLabelTransformationMatrix: function (labelPosition) {\n    var labelDistance;\n    var labelAngle = 0;\n    var args = {};\n    if (typeof labelPosition === 'number') {\n      labelDistance = labelPosition;\n    } else if (typeof labelPosition.distance === 'number') {\n      args = labelPosition.args || {};\n      labelDistance = labelPosition.distance;\n      labelAngle = labelPosition.angle || 0;\n    } else {\n      throw new Error('dia.LinkView: invalid label position distance.');\n    }\n    var isDistanceRelative = labelDistance > 0 && labelDistance <= 1;\n    var labelOffset = 0;\n    var labelOffsetCoordinates = {\n      x: 0,\n      y: 0\n    };\n    if (labelPosition.offset) {\n      var positionOffset = labelPosition.offset;\n      if (typeof positionOffset === 'number') labelOffset = positionOffset;\n      if (positionOffset.x) labelOffsetCoordinates.x = positionOffset.x;\n      if (positionOffset.y) labelOffsetCoordinates.y = positionOffset.y;\n    }\n    var isOffsetAbsolute = labelOffsetCoordinates.x !== 0 || labelOffsetCoordinates.y !== 0 || labelOffset === 0;\n    var isKeepGradient = args.keepGradient;\n    var isEnsureLegibility = args.ensureLegibility;\n    var path = this.path;\n    var pathOpt = {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    };\n    var distance = isDistanceRelative ? labelDistance * this.getConnectionLength() : labelDistance;\n    var tangent = path.tangentAtLength(distance, pathOpt);\n    var translation;\n    var angle = labelAngle;\n    if (tangent) {\n      if (isOffsetAbsolute) {\n        translation = tangent.start.clone();\n        translation.offset(labelOffsetCoordinates);\n      } else {\n        var normal = tangent.clone();\n        normal.rotate(tangent.start, -90);\n        normal.setLength(labelOffset);\n        translation = normal.end;\n      }\n      if (isKeepGradient) {\n        angle = tangent.angle() + labelAngle;\n        if (isEnsureLegibility) {\n          angle = normalizeAngle((angle + 90) % 180 - 90);\n        }\n      }\n    } else {\n      // fallback - the connection has zero length\n      translation = path.start.clone();\n      if (isOffsetAbsolute) translation.offset(labelOffsetCoordinates);\n    }\n    return V.createSVGMatrix().translate(translation.x, translation.y).rotate(angle);\n  },\n  getLabelCoordinates: function (labelPosition) {\n    var transformationMatrix = this._getLabelTransformationMatrix(labelPosition);\n    return new Point(transformationMatrix.e, transformationMatrix.f);\n  },\n  getVertexIndex: function (x, y) {\n    var model = this.model;\n    var vertices = model.vertices();\n    var vertexLength = this.getClosestPointLength(new Point(x, y));\n    var idx = 0;\n    for (var n = vertices.length; idx < n; idx++) {\n      var currentVertex = vertices[idx];\n      var currentVertexLength = this.getClosestPointLength(currentVertex);\n      if (vertexLength < currentVertexLength) break;\n    }\n    return idx;\n  },\n  // Interaction. The controller part.\n  // ---------------------------------\n\n  notifyPointerdown(evt, x, y) {\n    CellView.prototype.pointerdown.call(this, evt, x, y);\n    this.notify('link:pointerdown', evt, x, y);\n  },\n  notifyPointermove(evt, x, y) {\n    CellView.prototype.pointermove.call(this, evt, x, y);\n    this.notify('link:pointermove', evt, x, y);\n  },\n  notifyPointerup(evt, x, y) {\n    this.notify('link:pointerup', evt, x, y);\n    CellView.prototype.pointerup.call(this, evt, x, y);\n  },\n  pointerdblclick: function (evt, x, y) {\n    CellView.prototype.pointerdblclick.apply(this, arguments);\n    this.notify('link:pointerdblclick', evt, x, y);\n  },\n  pointerclick: function (evt, x, y) {\n    CellView.prototype.pointerclick.apply(this, arguments);\n    this.notify('link:pointerclick', evt, x, y);\n  },\n  contextmenu: function (evt, x, y) {\n    CellView.prototype.contextmenu.apply(this, arguments);\n    this.notify('link:contextmenu', evt, x, y);\n  },\n  pointerdown: function (evt, x, y) {\n    this.notifyPointerdown(evt, x, y);\n    this.dragStart(evt, x, y);\n  },\n  pointermove: function (evt, x, y) {\n    // Backwards compatibility\n    var dragData = this._dragData;\n    if (dragData) this.eventData(evt, dragData);\n    var data = this.eventData(evt);\n    switch (data.action) {\n      case 'label-move':\n        this.dragLabel(evt, x, y);\n        break;\n      case 'arrowhead-move':\n        this.dragArrowhead(evt, x, y);\n        break;\n      case 'move':\n        this.drag(evt, x, y);\n        break;\n    }\n\n    // Backwards compatibility\n    if (dragData) assign(dragData, this.eventData(evt));\n    this.notifyPointermove(evt, x, y);\n  },\n  pointerup: function (evt, x, y) {\n    // Backwards compatibility\n    var dragData = this._dragData;\n    if (dragData) {\n      this.eventData(evt, dragData);\n      this._dragData = null;\n    }\n    var data = this.eventData(evt);\n    switch (data.action) {\n      case 'label-move':\n        this.dragLabelEnd(evt, x, y);\n        break;\n      case 'arrowhead-move':\n        this.dragArrowheadEnd(evt, x, y);\n        break;\n      case 'move':\n        this.dragEnd(evt, x, y);\n    }\n    this.notifyPointerup(evt, x, y);\n    this.checkMouseleave(evt);\n  },\n  mouseover: function (evt) {\n    CellView.prototype.mouseover.apply(this, arguments);\n    this.notify('link:mouseover', evt);\n  },\n  mouseout: function (evt) {\n    CellView.prototype.mouseout.apply(this, arguments);\n    this.notify('link:mouseout', evt);\n  },\n  mouseenter: function (evt) {\n    CellView.prototype.mouseenter.apply(this, arguments);\n    this.notify('link:mouseenter', evt);\n  },\n  mouseleave: function (evt) {\n    CellView.prototype.mouseleave.apply(this, arguments);\n    this.notify('link:mouseleave', evt);\n  },\n  mousewheel: function (evt, x, y, delta) {\n    CellView.prototype.mousewheel.apply(this, arguments);\n    this.notify('link:mousewheel', evt, x, y, delta);\n  },\n  onlabel: function (evt, x, y) {\n    this.notifyPointerdown(evt, x, y);\n    this.dragLabelStart(evt, x, y);\n    var stopPropagation = this.eventData(evt).stopPropagation;\n    if (stopPropagation) evt.stopPropagation();\n  },\n  // Drag Start Handlers\n\n  dragLabelStart: function (evt, x, y) {\n    if (this.can('labelMove')) {\n      if (this.isDefaultInteractionPrevented(evt)) return;\n      var labelNode = evt.currentTarget;\n      var labelIdx = parseInt(labelNode.getAttribute('label-idx'), 10);\n      var defaultLabelPosition = this._getDefaultLabelPositionProperty();\n      var initialLabelPosition = this._normalizeLabelPosition(this._getLabelPositionProperty(labelIdx));\n      var position = this._mergeLabelPositionProperty(initialLabelPosition, defaultLabelPosition);\n      var coords = this.getLabelCoordinates(position);\n      var dx = coords.x - x; // how much needs to be added to cursor x to get to label x\n      var dy = coords.y - y; // how much needs to be added to cursor y to get to label y\n\n      var positionAngle = this._getLabelPositionAngle(labelIdx);\n      var labelPositionArgs = this._getLabelPositionArgs(labelIdx);\n      var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n      var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n      this.eventData(evt, {\n        action: 'label-move',\n        labelIdx: labelIdx,\n        dx: dx,\n        dy: dy,\n        positionAngle: positionAngle,\n        positionArgs: positionArgs,\n        stopPropagation: true\n      });\n    } else {\n      // Backwards compatibility:\n      // If labels can't be dragged no default action is triggered.\n      this.eventData(evt, {\n        stopPropagation: true\n      });\n    }\n    this.paper.delegateDragEvents(this, evt.data);\n  },\n  dragArrowheadStart: function (evt, x, y) {\n    if (!this.can('arrowheadMove')) return;\n    var arrowheadNode = evt.target;\n    var arrowheadType = arrowheadNode.getAttribute('end');\n    var data = this.startArrowheadMove(arrowheadType, {\n      ignoreBackwardsCompatibility: true\n    });\n    this.eventData(evt, data);\n  },\n  dragStart: function (evt, x, y) {\n    if (this.isDefaultInteractionPrevented(evt)) return;\n    if (!this.can('linkMove')) return;\n    this.eventData(evt, {\n      action: 'move',\n      dx: x,\n      dy: y\n    });\n  },\n  // Drag Handlers\n  dragLabel: function (evt, x, y) {\n    var data = this.eventData(evt);\n    var label = {\n      position: this.getLabelPosition(x + data.dx, y + data.dy, data.positionAngle, data.positionArgs)\n    };\n    if (this.paper.options.snapLabels) delete label.position.offset;\n    // The `touchmove' events are not fired\n    // when the original event target is removed from the DOM.\n    // The labels are currently re-rendered completely when only\n    // the position changes. This is why we need to make sure that\n    // the label is updated synchronously.\n    // TODO: replace `touchmove` with `pointermove` (breaking change).\n    const setOptions = {\n      ui: true\n    };\n    if (this.paper.isAsync() && evt.type === 'touchmove') {\n      setOptions.async = false;\n    }\n    this.model.label(data.labelIdx, label, setOptions);\n  },\n  dragArrowhead: function (evt, x, y) {\n    if (this.paper.options.snapLinks) {\n      const isSnapped = this._snapArrowhead(evt, x, y);\n      if (!isSnapped && this.paper.options.snapLinksSelf) {\n        this._snapArrowheadSelf(evt, x, y);\n      }\n    } else {\n      if (this.paper.options.snapLinksSelf) {\n        this._snapArrowheadSelf(evt, x, y);\n      } else {\n        this._connectArrowhead(this.getEventTarget(evt), x, y, this.eventData(evt));\n      }\n    }\n  },\n  drag: function (evt, x, y) {\n    var data = this.eventData(evt);\n    this.model.translate(x - data.dx, y - data.dy, {\n      ui: true\n    });\n    this.eventData(evt, {\n      dx: x,\n      dy: y\n    });\n  },\n  // Drag End Handlers\n\n  dragLabelEnd: function () {\n    // noop\n  },\n  dragArrowheadEnd: function (evt, x, y) {\n    var data = this.eventData(evt);\n    var paper = this.paper;\n    if (paper.options.snapLinks) {\n      this._snapArrowheadEnd(data);\n    } else {\n      this._connectArrowheadEnd(data, x, y);\n    }\n    if (!paper.linkAllowed(this)) {\n      // If the changed link is not allowed, revert to its previous state.\n      this._disallow(data);\n    } else {\n      this._finishEmbedding(data);\n      this._notifyConnectEvent(data, evt);\n    }\n    this._afterArrowheadMove(data);\n  },\n  dragEnd: function () {\n    // noop\n  },\n  _disallow: function (data) {\n    switch (data.whenNotAllowed) {\n      case 'remove':\n        this.model.remove({\n          ui: true\n        });\n        break;\n      case 'revert':\n      default:\n        this.model.set(data.arrowhead, data.initialEnd, {\n          ui: true\n        });\n        break;\n    }\n  },\n  _finishEmbedding: function (data) {\n    // Reparent the link if embedding is enabled\n    if (this.paper.options.embeddingMode && this.model.reparent()) {\n      // Make sure we don't reverse to the original 'z' index (see afterArrowheadMove()).\n      data.z = null;\n    }\n  },\n  _notifyConnectEvent: function (data, evt) {\n    var arrowhead = data.arrowhead;\n    var initialEnd = data.initialEnd;\n    var currentEnd = this.model.prop(arrowhead);\n    var endChanged = currentEnd && !Link.endsEqual(initialEnd, currentEnd);\n    if (endChanged) {\n      var paper = this.paper;\n      if (initialEnd.id) {\n        this.notify('link:disconnect', evt, paper.findViewByModel(initialEnd.id), data.initialMagnet, arrowhead);\n      }\n      if (currentEnd.id) {\n        this.notify('link:connect', evt, paper.findViewByModel(currentEnd.id), data.magnetUnderPointer, arrowhead);\n      }\n    }\n  },\n  _snapToPoints: function (snapPoint, points, radius) {\n    let closestPointX = null;\n    let closestDistanceX = Infinity;\n    let closestPointY = null;\n    let closestDistanceY = Infinity;\n    let x = snapPoint.x;\n    let y = snapPoint.y;\n    for (let i = 0; i < points.length; i++) {\n      const distX = Math.abs(points[i].x - snapPoint.x);\n      if (distX < closestDistanceX) {\n        closestDistanceX = distX;\n        closestPointX = points[i];\n      }\n      const distY = Math.abs(points[i].y - snapPoint.y);\n      if (distY < closestDistanceY) {\n        closestDistanceY = distY;\n        closestPointY = points[i];\n      }\n    }\n    if (closestDistanceX < radius) {\n      x = closestPointX.x;\n    }\n    if (closestDistanceY < radius) {\n      y = closestPointY.y;\n    }\n    return {\n      x,\n      y\n    };\n  },\n  _snapArrowheadSelf: function (evt, x, y) {\n    const {\n      paper,\n      model\n    } = this;\n    const {\n      snapLinksSelf\n    } = paper.options;\n    const data = this.eventData(evt);\n    const radius = snapLinksSelf.radius || 20;\n    const anchor = this.getEndAnchor(data.arrowhead === 'source' ? 'target' : 'source');\n    const vertices = model.vertices();\n    const points = [anchor, ...vertices];\n    const snapPoint = this._snapToPoints({\n      x: x,\n      y: y\n    }, points, radius);\n    const point = paper.localToClientPoint(snapPoint);\n    this._connectArrowhead(document.elementFromPoint(point.x, point.y), snapPoint.x, snapPoint.y, this.eventData(evt));\n  },\n  _snapArrowhead: function (evt, x, y) {\n    const {\n      paper\n    } = this;\n    const {\n      snapLinks,\n      connectionStrategy\n    } = paper.options;\n    const data = this.eventData(evt);\n    let isSnapped = false;\n    // checking view in close area of the pointer\n\n    var r = snapLinks.radius || 50;\n    var viewsInArea = paper.findViewsInArea({\n      x: x - r,\n      y: y - r,\n      width: 2 * r,\n      height: 2 * r\n    });\n    var prevClosestView = data.closestView || null;\n    var prevClosestMagnet = data.closestMagnet || null;\n    var prevMagnetProxy = data.magnetProxy || null;\n    data.closestView = data.closestMagnet = data.magnetProxy = null;\n    var minDistance = Number.MAX_VALUE;\n    var pointer = new Point(x, y);\n    viewsInArea.forEach(function (view) {\n      const candidates = [];\n      // skip connecting to the element in case '.': { magnet: false } attribute present\n      if (view.el.getAttribute('magnet') !== 'false') {\n        candidates.push({\n          bbox: view.model.getBBox(),\n          magnet: view.el\n        });\n      }\n      view.$('[magnet]').toArray().forEach(magnet => {\n        candidates.push({\n          bbox: view.getNodeBBox(magnet),\n          magnet\n        });\n      });\n      candidates.forEach(candidate => {\n        const {\n          magnet,\n          bbox\n        } = candidate;\n        // find distance from the center of the model to pointer coordinates\n        const distance = bbox.center().squaredDistance(pointer);\n        // the connection is looked up in a circle area by `distance < r`\n        if (distance < minDistance) {\n          const isAlreadyValidated = prevClosestMagnet === magnet;\n          if (isAlreadyValidated || paper.options.validateConnection.apply(paper, data.validateConnectionArgs(view, view.el === magnet ? null : magnet))) {\n            minDistance = distance;\n            data.closestView = view;\n            data.closestMagnet = magnet;\n          }\n        }\n      });\n    }, this);\n    var end;\n    var magnetProxy = null;\n    var closestView = data.closestView;\n    var closestMagnet = data.closestMagnet;\n    if (closestMagnet) {\n      magnetProxy = data.magnetProxy = closestView.findProxyNode(closestMagnet, 'highlighter');\n    }\n    var endType = data.arrowhead;\n    var newClosestMagnet = prevClosestMagnet !== closestMagnet;\n    if (prevClosestView && newClosestMagnet) {\n      prevClosestView.unhighlight(prevMagnetProxy, {\n        connecting: true,\n        snapping: true\n      });\n    }\n    if (closestView) {\n      const {\n        prevEnd,\n        prevX,\n        prevY\n      } = data;\n      data.prevX = x;\n      data.prevY = y;\n      isSnapped = true;\n      if (!newClosestMagnet) {\n        if (typeof connectionStrategy !== 'function' || prevX === x && prevY === y) {\n          // the magnet has not changed and the link's end does not depend on the x and y\n          return isSnapped;\n        }\n      }\n      end = closestView.getLinkEnd(closestMagnet, x, y, this.model, endType);\n      if (!newClosestMagnet && isEqual(prevEnd, end)) {\n        // the source/target json has not changed\n        return isSnapped;\n      }\n      data.prevEnd = end;\n      if (newClosestMagnet) {\n        closestView.highlight(magnetProxy, {\n          connecting: true,\n          snapping: true\n        });\n      }\n    } else {\n      end = {\n        x: x,\n        y: y\n      };\n    }\n    this.model.set(endType, end || {\n      x: x,\n      y: y\n    }, {\n      ui: true\n    });\n    if (prevClosestView) {\n      this.notify('link:snap:disconnect', evt, prevClosestView, prevClosestMagnet, endType);\n    }\n    if (closestView) {\n      this.notify('link:snap:connect', evt, closestView, closestMagnet, endType);\n    }\n    return isSnapped;\n  },\n  _snapArrowheadEnd: function (data) {\n    // Finish off link snapping.\n    // Everything except view unhighlighting was already done on pointermove.\n    var closestView = data.closestView;\n    var closestMagnet = data.closestMagnet;\n    if (closestView && closestMagnet) {\n      closestView.unhighlight(data.magnetProxy, {\n        connecting: true,\n        snapping: true\n      });\n      data.magnetUnderPointer = closestView.findMagnet(closestMagnet);\n    }\n    data.closestView = data.closestMagnet = null;\n  },\n  _connectArrowhead: function (target, x, y, data) {\n    // checking views right under the pointer\n    const {\n      paper,\n      model\n    } = this;\n    if (data.eventTarget !== target) {\n      // Unhighlight the previous view under pointer if there was one.\n      if (data.magnetProxy) {\n        data.viewUnderPointer.unhighlight(data.magnetProxy, {\n          connecting: true\n        });\n      }\n      const viewUnderPointer = data.viewUnderPointer = paper.findView(target);\n      if (viewUnderPointer) {\n        // If we found a view that is under the pointer, we need to find the closest\n        // magnet based on the real target element of the event.\n        const magnetUnderPointer = data.magnetUnderPointer = viewUnderPointer.findMagnet(target);\n        const magnetProxy = data.magnetProxy = viewUnderPointer.findProxyNode(magnetUnderPointer, 'highlighter');\n        if (magnetUnderPointer && this.paper.options.validateConnection.apply(paper, data.validateConnectionArgs(viewUnderPointer, magnetUnderPointer))) {\n          // If there was no magnet found, do not highlight anything and assume there\n          // is no view under pointer we're interested in reconnecting to.\n          // This can only happen if the overall element has the attribute `'.': { magnet: false }`.\n          if (magnetProxy) {\n            viewUnderPointer.highlight(magnetProxy, {\n              connecting: true\n            });\n          }\n        } else {\n          // This type of connection is not valid. Disregard this magnet.\n          data.magnetUnderPointer = null;\n          data.magnetProxy = null;\n        }\n      } else {\n        // Make sure we'll unset previous magnet.\n        data.magnetUnderPointer = null;\n        data.magnetProxy = null;\n      }\n    }\n    data.eventTarget = target;\n    model.set(data.arrowhead, {\n      x: x,\n      y: y\n    }, {\n      ui: true\n    });\n  },\n  _connectArrowheadEnd: function (data = {}, x, y) {\n    const {\n      model\n    } = this;\n    const {\n      viewUnderPointer,\n      magnetUnderPointer,\n      magnetProxy,\n      arrowhead\n    } = data;\n    if (!magnetUnderPointer || !magnetProxy || !viewUnderPointer) return;\n    viewUnderPointer.unhighlight(magnetProxy, {\n      connecting: true\n    });\n\n    // The link end is taken from the magnet under the pointer, not the proxy.\n    const end = viewUnderPointer.getLinkEnd(magnetUnderPointer, x, y, model, arrowhead);\n    model.set(arrowhead, end, {\n      ui: true\n    });\n  },\n  _beforeArrowheadMove: function (data) {\n    data.z = this.model.get('z');\n    this.model.toFront();\n\n    // Let the pointer propagate through the link view elements so that\n    // the `evt.target` is another element under the pointer, not the link itself.\n    var style = this.el.style;\n    data.pointerEvents = style.pointerEvents;\n    style.pointerEvents = 'none';\n    if (this.paper.options.markAvailable) {\n      this._markAvailableMagnets(data);\n    }\n  },\n  _afterArrowheadMove: function (data) {\n    if (data.z !== null) {\n      this.model.set('z', data.z, {\n        ui: true\n      });\n      data.z = null;\n    }\n\n    // Put `pointer-events` back to its original value. See `_beforeArrowheadMove()` for explanation.\n    this.el.style.pointerEvents = data.pointerEvents;\n    if (this.paper.options.markAvailable) {\n      this._unmarkAvailableMagnets(data);\n    }\n  },\n  _createValidateConnectionArgs: function (arrowhead) {\n    // It makes sure the arguments for validateConnection have the following form:\n    // (source view, source magnet, target view, target magnet and link view)\n    var args = [];\n    args[4] = arrowhead;\n    args[5] = this;\n    var oppositeArrowhead;\n    var i = 0;\n    var j = 0;\n    if (arrowhead === 'source') {\n      i = 2;\n      oppositeArrowhead = 'target';\n    } else {\n      j = 2;\n      oppositeArrowhead = 'source';\n    }\n    var end = this.model.get(oppositeArrowhead);\n    if (end.id) {\n      var view = args[i] = this.paper.findViewByModel(end.id);\n      var magnet = view.getMagnetFromLinkEnd(end);\n      if (magnet === view.el) magnet = undefined;\n      args[i + 1] = magnet;\n    }\n    function validateConnectionArgs(cellView, magnet) {\n      args[j] = cellView;\n      args[j + 1] = cellView.el === magnet ? undefined : magnet;\n      return args;\n    }\n    return validateConnectionArgs;\n  },\n  _markAvailableMagnets: function (data) {\n    function isMagnetAvailable(view, magnet) {\n      var paper = view.paper;\n      var validate = paper.options.validateConnection;\n      return validate.apply(paper, this.validateConnectionArgs(view, magnet));\n    }\n    var paper = this.paper;\n    var elements = paper.model.getCells();\n    data.marked = {};\n    for (var i = 0, n = elements.length; i < n; i++) {\n      var view = elements[i].findView(paper);\n      if (!view) {\n        continue;\n      }\n      var magnets = Array.prototype.slice.call(view.el.querySelectorAll('[magnet]'));\n      if (view.el.getAttribute('magnet') !== 'false') {\n        // Element wrapping group is also a magnet\n        magnets.push(view.el);\n      }\n      var availableMagnets = magnets.filter(isMagnetAvailable.bind(data, view));\n      if (availableMagnets.length > 0) {\n        // highlight all available magnets\n        for (var j = 0, m = availableMagnets.length; j < m; j++) {\n          view.highlight(availableMagnets[j], {\n            magnetAvailability: true\n          });\n        }\n        // highlight the entire view\n        view.highlight(null, {\n          elementAvailability: true\n        });\n        data.marked[view.model.id] = availableMagnets;\n      }\n    }\n  },\n  _unmarkAvailableMagnets: function (data) {\n    var markedKeys = Object.keys(data.marked);\n    var id;\n    var markedMagnets;\n    for (var i = 0, n = markedKeys.length; i < n; i++) {\n      id = markedKeys[i];\n      markedMagnets = data.marked[id];\n      var view = this.paper.findViewByModel(id);\n      if (view) {\n        for (var j = 0, m = markedMagnets.length; j < m; j++) {\n          view.unhighlight(markedMagnets[j], {\n            magnetAvailability: true\n          });\n        }\n        view.unhighlight(null, {\n          elementAvailability: true\n        });\n      }\n    }\n    data.marked = null;\n  },\n  startArrowheadMove: function (end, opt) {\n    opt || (opt = {});\n\n    // Allow to delegate events from an another view to this linkView in order to trigger arrowhead\n    // move without need to click on the actual arrowhead dom element.\n    var data = {\n      action: 'arrowhead-move',\n      arrowhead: end,\n      whenNotAllowed: opt.whenNotAllowed || 'revert',\n      initialMagnet: this[end + 'Magnet'] || (this[end + 'View'] ? this[end + 'View'].el : null),\n      initialEnd: clone(this.model.get(end)),\n      validateConnectionArgs: this._createValidateConnectionArgs(end)\n    };\n    this._beforeArrowheadMove(data);\n    if (opt.ignoreBackwardsCompatibility !== true) {\n      this._dragData = data;\n    }\n    return data;\n  },\n  // Lifecycle methods\n\n  onMount: function () {\n    CellView.prototype.onMount.apply(this, arguments);\n    this.mountLabels();\n  },\n  onDetach: function () {\n    CellView.prototype.onDetach.apply(this, arguments);\n    this.unmountLabels();\n  },\n  onRemove: function () {\n    CellView.prototype.onRemove.apply(this, arguments);\n    this.unmountLabels();\n  }\n}, {\n  Flags: Flags\n});\nObject.defineProperty(LinkView.prototype, 'sourceBBox', {\n  enumerable: true,\n  get: function () {\n    var sourceView = this.sourceView;\n    if (!sourceView) {\n      var sourceDef = this.model.source();\n      return new Rect(sourceDef.x, sourceDef.y);\n    }\n    var sourceMagnet = this.sourceMagnet;\n    if (sourceView.isNodeConnection(sourceMagnet)) {\n      return new Rect(this.sourceAnchor);\n    }\n    return sourceView.getNodeBBox(sourceMagnet || sourceView.el);\n  }\n});\nObject.defineProperty(LinkView.prototype, 'targetBBox', {\n  enumerable: true,\n  get: function () {\n    var targetView = this.targetView;\n    if (!targetView) {\n      var targetDef = this.model.target();\n      return new Rect(targetDef.x, targetDef.y);\n    }\n    var targetMagnet = this.targetMagnet;\n    if (targetView.isNodeConnection(targetMagnet)) {\n      return new Rect(this.targetAnchor);\n    }\n    return targetView.getNodeBBox(targetMagnet || targetView.el);\n  }\n});","map":{"version":3,"names":["CellView","Link","V","addClassNamePrefix","merge","assign","isObject","isFunction","clone","isPercentage","result","isEqual","Point","Line","Path","normalizeAngle","Rect","Polyline","routers","connectors","env","Flags","TOOLS","RENDER","UPDATE","LABELS","SOURCE","TARGET","CONNECTOR","LinkView","extend","className","classNames","prototype","apply","split","push","join","_labelCache","_labelSelectors","_V","_dragData","metrics","decimalsRounding","initialize","arguments","cleanNodesCache","presentationAttributes","markup","attrs","router","connector","labels","labelMarkup","vertices","source","target","initFlag","UPDATE_PRIORITY","confirmUpdate","flags","opt","hasFlag","updateEndProperties","removeFlag","paper","sourceView","targetView","isViewMounted","render","updateHighlighters","updateTools","test","__fixSafariBug268376","model","attributes","updateLabels","onLabelsChange","updateAll","updateConnector","updatePath","updateDOM","translateBy","isRelationshipEmbeddedIn","translate","tx","ty","update","updateLabelPositions","el","childNodes","Array","from","fragment","document","createDocumentFragment","i","n","length","removeChild","appendChild","requestConnectionUpdate","requestUpdate","getFlag","isLabelsRenderRequired","previousLabels","previous","pathArray","propertyPathArray","pathLength","labelExists","Object","propertyValue","_link","_labels","renderLabels","vel","empty","unmountLabels","renderMarkup","link","get","Error","isArray","renderJSONMarkup","renderStringMarkup","doc","parseDOMJSON","selectors","append","children","_getLabelMarkup","undefined","_getLabelStringMarkup","node","currentChild","_normalizeLabelMarkup","DocumentFragment","hasChildNodes","vNode","nodeName","toUpperCase","addClass","cache","vLabels","labelCache","labelSelectors","labelsCount","remove","options","labelsLayer","attr","id","label","labelNode","builtinDefaultLabel","_builtins","defaultLabel","builtinDefaultLabelMarkup","_getDefaultLabel","defaultLabelMarkup","defaultMarkup","setAttribute","rootSelector","selector","parent","mountLabels","hasLabels","getLayerView","insertSortedNode","parentNode","findLabelNodes","labelIndex","labelRoot","findBySelector","findLabelNode","_mergeLabelAttrs","hasCustomMarkup","labelAttrs","defaultLabelAttrs","builtinDefaultLabelAttrs","_mergeLabelSize","labelSize","defaultLabelSize","canLabelMove","can","size","updateDOMSubtreeAttributes","rootBBox","removeRedundantLinearVertices","SIMPLIFY_THRESHOLD","routePoints","sourceAnchor","targetAnchor","numRoutePoints","polyline","simplify","threshold","polylinePoints","points","map","point","toJSON","numPolylinePoints","slice","getEndView","type","getEndAnchor","getEndConnectionPoint","sourcePoint","targetPoint","getEndMagnet","sourceMagnet","targetMagnet","updateRoute","route","path","offset","perpendicular","anchors","findAnchors","findRoute","connectionPoints","findConnectionPoints","findPath","findAnchorsOrdered","firstEndType","firstRef","secondEndType","secondRef","firstAnchor","secondAnchor","firstAnchorRef","secondAnchorRef","firstDef","secondDef","firstView","secondView","firstMagnet","secondMagnet","getAnchor","anchor","res","firstVertex","lastVertex","priority","firstWaypoint","lastWaypoint","sourceDef","targetDef","paperOptions","isNodeConnection","sourceConnectionPointDef","connectionPoint","defaultConnectionPoint","sourcePointRef","sourceLine","getConnectionPoint","targetConnectionPointDef","targetPointRef","targetLine","anchorDef","cellView","magnet","ref","endType","isConnection","defaultLinkAnchor","name","defaultAnchor","anchorFn","anchorName","anchorNamespace","call","args","round","connectionPointDef","view","line","end","connectionPointFn","connectionPointName","connectionPointNamespace","_getDefaultLabelPositionProperty","builtinDefaultLabelPosition","position","defaultLabelPosition","_normalizeLabelPosition","labelPosition","distance","angle","_mergeLabelPositionProperty","normalizedLabelPosition","normalizedDefaultLabelPosition","idx","transformationMatrix","_getLabelTransformationMatrix","matrixToTransformString","_cleanLabelMatrices","index","magnetMatrix","endViewProperty","endDef","endId","updateEndMagnet","endModel","getModelById","endView","findView","endMagnetProperty","connectedMagnet","getMagnetFromLinkEnd","_getLabelPositionProperty","_getLabelPositionAngle","_getLabelPositionArgs","_getDefaultLabelPositionArgs","_mergeLabelPositionArgs","labelPositionArgs","defaultLabelPositionArgs","addLabel","p1","p2","p3","p4","localX","localY","localAngle","localOpt","x","y","positionArgs","getLabelPosition","insertLabel","addVertex","isPointProvided","vertex","getVertexIndex","insertVertex","sendToken","token","callback","onAnimationEnd","vToken","duration","isReversed","direction","connection","animationAttributes","dur","repeatCount","calcMode","fill","keyPoints","keyTimes","findNode","querySelector","SVGPathElement","appendTo","cells","animateAlongPath","setTimeout","namespace","routerNamespace","defaultRouter","routerFn","connectorNamespace","defaultConnector","connectorFn","raw","normalizePathData","getConnection","getSerializedConnection","hasOwnProperty","data","serialize","getConnectionSubdivisions","segmentSubdivisions","subdivisions","getSegmentSubdivisions","getConnectionLength","getPointAtLength","pointAtLength","getPointAtRatio","ratio","parseFloat","pointAt","getTangentAtLength","tangentAtLength","getTangentAtRatio","tangentAt","getClosestPoint","closestPoint","getClosestPointLength","closestPointLength","getClosestPointRatio","closestPointNormalizedLength","isDistanceRelative","absoluteDistance","isDistanceAbsoluteReverse","reverseDistance","isOffsetAbsolute","absoluteOffset","pathOpt","labelPoint","t","closestPointT","labelDistance","lengthAtT","tangent","tangentAtT","labelOffset","pointOffset","pointAtT","labelOffsetDiff","difference","labelAngle","labelOffsetCoordinates","positionOffset","isKeepGradient","keepGradient","isEnsureLegibility","ensureLegibility","translation","start","normal","rotate","setLength","createSVGMatrix","getLabelCoordinates","e","f","vertexLength","currentVertex","currentVertexLength","notifyPointerdown","evt","pointerdown","notify","notifyPointermove","pointermove","notifyPointerup","pointerup","pointerdblclick","pointerclick","contextmenu","dragStart","dragData","eventData","action","dragLabel","dragArrowhead","drag","dragLabelEnd","dragArrowheadEnd","dragEnd","checkMouseleave","mouseover","mouseout","mouseenter","mouseleave","mousewheel","delta","onlabel","dragLabelStart","stopPropagation","isDefaultInteractionPrevented","currentTarget","labelIdx","parseInt","getAttribute","initialLabelPosition","coords","dx","dy","positionAngle","delegateDragEvents","dragArrowheadStart","arrowheadNode","arrowheadType","startArrowheadMove","ignoreBackwardsCompatibility","snapLabels","setOptions","ui","isAsync","async","snapLinks","isSnapped","_snapArrowhead","snapLinksSelf","_snapArrowheadSelf","_connectArrowhead","getEventTarget","_snapArrowheadEnd","_connectArrowheadEnd","linkAllowed","_disallow","_finishEmbedding","_notifyConnectEvent","_afterArrowheadMove","whenNotAllowed","set","arrowhead","initialEnd","embeddingMode","reparent","z","currentEnd","prop","endChanged","endsEqual","findViewByModel","initialMagnet","magnetUnderPointer","_snapToPoints","snapPoint","radius","closestPointX","closestDistanceX","Infinity","closestPointY","closestDistanceY","distX","Math","abs","distY","localToClientPoint","elementFromPoint","connectionStrategy","r","viewsInArea","findViewsInArea","width","height","prevClosestView","closestView","prevClosestMagnet","closestMagnet","prevMagnetProxy","magnetProxy","minDistance","Number","MAX_VALUE","pointer","forEach","candidates","bbox","getBBox","$","toArray","getNodeBBox","candidate","center","squaredDistance","isAlreadyValidated","validateConnection","validateConnectionArgs","findProxyNode","newClosestMagnet","unhighlight","connecting","snapping","prevEnd","prevX","prevY","getLinkEnd","highlight","findMagnet","eventTarget","viewUnderPointer","_beforeArrowheadMove","toFront","style","pointerEvents","markAvailable","_markAvailableMagnets","_unmarkAvailableMagnets","_createValidateConnectionArgs","oppositeArrowhead","j","isMagnetAvailable","validate","elements","getCells","marked","magnets","querySelectorAll","availableMagnets","filter","bind","m","magnetAvailability","elementAvailability","markedKeys","keys","markedMagnets","onMount","onDetach","onRemove","defineProperty","enumerable"],"sources":["C:/react-vcx7m6/node_modules/@joint/core/src/dia/LinkView.mjs"],"sourcesContent":["import { CellView } from './CellView.mjs';\nimport { Link } from './Link.mjs';\nimport V from '../V/index.mjs';\nimport { addClassNamePrefix, merge, assign, isObject, isFunction, clone, isPercentage, result, isEqual } from '../util/index.mjs';\nimport { Point, Line, Path, normalizeAngle, Rect, Polyline } from '../g/index.mjs';\nimport * as routers from '../routers/index.mjs';\nimport * as connectors from '../connectors/index.mjs';\nimport { env } from '../env/index.mjs';\n\nconst Flags = {\n    TOOLS: CellView.Flags.TOOLS,\n    RENDER: 'RENDER',\n    UPDATE: 'UPDATE',\n    LABELS: 'LABELS',\n    SOURCE: 'SOURCE',\n    TARGET: 'TARGET',\n    CONNECTOR: 'CONNECTOR'\n};\n\n// Link base view and controller.\n// ----------------------------------------\n\nexport const LinkView = CellView.extend({\n\n    className: function() {\n\n        var classNames = CellView.prototype.className.apply(this).split(' ');\n\n        classNames.push('link');\n\n        return classNames.join(' ');\n    },\n\n    _labelCache: null,\n    _labelSelectors: null,\n    _V: null,\n    _dragData: null, // deprecated\n\n    metrics: null,\n    decimalsRounding: 2,\n\n    initialize: function() {\n\n        CellView.prototype.initialize.apply(this, arguments);\n\n        // `_.labelCache` is a mapping of indexes of labels in the `this.get('labels')` array to\n        // `<g class=\"label\">` nodes wrapped by Vectorizer. This allows for quick access to the\n        // nodes in `updateLabelPosition()` in order to update the label positions.\n        this._labelCache = {};\n\n        // a cache of label selectors\n        this._labelSelectors = {};\n\n        // cache of default markup nodes\n        this._V = {};\n\n        // connection path metrics\n        this.cleanNodesCache();\n    },\n\n    presentationAttributes: {\n        markup: [Flags.RENDER],\n        attrs: [Flags.UPDATE],\n        router: [Flags.UPDATE],\n        connector: [Flags.CONNECTOR],\n        labels: [Flags.LABELS],\n        labelMarkup: [Flags.LABELS],\n        vertices: [Flags.UPDATE],\n        source: [Flags.SOURCE, Flags.UPDATE],\n        target: [Flags.TARGET, Flags.UPDATE]\n    },\n\n    initFlag: [Flags.RENDER, Flags.SOURCE, Flags.TARGET, Flags.TOOLS],\n\n    UPDATE_PRIORITY: 1,\n\n    confirmUpdate: function(flags, opt) {\n\n        opt || (opt = {});\n\n        if (this.hasFlag(flags, Flags.SOURCE)) {\n            if (!this.updateEndProperties('source')) return flags;\n            flags = this.removeFlag(flags, Flags.SOURCE);\n        }\n\n        if (this.hasFlag(flags, Flags.TARGET)) {\n            if (!this.updateEndProperties('target')) return flags;\n            flags = this.removeFlag(flags, Flags.TARGET);\n        }\n\n        const { paper, sourceView, targetView } = this;\n        if (paper && ((sourceView && !paper.isViewMounted(sourceView)) || (targetView && !paper.isViewMounted(targetView)))) {\n            // Wait for the sourceView and targetView to be rendered\n            return flags;\n        }\n\n        if (this.hasFlag(flags, Flags.RENDER)) {\n            this.render();\n            this.updateHighlighters(true);\n            this.updateTools(opt);\n            flags = this.removeFlag(flags, [Flags.RENDER, Flags.UPDATE, Flags.LABELS, Flags.TOOLS, Flags.CONNECTOR]);\n\n            if (env.test('isSafari')) {\n                this.__fixSafariBug268376();\n            }\n\n            return flags;\n        }\n\n        let updateHighlighters = false;\n\n        const { model } = this;\n        const { attributes } = model;\n        let updateLabels = this.hasFlag(flags, Flags.LABELS);\n\n        if (updateLabels) {\n            this.onLabelsChange(model, attributes.labels, opt);\n            flags = this.removeFlag(flags, Flags.LABELS);\n            updateHighlighters = true;\n        }\n\n        const updateAll = this.hasFlag(flags, Flags.UPDATE);\n        const updateConnector = this.hasFlag(flags, Flags.CONNECTOR);\n        if (updateAll || updateConnector) {\n            if (!updateAll) {\n                // Keep the current route and update the geometry\n                this.updatePath();\n                this.updateDOM();\n            } else if (opt.translateBy && model.isRelationshipEmbeddedIn(opt.translateBy)) {\n                // The link is being translated by an ancestor that will\n                // shift source point, target point and all vertices\n                // by an equal distance.\n                this.translate(opt.tx, opt.ty);\n            } else {\n                this.update();\n            }\n            this.updateTools(opt);\n            flags = this.removeFlag(flags, [Flags.UPDATE, Flags.TOOLS, Flags.CONNECTOR]);\n            updateLabels = false;\n            updateHighlighters = true;\n        }\n\n        if (updateLabels) {\n            this.updateLabelPositions();\n        }\n\n        if (updateHighlighters) {\n            this.updateHighlighters();\n        }\n\n        if (this.hasFlag(flags, Flags.TOOLS)) {\n            this.updateTools(opt);\n            flags = this.removeFlag(flags, Flags.TOOLS);\n        }\n\n        return flags;\n    },\n\n    __fixSafariBug268376: function() {\n        // Safari has a bug where any change after the first render is not reflected in the DOM.\n        // https://bugs.webkit.org/show_bug.cgi?id=268376\n        const { el } = this;\n        const childNodes = Array.from(el.childNodes);\n        const fragment = document.createDocumentFragment();\n        for (let i = 0, n = childNodes.length; i < n; i++) {\n            el.removeChild(childNodes[i]);\n            fragment.appendChild(childNodes[i]);\n        }\n        el.appendChild(fragment);\n    },\n\n    requestConnectionUpdate: function(opt) {\n        this.requestUpdate(this.getFlag(Flags.UPDATE), opt);\n    },\n\n    isLabelsRenderRequired: function(opt = {}) {\n\n        const previousLabels = this.model.previous('labels');\n        if (!previousLabels) return true;\n\n        // Here is an optimization for cases when we know, that change does\n        // not require re-rendering of all labels.\n        if (('propertyPathArray' in opt) && ('propertyValue' in opt)) {\n            // The label is setting by `prop()` method\n            var pathArray = opt.propertyPathArray || [];\n            var pathLength = pathArray.length;\n            if (pathLength > 1) {\n                // We are changing a single label here e.g. 'labels/0/position'\n                var labelExists = !!previousLabels[pathArray[1]];\n                if (labelExists) {\n                    if (pathLength === 2) {\n                        // We are changing the entire label. Need to check if the\n                        // markup is also being changed.\n                        return ('markup' in Object(opt.propertyValue));\n                    } else if (pathArray[2] !== 'markup') {\n                        // We are changing a label property but not the markup\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return true;\n    },\n\n    onLabelsChange: function(_link, _labels, opt) {\n\n        // Note: this optimization works in async=false mode only\n        if (this.isLabelsRenderRequired(opt)) {\n            this.renderLabels();\n        } else {\n            this.updateLabels();\n        }\n    },\n\n    // Rendering.\n    // ----------\n\n    render: function() {\n\n        this.vel.empty();\n        this.unmountLabels();\n        this._V = {};\n        this.renderMarkup();\n        // rendering labels has to be run after the link is appended to DOM tree. (otherwise <Text> bbox\n        // returns zero values)\n        this.renderLabels();\n        this.update();\n\n        return this;\n    },\n\n    renderMarkup: function() {\n\n        var link = this.model;\n        var markup = link.get('markup') || link.markup;\n        if (!markup) throw new Error('dia.LinkView: markup required');\n        if (Array.isArray(markup)) return this.renderJSONMarkup(markup);\n        if (typeof markup === 'string') return this.renderStringMarkup(markup);\n        throw new Error('dia.LinkView: invalid markup');\n    },\n\n    renderJSONMarkup: function(markup) {\n\n        var doc = this.parseDOMJSON(markup, this.el);\n        // Selectors\n        this.selectors = doc.selectors;\n        // Fragment\n        this.vel.append(doc.fragment);\n    },\n\n    renderStringMarkup: function(markup) {\n\n        // A special markup can be given in the `properties.markup` property. This might be handy\n        // if e.g. arrowhead markers should be `<image>` elements or any other element than `<path>`s.\n        // `.connection`, `.connection-wrap`, `.marker-source` and `.marker-target` selectors\n        // of elements with special meaning though. Therefore, those classes should be preserved in any\n        // special markup passed in `properties.markup`.\n        var children = V(markup);\n        // custom markup may contain only one children\n        if (!Array.isArray(children)) children = [children];\n\n        this.vel.append(children);\n    },\n\n    _getLabelMarkup: function(labelMarkup) {\n\n        if (!labelMarkup) return undefined;\n\n        if (Array.isArray(labelMarkup)) return this.parseDOMJSON(labelMarkup, null);\n        if (typeof labelMarkup === 'string') return this._getLabelStringMarkup(labelMarkup);\n        throw new Error('dia.linkView: invalid label markup');\n    },\n\n    _getLabelStringMarkup: function(labelMarkup) {\n\n        var children = V(labelMarkup);\n        var fragment = document.createDocumentFragment();\n\n        if (!Array.isArray(children)) {\n            fragment.appendChild(children.node);\n\n        } else {\n            for (var i = 0, n = children.length; i < n; i++) {\n                var currentChild = children[i].node;\n                fragment.appendChild(currentChild);\n            }\n        }\n\n        return { fragment: fragment, selectors: {}}; // no selectors\n    },\n\n    // Label markup fragment may come wrapped in <g class=\"label\" />, or not.\n    // If it doesn't, add the <g /> container here.\n    _normalizeLabelMarkup: function(markup) {\n\n        if (!markup) return undefined;\n\n        var fragment = markup.fragment;\n        if (!(markup.fragment instanceof DocumentFragment) || !markup.fragment.hasChildNodes()) throw new Error('dia.LinkView: invalid label markup.');\n\n        var vNode;\n        var childNodes = fragment.childNodes;\n\n        if ((childNodes.length > 1) || childNodes[0].nodeName.toUpperCase() !== 'G') {\n            // default markup fragment is not wrapped in <g />\n            // add a <g /> container\n            vNode = V('g').append(fragment);\n        } else {\n            vNode = V(childNodes[0]);\n        }\n\n        vNode.addClass('label');\n\n        return { node: vNode.node, selectors: markup.selectors };\n    },\n\n    renderLabels: function() {\n\n        var cache = this._V;\n        var vLabels = cache.labels;\n        var labelCache = this._labelCache = {};\n        var labelSelectors = this._labelSelectors = {};\n        var model = this.model;\n        var labels = model.attributes.labels || [];\n        var labelsCount = labels.length;\n\n        if (labelsCount === 0) {\n            if (vLabels) vLabels.remove();\n            return this;\n        }\n\n        if (vLabels) {\n            vLabels.empty();\n        }  else {\n            // there is no label container in the markup but some labels are defined\n            // add a <g class=\"labels\" /> container\n            vLabels = cache.labels = V('g').addClass('labels');\n            if (this.options.labelsLayer) {\n                vLabels.addClass(addClassNamePrefix(result(this, 'className')));\n                vLabels.attr('model-id', model.id);\n            }\n        }\n\n        for (var i = 0; i < labelsCount; i++) {\n\n            var label = labels[i];\n            var labelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(label.markup));\n            var labelNode;\n            var selectors;\n            if (labelMarkup) {\n\n                labelNode = labelMarkup.node;\n                selectors = labelMarkup.selectors;\n\n            } else {\n\n                var builtinDefaultLabel =  model._builtins.defaultLabel;\n                var builtinDefaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(builtinDefaultLabel.markup));\n                var defaultLabel = model._getDefaultLabel();\n                var defaultLabelMarkup = this._normalizeLabelMarkup(this._getLabelMarkup(defaultLabel.markup));\n                var defaultMarkup = defaultLabelMarkup || builtinDefaultLabelMarkup;\n\n                labelNode = defaultMarkup.node;\n                selectors = defaultMarkup.selectors;\n            }\n\n            labelNode.setAttribute('label-idx', i); // assign label-idx\n            vLabels.append(labelNode);\n            labelCache[i] = labelNode; // cache node for `updateLabels()` so it can just update label node positions\n\n            var rootSelector = this.selector;\n            if (selectors[rootSelector]) throw new Error('dia.LinkView: ambiguous label root selector.');\n            selectors[rootSelector] = labelNode;\n\n            labelSelectors[i] = selectors; // cache label selectors for `updateLabels()`\n        }\n        if (!vLabels.parent()) {\n            this.mountLabels();\n        }\n\n        this.updateLabels();\n\n        return this;\n    },\n\n    mountLabels: function() {\n        const { el, paper, model, _V, options } = this;\n        const { labels: vLabels } = _V;\n        if (!vLabels || !model.hasLabels()) return;\n        const { node } = vLabels;\n        if (options.labelsLayer) {\n            paper.getLayerView(options.labelsLayer).insertSortedNode(node, model.get('z'));\n        } else {\n            if (node.parentNode !== el) {\n                el.appendChild(node);\n            }\n        }\n    },\n\n    unmountLabels: function() {\n        const { options, _V } = this;\n        if (!_V) return;\n        const { labels: vLabels } = _V;\n        if (vLabels && options.labelsLayer) {\n            vLabels.remove();\n        }\n    },\n\n    findLabelNodes: function(labelIndex, selector) {\n        const labelRoot = this._labelCache[labelIndex];\n        if (!labelRoot) return [];\n        const labelSelectors = this._labelSelectors[labelIndex];\n        return this.findBySelector(selector, labelRoot, labelSelectors);\n    },\n\n    findLabelNode: function(labelIndex, selector) {\n        const [node = null] = this.findLabelNodes(labelIndex, selector);\n        return node;\n    },\n\n    // merge default label attrs into label attrs (or use built-in default label attrs if neither is provided)\n    // keep `undefined` or `null` because `{}` means something else\n    _mergeLabelAttrs: function(hasCustomMarkup, labelAttrs, defaultLabelAttrs, builtinDefaultLabelAttrs) {\n\n        if (labelAttrs === null) return null;\n        if (labelAttrs === undefined) {\n\n            if (defaultLabelAttrs === null) return null;\n            if (defaultLabelAttrs === undefined) {\n\n                if (hasCustomMarkup) return undefined;\n                return builtinDefaultLabelAttrs;\n            }\n\n            if (hasCustomMarkup) return defaultLabelAttrs;\n            return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs);\n        }\n\n        if (hasCustomMarkup) return merge({}, defaultLabelAttrs, labelAttrs);\n        return merge({}, builtinDefaultLabelAttrs, defaultLabelAttrs, labelAttrs);\n    },\n\n    // merge default label size into label size (no built-in default)\n    // keep `undefined` or `null` because `{}` means something else\n    _mergeLabelSize: function(labelSize, defaultLabelSize) {\n\n        if (labelSize === null) return null;\n        if (labelSize === undefined) {\n\n            if (defaultLabelSize === null) return null;\n            if (defaultLabelSize === undefined) return undefined;\n\n            return defaultLabelSize;\n        }\n\n        return merge({}, defaultLabelSize, labelSize);\n    },\n\n    updateLabels: function() {\n\n        if (!this._V.labels) return this;\n\n        var model = this.model;\n        var labels = model.get('labels') || [];\n        var canLabelMove = this.can('labelMove');\n\n        var builtinDefaultLabel = model._builtins.defaultLabel;\n        var builtinDefaultLabelAttrs = builtinDefaultLabel.attrs;\n\n        var defaultLabel = model._getDefaultLabel();\n        var defaultLabelMarkup = defaultLabel.markup;\n        var defaultLabelAttrs = defaultLabel.attrs;\n        var defaultLabelSize = defaultLabel.size;\n\n        for (var i = 0, n = labels.length; i < n; i++) {\n\n            var labelNode = this._labelCache[i];\n            labelNode.setAttribute('cursor', (canLabelMove ? 'move' : 'default'));\n\n            var selectors = this._labelSelectors[i];\n\n            var label = labels[i];\n            var labelMarkup = label.markup;\n            var labelAttrs = label.attrs;\n            var labelSize = label.size;\n\n            var attrs = this._mergeLabelAttrs(\n                (labelMarkup || defaultLabelMarkup),\n                labelAttrs,\n                defaultLabelAttrs,\n                builtinDefaultLabelAttrs\n            );\n\n            var size = this._mergeLabelSize(\n                labelSize,\n                defaultLabelSize\n            );\n\n            this.updateDOMSubtreeAttributes(labelNode, attrs, {\n                rootBBox: new Rect(size),\n                selectors: selectors\n            });\n        }\n\n        return this;\n    },\n\n    // remove vertices that lie on (or nearly on) straight lines within the link\n    // return the number of removed points\n    removeRedundantLinearVertices: function(opt) {\n\n        const SIMPLIFY_THRESHOLD = 0.001;\n\n        const link = this.model;\n        const vertices = link.vertices();\n        const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor];\n        const numRoutePoints = routePoints.length;\n\n        // put routePoints into a polyline and try to simplify\n        const polyline = new Polyline(routePoints);\n        polyline.simplify({ threshold: SIMPLIFY_THRESHOLD });\n        const polylinePoints = polyline.points.map((point) => (point.toJSON())); // JSON of points after simplification\n        const numPolylinePoints = polylinePoints.length; // number of points after simplification\n\n        // shortcut if simplification did not remove any redundant vertices:\n        if (numRoutePoints === numPolylinePoints) return 0;\n\n        // else: set simplified polyline points as link vertices\n        // remove first and last polyline points again (= source/target anchors)\n        link.vertices(polylinePoints.slice(1, numPolylinePoints - 1), opt);\n        return (numRoutePoints - numPolylinePoints);\n    },\n\n    getEndView: function(type) {\n        switch (type) {\n            case 'source':\n                return this.sourceView || null;\n            case 'target':\n                return this.targetView || null;\n            default:\n                throw new Error('dia.LinkView: type parameter required.');\n        }\n    },\n\n    getEndAnchor: function(type) {\n        switch (type) {\n            case 'source':\n                return new Point(this.sourceAnchor);\n            case 'target':\n                return new Point(this.targetAnchor);\n            default:\n                throw new Error('dia.LinkView: type parameter required.');\n        }\n    },\n\n    getEndConnectionPoint: function(type) {\n        switch (type) {\n            case 'source':\n                return new Point(this.sourcePoint);\n            case 'target':\n                return new Point(this.targetPoint);\n            default:\n                throw new Error('dia.LinkView: type parameter required.');\n        }\n    },\n\n    getEndMagnet: function(type) {\n        switch (type) {\n            case 'source':\n                var sourceView = this.sourceView;\n                if (!sourceView) break;\n                return this.sourceMagnet || sourceView.el;\n            case 'target':\n                var targetView = this.targetView;\n                if (!targetView) break;\n                return this.targetMagnet || targetView.el;\n            default:\n                throw new Error('dia.LinkView: type parameter required.');\n        }\n        return null;\n    },\n\n\n    // Updating.\n    // ---------\n\n    update: function() {\n        this.updateRoute();\n        this.updatePath();\n        this.updateDOM();\n        return this;\n    },\n\n    translate: function(tx = 0, ty = 0) {\n        const { route, path } = this;\n        if (!route || !path) return;\n        // translate the route\n        const polyline = new Polyline(route);\n        polyline.translate(tx, ty);\n        this.route = polyline.points;\n        // translate source and target connection and anchor points.\n        this.sourcePoint.offset(tx, ty);\n        this.targetPoint.offset(tx, ty);\n        this.sourceAnchor.offset(tx, ty);\n        this.targetAnchor.offset(tx, ty);\n        // translate the geometry path\n        path.translate(tx, ty);\n        this.updateDOM();\n    },\n\n    updateDOM() {\n        const { el, model, selectors } = this;\n        this.cleanNodesCache();\n        // update SVG attributes defined by 'attrs/'.\n        this.updateDOMSubtreeAttributes(el, model.attr(), { selectors });\n        // update the label position etc.\n        this.updateLabelPositions();\n        // *Deprecated*\n        // Local perpendicular flag (as opposed to one defined on paper).\n        // Could be enabled inside a connector/router. It's valid only\n        // during the update execution.\n        this.options.perpendicular = null;\n    },\n\n    updateRoute: function() {\n        const { model } = this;\n        const vertices = model.vertices();\n        // 1. Find Anchors\n        const anchors = this.findAnchors(vertices);\n        const sourceAnchor = this.sourceAnchor = anchors.source;\n        const targetAnchor = this.targetAnchor = anchors.target;\n        // 2. Find Route\n        const route = this.findRoute(vertices);\n        this.route = route;\n        // 3. Find Connection Points\n        var connectionPoints = this.findConnectionPoints(route, sourceAnchor, targetAnchor);\n        this.sourcePoint = connectionPoints.source;\n        this.targetPoint = connectionPoints.target;\n    },\n\n    updatePath: function() {\n        const { route, sourcePoint, targetPoint } = this;\n        // 4. Find Connection\n        const path = this.findPath(route, sourcePoint.clone(), targetPoint.clone());\n        this.path = path;\n    },\n\n    findAnchorsOrdered: function(firstEndType, firstRef, secondEndType, secondRef) {\n\n        var firstAnchor, secondAnchor;\n        var firstAnchorRef, secondAnchorRef;\n        var model = this.model;\n        var firstDef = model.get(firstEndType);\n        var secondDef = model.get(secondEndType);\n        var firstView = this.getEndView(firstEndType);\n        var secondView = this.getEndView(secondEndType);\n        var firstMagnet = this.getEndMagnet(firstEndType);\n        var secondMagnet = this.getEndMagnet(secondEndType);\n\n        // Anchor first\n        if (firstView) {\n            if (firstRef) {\n                firstAnchorRef = new Point(firstRef);\n            } else if (secondView) {\n                firstAnchorRef = secondMagnet;\n            } else {\n                firstAnchorRef = new Point(secondDef);\n            }\n            firstAnchor = this.getAnchor(firstDef.anchor, firstView, firstMagnet, firstAnchorRef, firstEndType);\n        } else {\n            firstAnchor = new Point(firstDef);\n        }\n\n        // Anchor second\n        if (secondView) {\n            secondAnchorRef = new Point(secondRef || firstAnchor);\n            secondAnchor = this.getAnchor(secondDef.anchor, secondView, secondMagnet, secondAnchorRef, secondEndType);\n        } else {\n            secondAnchor = new Point(secondDef);\n        }\n\n        var res = {};\n        res[firstEndType] = firstAnchor;\n        res[secondEndType] = secondAnchor;\n        return res;\n    },\n\n    findAnchors: function(vertices) {\n\n        var model = this.model;\n        var firstVertex = vertices[0];\n        var lastVertex = vertices[vertices.length - 1];\n\n        if (model.target().priority && !model.source().priority) {\n            // Reversed order\n            return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);\n        }\n\n        // Usual order\n        return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);\n    },\n\n    findConnectionPoints: function(route, sourceAnchor, targetAnchor) {\n\n        var firstWaypoint = route[0];\n        var lastWaypoint = route[route.length - 1];\n        var model = this.model;\n        var sourceDef = model.get('source');\n        var targetDef = model.get('target');\n        var sourceView = this.sourceView;\n        var targetView = this.targetView;\n        var paperOptions = this.paper.options;\n        var sourceMagnet, targetMagnet;\n\n        // Connection Point Source\n        var sourcePoint;\n        if (sourceView && !sourceView.isNodeConnection(this.sourceMagnet)) {\n            sourceMagnet = (this.sourceMagnet || sourceView.el);\n            var sourceConnectionPointDef = sourceDef.connectionPoint || paperOptions.defaultConnectionPoint;\n            var sourcePointRef = firstWaypoint || targetAnchor;\n            var sourceLine = new Line(sourcePointRef, sourceAnchor);\n            sourcePoint = this.getConnectionPoint(\n                sourceConnectionPointDef,\n                sourceView,\n                sourceMagnet,\n                sourceLine,\n                'source'\n            );\n        } else {\n            sourcePoint = sourceAnchor;\n        }\n        // Connection Point Target\n        var targetPoint;\n        if (targetView && !targetView.isNodeConnection(this.targetMagnet)) {\n            targetMagnet = (this.targetMagnet || targetView.el);\n            var targetConnectionPointDef = targetDef.connectionPoint || paperOptions.defaultConnectionPoint;\n            var targetPointRef = lastWaypoint || sourceAnchor;\n            var targetLine = new Line(targetPointRef, targetAnchor);\n            targetPoint = this.getConnectionPoint(\n                targetConnectionPointDef,\n                targetView,\n                targetMagnet,\n                targetLine,\n                'target'\n            );\n        } else {\n            targetPoint = targetAnchor;\n        }\n\n        return {\n            source: sourcePoint,\n            target: targetPoint\n        };\n    },\n\n    getAnchor: function(anchorDef, cellView, magnet, ref, endType) {\n\n        var isConnection = cellView.isNodeConnection(magnet);\n        var paperOptions = this.paper.options;\n        if (!anchorDef) {\n            if (isConnection) {\n                anchorDef = paperOptions.defaultLinkAnchor;\n            } else {\n                if (this.options.perpendicular) {\n                    // Backwards compatibility\n                    // See `manhattan` router for more details\n                    anchorDef = { name: 'perpendicular' };\n                } else {\n                    anchorDef = paperOptions.defaultAnchor;\n                }\n            }\n        }\n\n        if (!anchorDef) throw new Error('Anchor required.');\n        var anchorFn;\n        if (typeof anchorDef === 'function') {\n            anchorFn = anchorDef;\n        } else {\n            var anchorName = anchorDef.name;\n            var anchorNamespace = isConnection ? 'linkAnchorNamespace' : 'anchorNamespace';\n            anchorFn = paperOptions[anchorNamespace][anchorName];\n            if (typeof anchorFn !== 'function') throw new Error('Unknown anchor: ' + anchorName);\n        }\n        var anchor = anchorFn.call(\n            this,\n            cellView,\n            magnet,\n            ref,\n            anchorDef.args || {},\n            endType,\n            this\n        );\n        if (!anchor) return new Point();\n        return anchor.round(this.decimalsRounding);\n    },\n\n\n    getConnectionPoint: function(connectionPointDef, view, magnet, line, endType) {\n\n        var connectionPoint;\n        var anchor = line.end;\n        var paperOptions = this.paper.options;\n\n        if (!connectionPointDef) return anchor;\n        var connectionPointFn;\n        if (typeof connectionPointDef === 'function') {\n            connectionPointFn = connectionPointDef;\n        } else {\n            var connectionPointName = connectionPointDef.name;\n            connectionPointFn = paperOptions.connectionPointNamespace[connectionPointName];\n            if (typeof connectionPointFn !== 'function') throw new Error('Unknown connection point: ' + connectionPointName);\n        }\n        connectionPoint = connectionPointFn.call(this, line, view, magnet, connectionPointDef.args || {}, endType, this);\n        if (!connectionPoint) return anchor;\n        return connectionPoint.round(this.decimalsRounding);\n    },\n\n    // combine default label position with built-in default label position\n    _getDefaultLabelPositionProperty: function() {\n\n        var model = this.model;\n\n        var builtinDefaultLabel = model._builtins.defaultLabel;\n        var builtinDefaultLabelPosition = builtinDefaultLabel.position;\n\n        var defaultLabel = model._getDefaultLabel();\n        var defaultLabelPosition = this._normalizeLabelPosition(defaultLabel.position);\n\n        return merge({}, builtinDefaultLabelPosition, defaultLabelPosition);\n    },\n\n    // if label position is a number, normalize it to a position object\n    // this makes sure that label positions can be merged properly\n    _normalizeLabelPosition: function(labelPosition) {\n\n        if (typeof labelPosition === 'number') return { distance: labelPosition, offset: null, angle: 0, args: null };\n        return labelPosition;\n    },\n\n    // expects normalized position properties\n    // e.g. `this._normalizeLabelPosition(labelPosition)` and `this._getDefaultLabelPositionProperty()`\n    _mergeLabelPositionProperty: function(normalizedLabelPosition, normalizedDefaultLabelPosition) {\n\n        if (normalizedLabelPosition === null) return null;\n        if (normalizedLabelPosition === undefined) {\n\n            if (normalizedDefaultLabelPosition === null) return null;\n            return normalizedDefaultLabelPosition;\n        }\n\n        return merge({}, normalizedDefaultLabelPosition, normalizedLabelPosition);\n    },\n\n    updateLabelPositions: function() {\n\n        if (!this._V.labels) return this;\n\n        var path = this.path;\n        if (!path) return this;\n\n        // This method assumes all the label nodes are stored in the `this._labelCache` hash table\n        // by their indices in the `this.get('labels')` array. This is done in the `renderLabels()` method.\n\n        var model = this.model;\n        var labels = model.get('labels') || [];\n        if (!labels.length) return this;\n\n        var defaultLabelPosition = this._getDefaultLabelPositionProperty();\n\n        for (var idx = 0, n = labels.length; idx < n; idx++) {\n            var labelNode = this._labelCache[idx];\n            if (!labelNode) continue;\n            var label = labels[idx];\n            var labelPosition = this._normalizeLabelPosition(label.position);\n            var position = this._mergeLabelPositionProperty(labelPosition, defaultLabelPosition);\n            var transformationMatrix = this._getLabelTransformationMatrix(position);\n            labelNode.setAttribute('transform', V.matrixToTransformString(transformationMatrix));\n            this._cleanLabelMatrices(idx);\n        }\n\n        return this;\n    },\n\n    _cleanLabelMatrices: function(index) {\n        // Clean magnetMatrix for all nodes of the label.\n        // Cached BoundingRect does not need to updated when the position changes\n        // TODO: this doesn't work for labels with XML String markups.\n        const { metrics, _labelSelectors } = this;\n        const selectors = _labelSelectors[index];\n        if (!selectors) return;\n        for (let selector in selectors) {\n            const { id } = selectors[selector];\n            if (id && (id in metrics)) delete metrics[id].magnetMatrix;\n        }\n    },\n\n    updateEndProperties: function(endType) {\n\n        const { model, paper } = this;\n        const endViewProperty = `${endType}View`;\n        const endDef = model.get(endType);\n        const endId = endDef && endDef.id;\n\n        if (!endId) {\n            // the link end is a point ~ rect 0x0\n            this[endViewProperty] = null;\n            this.updateEndMagnet(endType);\n            return true;\n        }\n\n        const endModel = paper.getModelById(endId);\n        if (!endModel) throw new Error('LinkView: invalid ' + endType + ' cell.');\n\n        const endView = endModel.findView(paper);\n        if (!endView) {\n            // A view for a model should always exist\n            return false;\n        }\n\n        this[endViewProperty] = endView;\n        this.updateEndMagnet(endType);\n        return true;\n    },\n\n    updateEndMagnet: function(endType) {\n\n        const endMagnetProperty = `${endType}Magnet`;\n        const endView = this.getEndView(endType);\n        if (endView) {\n            let connectedMagnet = endView.getMagnetFromLinkEnd(this.model.get(endType));\n            if (connectedMagnet === endView.el) connectedMagnet = null;\n            this[endMagnetProperty] = connectedMagnet;\n        } else {\n            this[endMagnetProperty] = null;\n        }\n    },\n\n    _getLabelPositionProperty: function(idx) {\n\n        return (this.model.label(idx).position || {});\n    },\n\n    _getLabelPositionAngle: function(idx) {\n\n        var labelPosition = this._getLabelPositionProperty(idx);\n        return (labelPosition.angle || 0);\n    },\n\n    _getLabelPositionArgs: function(idx) {\n\n        var labelPosition = this._getLabelPositionProperty(idx);\n        return labelPosition.args;\n    },\n\n    _getDefaultLabelPositionArgs: function() {\n\n        var defaultLabel = this.model._getDefaultLabel();\n        var defaultLabelPosition = defaultLabel.position || {};\n        return defaultLabelPosition.args;\n    },\n\n    // merge default label position args into label position args\n    // keep `undefined` or `null` because `{}` means something else\n    _mergeLabelPositionArgs: function(labelPositionArgs, defaultLabelPositionArgs) {\n\n        if (labelPositionArgs === null) return null;\n        if (labelPositionArgs === undefined) {\n\n            if (defaultLabelPositionArgs === null) return null;\n            return defaultLabelPositionArgs;\n        }\n\n        return merge({}, defaultLabelPositionArgs, labelPositionArgs);\n    },\n\n    // Add default label at given position at end of `labels` array.\n    // Four signatures:\n    // - obj, obj = point, opt\n    // - obj, num, obj = point, angle, opt\n    // - num, num, obj = x, y, opt\n    // - num, num, num, obj = x, y, angle, opt\n    // Assigns relative coordinates by default:\n    // `opt.absoluteDistance` forces absolute coordinates.\n    // `opt.reverseDistance` forces reverse absolute coordinates (if absoluteDistance = true).\n    // `opt.absoluteOffset` forces absolute coordinates for offset.\n    // Additional args:\n    // `opt.keepGradient` auto-adjusts the angle of the label to match path gradient at position.\n    // `opt.ensureLegibility` rotates labels so they are never upside-down.\n    addLabel: function(p1, p2, p3, p4) {\n\n        // normalize data from the four possible signatures\n        var localX;\n        var localY;\n        var localAngle = 0;\n        var localOpt;\n        if (typeof p1 !== 'number') {\n            // {x, y} object provided as first parameter\n            localX = p1.x;\n            localY = p1.y;\n            if (typeof p2 === 'number') {\n                // angle and opt provided as second and third parameters\n                localAngle = p2;\n                localOpt = p3;\n            } else {\n                // opt provided as second parameter\n                localOpt = p2;\n            }\n        } else {\n            // x and y provided as first and second parameters\n            localX = p1;\n            localY = p2;\n            if (typeof p3 === 'number') {\n                // angle and opt provided as third and fourth parameters\n                localAngle = p3;\n                localOpt = p4;\n            } else {\n                // opt provided as third parameter\n                localOpt = p3;\n            }\n        }\n\n        // merge label position arguments\n        var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n        var labelPositionArgs = localOpt;\n        var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n\n        // append label to labels array\n        var label = { position: this.getLabelPosition(localX, localY, localAngle, positionArgs) };\n        var idx = -1;\n        this.model.insertLabel(idx, label, localOpt);\n        return idx;\n    },\n\n    // Add a new vertex at calculated index to the `vertices` array.\n    addVertex: function(x, y, opt) {\n\n        // accept input in form `{ x, y }, opt` or `x, y, opt`\n        var isPointProvided = (typeof x !== 'number');\n        var localX = isPointProvided ? x.x : x;\n        var localY = isPointProvided ? x.y : y;\n        var localOpt = isPointProvided ? y : opt;\n\n        var vertex = { x: localX, y: localY };\n        var idx = this.getVertexIndex(localX, localY);\n        this.model.insertVertex(idx, vertex, localOpt);\n        return idx;\n    },\n\n    // Send a token (an SVG element, usually a circle) along the connection path.\n    // Example: `link.findView(paper).sendToken(V('circle', { r: 7, fill: 'green' }).node)`\n    // `opt.duration` is optional and is a time in milliseconds that the token travels from the source to the target of the link. Default is `1000`.\n    // `opt.direction` is optional and it determines whether the token goes from source to target or other way round (`reverse`)\n    // `opt.connection` is an optional selector to the connection path.\n    // `callback` is optional and is a function to be called once the token reaches the target.\n    sendToken: function(token, opt, callback) {\n\n        function onAnimationEnd(vToken, callback) {\n            return function() {\n                vToken.remove();\n                if (typeof callback === 'function') {\n                    callback();\n                }\n            };\n        }\n\n        var duration, isReversed, selector;\n        if (isObject(opt)) {\n            duration = opt.duration;\n            isReversed = (opt.direction === 'reverse');\n            selector = opt.connection;\n        } else {\n            // Backwards compatibility\n            duration = opt;\n            isReversed = false;\n            selector = null;\n        }\n\n        duration = duration || 1000;\n\n        var animationAttributes = {\n            dur: duration + 'ms',\n            repeatCount: 1,\n            calcMode: 'linear',\n            fill: 'freeze'\n        };\n\n        if (isReversed) {\n            animationAttributes.keyPoints = '1;0';\n            animationAttributes.keyTimes = '0;1';\n        }\n\n        var vToken = V(token);\n        var connection;\n        if (typeof selector === 'string') {\n            // Use custom connection path.\n            connection = this.findNode(selector);\n        } else {\n            // Select connection path automatically.\n            var cache = this._V;\n            connection = (cache.connection) ? cache.connection.node : this.el.querySelector('path');\n        }\n\n        if (!(connection instanceof SVGPathElement)) {\n            throw new Error('dia.LinkView: token animation requires a valid connection path.');\n        }\n\n        vToken\n            .appendTo(this.paper.cells)\n            .animateAlongPath(animationAttributes, connection);\n\n        setTimeout(onAnimationEnd(vToken, callback), duration);\n    },\n\n    findRoute: function(vertices) {\n\n        vertices || (vertices = []);\n\n        var namespace = this.paper.options.routerNamespace || routers;\n        var router = this.model.router();\n        var defaultRouter = this.paper.options.defaultRouter;\n\n        if (!router) {\n            if (defaultRouter) router = defaultRouter;\n            else return vertices.map(Point); // no router specified\n        }\n\n        var routerFn = isFunction(router) ? router : namespace[router.name];\n        if (!isFunction(routerFn)) {\n            throw new Error('dia.LinkView: unknown router: \"' + router.name + '\".');\n        }\n\n        var args = router.args || {};\n\n        var route = routerFn.call(\n            this, // context\n            vertices, // vertices\n            args, // options\n            this // linkView\n        );\n\n        if (!route) return vertices.map(Point);\n        return route;\n    },\n\n    // Return the `d` attribute value of the `<path>` element representing the link\n    // between `source` and `target`.\n    findPath: function(route, sourcePoint, targetPoint) {\n\n        var namespace = this.paper.options.connectorNamespace || connectors;\n        var connector = this.model.connector();\n        var defaultConnector = this.paper.options.defaultConnector;\n\n        if (!connector) {\n            connector = defaultConnector || {};\n        }\n\n        var connectorFn = isFunction(connector) ? connector : namespace[connector.name];\n        if (!isFunction(connectorFn)) {\n            throw new Error('dia.LinkView: unknown connector: \"' + connector.name + '\".');\n        }\n\n        var args = clone(connector.args || {});\n        args.raw = true; // Request raw g.Path as the result.\n\n        var path = connectorFn.call(\n            this, // context\n            sourcePoint, // start point\n            targetPoint, // end point\n            route, // vertices\n            args, // options\n            this // linkView\n        );\n\n        if (typeof path === 'string') {\n            // Backwards compatibility for connectors not supporting `raw` option.\n            path = new Path(V.normalizePathData(path));\n        }\n\n        return path;\n    },\n\n    // Public API.\n    // -----------\n\n    getConnection: function() {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.clone();\n    },\n\n    getSerializedConnection: function() {\n\n        var path = this.path;\n        if (!path) return null;\n\n        var metrics = this.metrics;\n        if (metrics.hasOwnProperty('data')) return metrics.data;\n        var data = path.serialize();\n        metrics.data = data;\n        return data;\n    },\n\n    getConnectionSubdivisions: function() {\n\n        var path = this.path;\n        if (!path) return null;\n\n        var metrics = this.metrics;\n        if (metrics.hasOwnProperty('segmentSubdivisions')) return metrics.segmentSubdivisions;\n        var subdivisions = path.getSegmentSubdivisions();\n        metrics.segmentSubdivisions = subdivisions;\n        return subdivisions;\n    },\n\n    getConnectionLength: function() {\n\n        var path = this.path;\n        if (!path) return 0;\n\n        var metrics = this.metrics;\n        if (metrics.hasOwnProperty('length')) return metrics.length;\n        var length = path.length({ segmentSubdivisions: this.getConnectionSubdivisions() });\n        metrics.length = length;\n        return length;\n    },\n\n    getPointAtLength: function(length) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.pointAtLength(length, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getPointAtRatio: function(ratio) {\n\n        var path = this.path;\n        if (!path) return null;\n        if (isPercentage(ratio)) ratio = parseFloat(ratio) / 100;\n        return path.pointAt(ratio, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getTangentAtLength: function(length) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.tangentAtLength(length, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getTangentAtRatio: function(ratio) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.tangentAt(ratio, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getClosestPoint: function(point) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.closestPoint(point, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getClosestPointLength: function(point) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.closestPointLength(point, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    getClosestPointRatio: function(point) {\n\n        var path = this.path;\n        if (!path) return null;\n\n        return path.closestPointNormalizedLength(point, { segmentSubdivisions: this.getConnectionSubdivisions() });\n    },\n\n    // Get label position object based on two provided coordinates, x and y.\n    // (Used behind the scenes when user moves labels around.)\n    // Two signatures:\n    // - num, num, obj = x, y, options\n    // - num, num, num, obj = x, y, angle, options\n    // Accepts distance/offset options = `absoluteDistance: boolean`, `reverseDistance: boolean`, `absoluteOffset: boolean`\n    // - `absoluteOffset` is necessary in order to move beyond connection endpoints\n    // Additional options = `keepGradient: boolean`, `ensureLegibility: boolean`\n    getLabelPosition: function(x, y, p3, p4) {\n\n        var position = {};\n\n        // normalize data from the two possible signatures\n        var localAngle = 0;\n        var localOpt;\n        if (typeof p3 === 'number') {\n            // angle and opt provided as third and fourth argument\n            localAngle = p3;\n            localOpt = p4;\n        } else {\n            // opt provided as third argument\n            localOpt = p3;\n        }\n\n        // save localOpt as `args` of the position object that is passed along\n        if (localOpt) position.args = localOpt;\n\n        // identify distance/offset settings\n        var isDistanceRelative = !(localOpt && localOpt.absoluteDistance); // relative by default\n        var isDistanceAbsoluteReverse = (localOpt && localOpt.absoluteDistance && localOpt.reverseDistance); // non-reverse by default\n        var isOffsetAbsolute = localOpt && localOpt.absoluteOffset; // offset is non-absolute by default\n\n        // find closest point t\n        var path = this.path;\n        var pathOpt = { segmentSubdivisions: this.getConnectionSubdivisions() };\n        var labelPoint = new Point(x, y);\n        var t = path.closestPointT(labelPoint, pathOpt);\n\n        // DISTANCE:\n        var labelDistance = path.lengthAtT(t, pathOpt);\n        if (isDistanceRelative) labelDistance = (labelDistance / this.getConnectionLength()) || 0; // fix to prevent NaN for 0 length\n        if (isDistanceAbsoluteReverse) labelDistance = (-1 * (this.getConnectionLength() - labelDistance)) || 1; // fix for end point (-0 => 1)\n        position.distance = labelDistance;\n\n        // OFFSET:\n        // use absolute offset if:\n        // - opt.absoluteOffset is true,\n        // - opt.absoluteOffset is not true but there is no tangent\n        var tangent;\n        if (!isOffsetAbsolute) tangent = path.tangentAtT(t);\n        var labelOffset;\n        if (tangent) {\n            labelOffset = tangent.pointOffset(labelPoint);\n        } else {\n            var closestPoint = path.pointAtT(t);\n            var labelOffsetDiff = labelPoint.difference(closestPoint);\n            labelOffset = { x: labelOffsetDiff.x, y: labelOffsetDiff.y };\n        }\n        position.offset = labelOffset;\n\n        // ANGLE:\n        position.angle = localAngle;\n\n        return position;\n    },\n\n    _getLabelTransformationMatrix: function(labelPosition) {\n\n        var labelDistance;\n        var labelAngle = 0;\n        var args = {};\n        if (typeof labelPosition === 'number') {\n            labelDistance = labelPosition;\n        } else if (typeof labelPosition.distance === 'number') {\n            args = labelPosition.args || {};\n            labelDistance = labelPosition.distance;\n            labelAngle = labelPosition.angle || 0;\n        } else {\n            throw new Error('dia.LinkView: invalid label position distance.');\n        }\n\n        var isDistanceRelative = ((labelDistance > 0) && (labelDistance <= 1));\n\n        var labelOffset = 0;\n        var labelOffsetCoordinates = { x: 0, y: 0 };\n        if (labelPosition.offset) {\n            var positionOffset = labelPosition.offset;\n            if (typeof positionOffset === 'number') labelOffset = positionOffset;\n            if (positionOffset.x) labelOffsetCoordinates.x = positionOffset.x;\n            if (positionOffset.y) labelOffsetCoordinates.y = positionOffset.y;\n        }\n\n        var isOffsetAbsolute = ((labelOffsetCoordinates.x !== 0) || (labelOffsetCoordinates.y !== 0) || labelOffset === 0);\n\n        var isKeepGradient = args.keepGradient;\n        var isEnsureLegibility = args.ensureLegibility;\n\n        var path = this.path;\n        var pathOpt = { segmentSubdivisions: this.getConnectionSubdivisions() };\n\n        var distance = isDistanceRelative ? (labelDistance * this.getConnectionLength()) : labelDistance;\n        var tangent = path.tangentAtLength(distance, pathOpt);\n\n        var translation;\n        var angle = labelAngle;\n        if (tangent) {\n            if (isOffsetAbsolute) {\n                translation = tangent.start.clone();\n                translation.offset(labelOffsetCoordinates);\n            } else {\n                var normal = tangent.clone();\n                normal.rotate(tangent.start, -90);\n                normal.setLength(labelOffset);\n                translation = normal.end;\n            }\n\n            if (isKeepGradient) {\n                angle = (tangent.angle() + labelAngle);\n                if (isEnsureLegibility) {\n                    angle = normalizeAngle(((angle + 90) % 180) - 90);\n                }\n            }\n\n        } else {\n            // fallback - the connection has zero length\n            translation = path.start.clone();\n            if (isOffsetAbsolute) translation.offset(labelOffsetCoordinates);\n        }\n\n        return V.createSVGMatrix()\n            .translate(translation.x, translation.y)\n            .rotate(angle);\n    },\n\n    getLabelCoordinates: function(labelPosition) {\n\n        var transformationMatrix = this._getLabelTransformationMatrix(labelPosition);\n        return new Point(transformationMatrix.e, transformationMatrix.f);\n    },\n\n    getVertexIndex: function(x, y) {\n\n        var model = this.model;\n        var vertices = model.vertices();\n\n        var vertexLength = this.getClosestPointLength(new Point(x, y));\n\n        var idx = 0;\n        for (var n = vertices.length; idx < n; idx++) {\n            var currentVertex = vertices[idx];\n            var currentVertexLength = this.getClosestPointLength(currentVertex);\n            if (vertexLength < currentVertexLength) break;\n        }\n\n        return idx;\n    },\n\n    // Interaction. The controller part.\n    // ---------------------------------\n\n    notifyPointerdown(evt, x, y) {\n        CellView.prototype.pointerdown.call(this, evt, x, y);\n        this.notify('link:pointerdown', evt, x, y);\n    },\n\n    notifyPointermove(evt, x, y) {\n        CellView.prototype.pointermove.call(this, evt, x, y);\n        this.notify('link:pointermove', evt, x, y);\n    },\n\n    notifyPointerup(evt, x, y) {\n        this.notify('link:pointerup', evt, x, y);\n        CellView.prototype.pointerup.call(this, evt, x, y);\n    },\n\n    pointerdblclick: function(evt, x, y) {\n\n        CellView.prototype.pointerdblclick.apply(this, arguments);\n        this.notify('link:pointerdblclick', evt, x, y);\n    },\n\n    pointerclick: function(evt, x, y) {\n\n        CellView.prototype.pointerclick.apply(this, arguments);\n        this.notify('link:pointerclick', evt, x, y);\n    },\n\n    contextmenu: function(evt, x, y) {\n\n        CellView.prototype.contextmenu.apply(this, arguments);\n        this.notify('link:contextmenu', evt, x, y);\n    },\n\n    pointerdown: function(evt, x, y) {\n\n        this.notifyPointerdown(evt, x, y);\n        this.dragStart(evt, x, y);\n    },\n\n    pointermove: function(evt, x, y) {\n\n        // Backwards compatibility\n        var dragData = this._dragData;\n        if (dragData) this.eventData(evt, dragData);\n\n        var data = this.eventData(evt);\n        switch (data.action) {\n\n            case 'label-move':\n                this.dragLabel(evt, x, y);\n                break;\n\n            case 'arrowhead-move':\n                this.dragArrowhead(evt, x, y);\n                break;\n\n            case 'move':\n                this.drag(evt, x, y);\n                break;\n        }\n\n        // Backwards compatibility\n        if (dragData) assign(dragData, this.eventData(evt));\n\n        this.notifyPointermove(evt, x, y);\n    },\n\n    pointerup: function(evt, x, y) {\n\n        // Backwards compatibility\n        var dragData = this._dragData;\n        if (dragData) {\n            this.eventData(evt, dragData);\n            this._dragData = null;\n        }\n\n        var data = this.eventData(evt);\n        switch (data.action) {\n\n            case 'label-move':\n                this.dragLabelEnd(evt, x, y);\n                break;\n\n            case 'arrowhead-move':\n                this.dragArrowheadEnd(evt, x, y);\n                break;\n\n            case 'move':\n                this.dragEnd(evt, x, y);\n        }\n\n        this.notifyPointerup(evt, x, y);\n        this.checkMouseleave(evt);\n    },\n\n    mouseover: function(evt) {\n\n        CellView.prototype.mouseover.apply(this, arguments);\n        this.notify('link:mouseover', evt);\n    },\n\n    mouseout: function(evt) {\n\n        CellView.prototype.mouseout.apply(this, arguments);\n        this.notify('link:mouseout', evt);\n    },\n\n    mouseenter: function(evt) {\n\n        CellView.prototype.mouseenter.apply(this, arguments);\n        this.notify('link:mouseenter', evt);\n    },\n\n    mouseleave: function(evt) {\n\n        CellView.prototype.mouseleave.apply(this, arguments);\n        this.notify('link:mouseleave', evt);\n    },\n\n    mousewheel: function(evt, x, y, delta) {\n\n        CellView.prototype.mousewheel.apply(this, arguments);\n        this.notify('link:mousewheel', evt, x, y, delta);\n    },\n\n    onlabel: function(evt, x, y) {\n\n        this.notifyPointerdown(evt, x, y);\n\n        this.dragLabelStart(evt, x, y);\n\n        var stopPropagation = this.eventData(evt).stopPropagation;\n        if (stopPropagation) evt.stopPropagation();\n    },\n\n    // Drag Start Handlers\n\n    dragLabelStart: function(evt, x, y) {\n\n        if (this.can('labelMove')) {\n\n            if (this.isDefaultInteractionPrevented(evt)) return;\n\n            var labelNode = evt.currentTarget;\n            var labelIdx = parseInt(labelNode.getAttribute('label-idx'), 10);\n\n            var defaultLabelPosition = this._getDefaultLabelPositionProperty();\n            var initialLabelPosition = this._normalizeLabelPosition(this._getLabelPositionProperty(labelIdx));\n            var position = this._mergeLabelPositionProperty(initialLabelPosition, defaultLabelPosition);\n\n            var coords = this.getLabelCoordinates(position);\n            var dx = coords.x - x; // how much needs to be added to cursor x to get to label x\n            var dy = coords.y - y; // how much needs to be added to cursor y to get to label y\n\n            var positionAngle = this._getLabelPositionAngle(labelIdx);\n            var labelPositionArgs = this._getLabelPositionArgs(labelIdx);\n            var defaultLabelPositionArgs = this._getDefaultLabelPositionArgs();\n            var positionArgs = this._mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n\n            this.eventData(evt, {\n                action: 'label-move',\n                labelIdx: labelIdx,\n                dx: dx,\n                dy: dy,\n                positionAngle: positionAngle,\n                positionArgs: positionArgs,\n                stopPropagation: true\n            });\n\n        } else {\n\n            // Backwards compatibility:\n            // If labels can't be dragged no default action is triggered.\n            this.eventData(evt, { stopPropagation: true });\n        }\n\n        this.paper.delegateDragEvents(this, evt.data);\n    },\n\n    dragArrowheadStart: function(evt, x, y) {\n\n        if (!this.can('arrowheadMove')) return;\n\n        var arrowheadNode = evt.target;\n        var arrowheadType = arrowheadNode.getAttribute('end');\n        var data = this.startArrowheadMove(arrowheadType, { ignoreBackwardsCompatibility: true });\n\n        this.eventData(evt, data);\n    },\n\n    dragStart: function(evt, x, y) {\n\n        if (this.isDefaultInteractionPrevented(evt)) return;\n\n        if (!this.can('linkMove')) return;\n\n        this.eventData(evt, {\n            action: 'move',\n            dx: x,\n            dy: y\n        });\n    },\n\n    // Drag Handlers\n    dragLabel: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        var label = { position: this.getLabelPosition((x + data.dx), (y + data.dy), data.positionAngle, data.positionArgs) };\n        if (this.paper.options.snapLabels) delete label.position.offset;\n        // The `touchmove' events are not fired\n        // when the original event target is removed from the DOM.\n        // The labels are currently re-rendered completely when only\n        // the position changes. This is why we need to make sure that\n        // the label is updated synchronously.\n        // TODO: replace `touchmove` with `pointermove` (breaking change).\n        const setOptions = { ui: true };\n        if (this.paper.isAsync() && evt.type === 'touchmove') {\n            setOptions.async = false;\n        }\n        this.model.label(data.labelIdx, label, setOptions);\n    },\n\n    dragArrowhead: function(evt, x, y) {\n        if (this.paper.options.snapLinks) {\n            const isSnapped = this._snapArrowhead(evt, x, y);\n            if (!isSnapped && this.paper.options.snapLinksSelf) {\n                this._snapArrowheadSelf(evt, x, y);\n            }\n        } else {\n            if (this.paper.options.snapLinksSelf) {\n                this._snapArrowheadSelf(evt, x, y);\n            } else {\n                this._connectArrowhead(this.getEventTarget(evt), x, y, this.eventData(evt));\n            }\n        }\n    },\n\n    drag: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        this.model.translate(x - data.dx, y - data.dy, { ui: true });\n        this.eventData(evt, {\n            dx: x,\n            dy: y\n        });\n    },\n\n    // Drag End Handlers\n\n    dragLabelEnd: function() {\n        // noop\n    },\n\n    dragArrowheadEnd: function(evt, x, y) {\n\n        var data = this.eventData(evt);\n        var paper = this.paper;\n\n        if (paper.options.snapLinks) {\n            this._snapArrowheadEnd(data);\n        } else {\n            this._connectArrowheadEnd(data, x, y);\n        }\n\n        if (!paper.linkAllowed(this)) {\n            // If the changed link is not allowed, revert to its previous state.\n            this._disallow(data);\n        } else {\n            this._finishEmbedding(data);\n            this._notifyConnectEvent(data, evt);\n        }\n\n        this._afterArrowheadMove(data);\n    },\n\n    dragEnd: function() {\n        // noop\n    },\n\n    _disallow: function(data) {\n\n        switch (data.whenNotAllowed) {\n\n            case 'remove':\n                this.model.remove({ ui: true });\n                break;\n\n            case 'revert':\n            default:\n                this.model.set(data.arrowhead, data.initialEnd, { ui: true });\n                break;\n        }\n    },\n\n    _finishEmbedding: function(data) {\n\n        // Reparent the link if embedding is enabled\n        if (this.paper.options.embeddingMode && this.model.reparent()) {\n            // Make sure we don't reverse to the original 'z' index (see afterArrowheadMove()).\n            data.z = null;\n        }\n    },\n\n    _notifyConnectEvent: function(data, evt) {\n\n        var arrowhead = data.arrowhead;\n        var initialEnd = data.initialEnd;\n        var currentEnd = this.model.prop(arrowhead);\n        var endChanged = currentEnd && !Link.endsEqual(initialEnd, currentEnd);\n        if (endChanged) {\n            var paper = this.paper;\n            if (initialEnd.id) {\n                this.notify('link:disconnect', evt, paper.findViewByModel(initialEnd.id), data.initialMagnet, arrowhead);\n            }\n            if (currentEnd.id) {\n                this.notify('link:connect', evt, paper.findViewByModel(currentEnd.id), data.magnetUnderPointer, arrowhead);\n            }\n        }\n    },\n\n    _snapToPoints: function(snapPoint, points, radius) {\n        let closestPointX = null;\n        let closestDistanceX = Infinity;\n\n        let closestPointY = null;\n        let closestDistanceY = Infinity;\n\n        let x = snapPoint.x;\n        let y = snapPoint.y;\n\n        for (let i = 0; i < points.length; i++) {\n            const distX = Math.abs(points[i].x - snapPoint.x);\n            if (distX < closestDistanceX) {\n                closestDistanceX = distX;\n                closestPointX = points[i];\n            }\n\n            const distY = Math.abs(points[i].y - snapPoint.y);\n            if (distY < closestDistanceY) {\n                closestDistanceY = distY;\n                closestPointY = points[i];\n            }\n        }\n\n        if (closestDistanceX < radius) {\n            x = closestPointX.x;\n        }\n        if (closestDistanceY < radius) {\n            y = closestPointY.y;\n        }\n\n        return { x, y };\n    },\n\n    _snapArrowheadSelf: function(evt, x, y) {\n\n        const { paper, model } = this;\n        const { snapLinksSelf } = paper.options;\n        const data = this.eventData(evt);\n        const radius = snapLinksSelf.radius || 20;\n\n        const anchor = this.getEndAnchor(data.arrowhead === 'source' ? 'target' : 'source');\n        const vertices = model.vertices();\n        const points = [anchor, ...vertices];\n\n        const snapPoint = this._snapToPoints({ x: x, y: y }, points, radius);\n\n        const point = paper.localToClientPoint(snapPoint);\n        this._connectArrowhead(document.elementFromPoint(point.x, point.y), snapPoint.x, snapPoint.y, this.eventData(evt));\n    },\n\n    _snapArrowhead: function(evt, x, y) {\n\n        const { paper } = this;\n        const { snapLinks, connectionStrategy } = paper.options;\n        const data = this.eventData(evt);\n        let isSnapped = false;\n        // checking view in close area of the pointer\n\n        var r = snapLinks.radius || 50;\n        var viewsInArea = paper.findViewsInArea({ x: x - r, y: y - r, width: 2 * r, height: 2 * r });\n\n        var prevClosestView = data.closestView || null;\n        var prevClosestMagnet = data.closestMagnet || null;\n        var prevMagnetProxy = data.magnetProxy || null;\n\n        data.closestView = data.closestMagnet = data.magnetProxy = null;\n\n        var minDistance = Number.MAX_VALUE;\n        var pointer = new Point(x, y);\n\n        viewsInArea.forEach(function(view) {\n            const candidates = [];\n            // skip connecting to the element in case '.': { magnet: false } attribute present\n            if (view.el.getAttribute('magnet') !== 'false') {\n                candidates.push({\n                    bbox: view.model.getBBox(),\n                    magnet: view.el\n                });\n            }\n\n            view.$('[magnet]').toArray().forEach(magnet => {\n                candidates.push({\n                    bbox: view.getNodeBBox(magnet),\n                    magnet\n                });\n            });\n\n            candidates.forEach(candidate => {\n                const { magnet, bbox } = candidate;\n                // find distance from the center of the model to pointer coordinates\n                const distance = bbox.center().squaredDistance(pointer);\n                // the connection is looked up in a circle area by `distance < r`\n                if (distance < minDistance) {\n                    const isAlreadyValidated = prevClosestMagnet === magnet;\n                    if (isAlreadyValidated || paper.options.validateConnection.apply(\n                        paper, data.validateConnectionArgs(view, (view.el === magnet) ? null : magnet)\n                    )) {\n                        minDistance = distance;\n                        data.closestView = view;\n                        data.closestMagnet = magnet;\n                    }\n                }\n            });\n\n        }, this);\n\n        var end;\n        var magnetProxy = null;\n        var closestView = data.closestView;\n        var closestMagnet = data.closestMagnet;\n        if (closestMagnet) {\n            magnetProxy = data.magnetProxy = closestView.findProxyNode(closestMagnet, 'highlighter');\n        }\n        var endType = data.arrowhead;\n        var newClosestMagnet = (prevClosestMagnet !== closestMagnet);\n        if (prevClosestView && newClosestMagnet) {\n            prevClosestView.unhighlight(prevMagnetProxy, {\n                connecting: true,\n                snapping: true\n            });\n        }\n\n        if (closestView) {\n            const { prevEnd, prevX, prevY } = data;\n            data.prevX = x;\n            data.prevY = y;\n            isSnapped = true;\n\n            if (!newClosestMagnet)  {\n                if (typeof connectionStrategy !== 'function' || (prevX === x && prevY === y)) {\n                    // the magnet has not changed and the link's end does not depend on the x and y\n                    return isSnapped;\n                }\n            }\n\n            end = closestView.getLinkEnd(closestMagnet, x, y, this.model, endType);\n            if (!newClosestMagnet && isEqual(prevEnd, end)) {\n                // the source/target json has not changed\n                return isSnapped;\n            }\n\n            data.prevEnd = end;\n\n            if (newClosestMagnet) {\n                closestView.highlight(magnetProxy, {\n                    connecting: true,\n                    snapping: true\n                });\n            }\n\n        } else {\n\n            end = { x: x, y: y };\n        }\n\n        this.model.set(endType, end || { x: x, y: y }, { ui: true });\n\n        if (prevClosestView) {\n            this.notify('link:snap:disconnect', evt, prevClosestView, prevClosestMagnet, endType);\n        }\n        if (closestView) {\n            this.notify('link:snap:connect', evt, closestView, closestMagnet, endType);\n        }\n\n        return isSnapped;\n    },\n\n    _snapArrowheadEnd: function(data) {\n\n        // Finish off link snapping.\n        // Everything except view unhighlighting was already done on pointermove.\n        var closestView = data.closestView;\n        var closestMagnet = data.closestMagnet;\n        if (closestView && closestMagnet) {\n\n            closestView.unhighlight(data.magnetProxy, { connecting: true, snapping: true });\n            data.magnetUnderPointer = closestView.findMagnet(closestMagnet);\n        }\n\n        data.closestView = data.closestMagnet = null;\n    },\n\n    _connectArrowhead: function(target, x, y, data) {\n\n        // checking views right under the pointer\n        const { paper, model } = this;\n\n        if (data.eventTarget !== target) {\n            // Unhighlight the previous view under pointer if there was one.\n            if (data.magnetProxy) {\n                data.viewUnderPointer.unhighlight(data.magnetProxy, {\n                    connecting: true\n                });\n            }\n\n            const viewUnderPointer = data.viewUnderPointer = paper.findView(target);\n            if (viewUnderPointer) {\n                // If we found a view that is under the pointer, we need to find the closest\n                // magnet based on the real target element of the event.\n                const magnetUnderPointer = data.magnetUnderPointer = viewUnderPointer.findMagnet(target);\n                const magnetProxy = data.magnetProxy = viewUnderPointer.findProxyNode(magnetUnderPointer, 'highlighter');\n\n                if (magnetUnderPointer && this.paper.options.validateConnection.apply(\n                    paper,\n                    data.validateConnectionArgs(viewUnderPointer, magnetUnderPointer)\n                )) {\n                    // If there was no magnet found, do not highlight anything and assume there\n                    // is no view under pointer we're interested in reconnecting to.\n                    // This can only happen if the overall element has the attribute `'.': { magnet: false }`.\n                    if (magnetProxy) {\n                        viewUnderPointer.highlight(magnetProxy, {\n                            connecting: true\n                        });\n                    }\n                } else {\n                    // This type of connection is not valid. Disregard this magnet.\n                    data.magnetUnderPointer = null;\n                    data.magnetProxy = null;\n                }\n            } else {\n                // Make sure we'll unset previous magnet.\n                data.magnetUnderPointer = null;\n                data.magnetProxy = null;\n            }\n        }\n\n        data.eventTarget = target;\n\n        model.set(data.arrowhead, { x: x, y: y }, { ui: true });\n    },\n\n    _connectArrowheadEnd: function(data = {}, x, y) {\n\n        const { model } = this;\n        const { viewUnderPointer, magnetUnderPointer, magnetProxy, arrowhead } = data;\n\n        if (!magnetUnderPointer || !magnetProxy || !viewUnderPointer) return;\n\n        viewUnderPointer.unhighlight(magnetProxy, { connecting: true });\n\n        // The link end is taken from the magnet under the pointer, not the proxy.\n        const end = viewUnderPointer.getLinkEnd(magnetUnderPointer, x, y, model, arrowhead);\n        model.set(arrowhead, end, { ui: true });\n    },\n\n    _beforeArrowheadMove: function(data) {\n\n        data.z = this.model.get('z');\n        this.model.toFront();\n\n        // Let the pointer propagate through the link view elements so that\n        // the `evt.target` is another element under the pointer, not the link itself.\n        var style = this.el.style;\n        data.pointerEvents = style.pointerEvents;\n        style.pointerEvents = 'none';\n\n        if (this.paper.options.markAvailable) {\n            this._markAvailableMagnets(data);\n        }\n    },\n\n    _afterArrowheadMove: function(data) {\n\n        if (data.z !== null) {\n            this.model.set('z', data.z, { ui: true });\n            data.z = null;\n        }\n\n        // Put `pointer-events` back to its original value. See `_beforeArrowheadMove()` for explanation.\n        this.el.style.pointerEvents = data.pointerEvents;\n\n        if (this.paper.options.markAvailable) {\n            this._unmarkAvailableMagnets(data);\n        }\n    },\n\n    _createValidateConnectionArgs: function(arrowhead) {\n        // It makes sure the arguments for validateConnection have the following form:\n        // (source view, source magnet, target view, target magnet and link view)\n        var args = [];\n\n        args[4] = arrowhead;\n        args[5] = this;\n\n        var oppositeArrowhead;\n        var i = 0;\n        var j = 0;\n\n        if (arrowhead === 'source') {\n            i = 2;\n            oppositeArrowhead = 'target';\n        } else {\n            j = 2;\n            oppositeArrowhead = 'source';\n        }\n\n        var end = this.model.get(oppositeArrowhead);\n\n        if (end.id) {\n            var view = args[i] = this.paper.findViewByModel(end.id);\n            var magnet = view.getMagnetFromLinkEnd(end);\n            if (magnet === view.el) magnet = undefined;\n            args[i + 1] = magnet;\n        }\n\n        function validateConnectionArgs(cellView, magnet) {\n            args[j] = cellView;\n            args[j + 1] = cellView.el === magnet ? undefined : magnet;\n            return args;\n        }\n\n        return validateConnectionArgs;\n    },\n\n    _markAvailableMagnets: function(data) {\n\n        function isMagnetAvailable(view, magnet) {\n            var paper = view.paper;\n            var validate = paper.options.validateConnection;\n            return validate.apply(paper, this.validateConnectionArgs(view, magnet));\n        }\n\n        var paper = this.paper;\n        var elements = paper.model.getCells();\n        data.marked = {};\n\n        for (var i = 0, n = elements.length; i < n; i++) {\n            var view = elements[i].findView(paper);\n\n            if (!view) {\n                continue;\n            }\n\n            var magnets = Array.prototype.slice.call(view.el.querySelectorAll('[magnet]'));\n            if (view.el.getAttribute('magnet') !== 'false') {\n                // Element wrapping group is also a magnet\n                magnets.push(view.el);\n            }\n\n            var availableMagnets = magnets.filter(isMagnetAvailable.bind(data, view));\n\n            if (availableMagnets.length > 0) {\n                // highlight all available magnets\n                for (var j = 0, m = availableMagnets.length; j < m; j++) {\n                    view.highlight(availableMagnets[j], { magnetAvailability: true });\n                }\n                // highlight the entire view\n                view.highlight(null, { elementAvailability: true });\n\n                data.marked[view.model.id] = availableMagnets;\n            }\n        }\n    },\n\n    _unmarkAvailableMagnets: function(data) {\n\n        var markedKeys = Object.keys(data.marked);\n        var id;\n        var markedMagnets;\n\n        for (var i = 0, n = markedKeys.length; i < n; i++) {\n            id = markedKeys[i];\n            markedMagnets = data.marked[id];\n\n            var view = this.paper.findViewByModel(id);\n            if (view) {\n                for (var j = 0, m = markedMagnets.length; j < m; j++) {\n                    view.unhighlight(markedMagnets[j], { magnetAvailability: true });\n                }\n                view.unhighlight(null, { elementAvailability: true });\n            }\n        }\n\n        data.marked = null;\n    },\n\n    startArrowheadMove: function(end, opt) {\n\n        opt || (opt = {});\n\n        // Allow to delegate events from an another view to this linkView in order to trigger arrowhead\n        // move without need to click on the actual arrowhead dom element.\n        var data = {\n            action: 'arrowhead-move',\n            arrowhead: end,\n            whenNotAllowed: opt.whenNotAllowed || 'revert',\n            initialMagnet: this[end + 'Magnet'] || (this[end + 'View'] ? this[end + 'View'].el : null),\n            initialEnd: clone(this.model.get(end)),\n            validateConnectionArgs: this._createValidateConnectionArgs(end)\n        };\n\n        this._beforeArrowheadMove(data);\n\n        if (opt.ignoreBackwardsCompatibility !== true) {\n            this._dragData = data;\n        }\n\n        return data;\n    },\n\n    // Lifecycle methods\n\n    onMount: function() {\n        CellView.prototype.onMount.apply(this, arguments);\n        this.mountLabels();\n    },\n\n    onDetach: function() {\n        CellView.prototype.onDetach.apply(this, arguments);\n        this.unmountLabels();\n    },\n\n    onRemove: function() {\n        CellView.prototype.onRemove.apply(this, arguments);\n        this.unmountLabels();\n    }\n\n}, {\n\n    Flags: Flags,\n});\n\nObject.defineProperty(LinkView.prototype, 'sourceBBox', {\n\n    enumerable: true,\n\n    get: function() {\n        var sourceView = this.sourceView;\n        if (!sourceView) {\n            var sourceDef = this.model.source();\n            return new Rect(sourceDef.x, sourceDef.y);\n        }\n        var sourceMagnet = this.sourceMagnet;\n        if (sourceView.isNodeConnection(sourceMagnet)) {\n            return new Rect(this.sourceAnchor);\n        }\n        return sourceView.getNodeBBox(sourceMagnet || sourceView.el);\n    }\n\n});\n\nObject.defineProperty(LinkView.prototype, 'targetBBox', {\n\n    enumerable: true,\n\n    get: function() {\n        var targetView = this.targetView;\n        if (!targetView) {\n            var targetDef = this.model.target();\n            return new Rect(targetDef.x, targetDef.y);\n        }\n        var targetMagnet = this.targetMagnet;\n        if (targetView.isNodeConnection(targetMagnet)) {\n            return new Rect(this.targetAnchor);\n        }\n        return targetView.getNodeBBox(targetMagnet || targetView.el);\n    }\n});\n\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,gBAAgB;AACzC,SAASC,IAAI,QAAQ,YAAY;AACjC,OAAOC,CAAC,MAAM,gBAAgB;AAC9B,SAASC,kBAAkB,EAAEC,KAAK,EAAEC,MAAM,EAAEC,QAAQ,EAAEC,UAAU,EAAEC,KAAK,EAAEC,YAAY,EAAEC,MAAM,EAAEC,OAAO,QAAQ,mBAAmB;AACjI,SAASC,KAAK,EAAEC,IAAI,EAAEC,IAAI,EAAEC,cAAc,EAAEC,IAAI,EAAEC,QAAQ,QAAQ,gBAAgB;AAClF,OAAO,KAAKC,OAAO,MAAM,sBAAsB;AAC/C,OAAO,KAAKC,UAAU,MAAM,yBAAyB;AACrD,SAASC,GAAG,QAAQ,kBAAkB;AAEtC,MAAMC,KAAK,GAAG;EACVC,KAAK,EAAEtB,QAAQ,CAACqB,KAAK,CAACC,KAAK;EAC3BC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,MAAM,EAAE,QAAQ;EAChBC,SAAS,EAAE;AACf,CAAC;;AAED;AACA;;AAEA,OAAO,MAAMC,QAAQ,GAAG7B,QAAQ,CAAC8B,MAAM,CAAC;EAEpCC,SAAS,EAAE,SAAAA,CAAA,EAAW;IAElB,IAAIC,UAAU,GAAGhC,QAAQ,CAACiC,SAAS,CAACF,SAAS,CAACG,KAAK,CAAC,IAAI,CAAC,CAACC,KAAK,CAAC,GAAG,CAAC;IAEpEH,UAAU,CAACI,IAAI,CAAC,MAAM,CAAC;IAEvB,OAAOJ,UAAU,CAACK,IAAI,CAAC,GAAG,CAAC;EAC/B,CAAC;EAEDC,WAAW,EAAE,IAAI;EACjBC,eAAe,EAAE,IAAI;EACrBC,EAAE,EAAE,IAAI;EACRC,SAAS,EAAE,IAAI;EAAE;;EAEjBC,OAAO,EAAE,IAAI;EACbC,gBAAgB,EAAE,CAAC;EAEnBC,UAAU,EAAE,SAAAA,CAAA,EAAW;IAEnB5C,QAAQ,CAACiC,SAAS,CAACW,UAAU,CAACV,KAAK,CAAC,IAAI,EAAEW,SAAS,CAAC;;IAEpD;IACA;IACA;IACA,IAAI,CAACP,WAAW,GAAG,CAAC,CAAC;;IAErB;IACA,IAAI,CAACC,eAAe,GAAG,CAAC,CAAC;;IAEzB;IACA,IAAI,CAACC,EAAE,GAAG,CAAC,CAAC;;IAEZ;IACA,IAAI,CAACM,eAAe,CAAC,CAAC;EAC1B,CAAC;EAEDC,sBAAsB,EAAE;IACpBC,MAAM,EAAE,CAAC3B,KAAK,CAACE,MAAM,CAAC;IACtB0B,KAAK,EAAE,CAAC5B,KAAK,CAACG,MAAM,CAAC;IACrB0B,MAAM,EAAE,CAAC7B,KAAK,CAACG,MAAM,CAAC;IACtB2B,SAAS,EAAE,CAAC9B,KAAK,CAACO,SAAS,CAAC;IAC5BwB,MAAM,EAAE,CAAC/B,KAAK,CAACI,MAAM,CAAC;IACtB4B,WAAW,EAAE,CAAChC,KAAK,CAACI,MAAM,CAAC;IAC3B6B,QAAQ,EAAE,CAACjC,KAAK,CAACG,MAAM,CAAC;IACxB+B,MAAM,EAAE,CAAClC,KAAK,CAACK,MAAM,EAAEL,KAAK,CAACG,MAAM,CAAC;IACpCgC,MAAM,EAAE,CAACnC,KAAK,CAACM,MAAM,EAAEN,KAAK,CAACG,MAAM;EACvC,CAAC;EAEDiC,QAAQ,EAAE,CAACpC,KAAK,CAACE,MAAM,EAAEF,KAAK,CAACK,MAAM,EAAEL,KAAK,CAACM,MAAM,EAAEN,KAAK,CAACC,KAAK,CAAC;EAEjEoC,eAAe,EAAE,CAAC;EAElBC,aAAa,EAAE,SAAAA,CAASC,KAAK,EAAEC,GAAG,EAAE;IAEhCA,GAAG,KAAKA,GAAG,GAAG,CAAC,CAAC,CAAC;IAEjB,IAAI,IAAI,CAACC,OAAO,CAACF,KAAK,EAAEvC,KAAK,CAACK,MAAM,CAAC,EAAE;MACnC,IAAI,CAAC,IAAI,CAACqC,mBAAmB,CAAC,QAAQ,CAAC,EAAE,OAAOH,KAAK;MACrDA,KAAK,GAAG,IAAI,CAACI,UAAU,CAACJ,KAAK,EAAEvC,KAAK,CAACK,MAAM,CAAC;IAChD;IAEA,IAAI,IAAI,CAACoC,OAAO,CAACF,KAAK,EAAEvC,KAAK,CAACM,MAAM,CAAC,EAAE;MACnC,IAAI,CAAC,IAAI,CAACoC,mBAAmB,CAAC,QAAQ,CAAC,EAAE,OAAOH,KAAK;MACrDA,KAAK,GAAG,IAAI,CAACI,UAAU,CAACJ,KAAK,EAAEvC,KAAK,CAACM,MAAM,CAAC;IAChD;IAEA,MAAM;MAAEsC,KAAK;MAAEC,UAAU;MAAEC;IAAW,CAAC,GAAG,IAAI;IAC9C,IAAIF,KAAK,KAAMC,UAAU,IAAI,CAACD,KAAK,CAACG,aAAa,CAACF,UAAU,CAAC,IAAMC,UAAU,IAAI,CAACF,KAAK,CAACG,aAAa,CAACD,UAAU,CAAE,CAAC,EAAE;MACjH;MACA,OAAOP,KAAK;IAChB;IAEA,IAAI,IAAI,CAACE,OAAO,CAACF,KAAK,EAAEvC,KAAK,CAACE,MAAM,CAAC,EAAE;MACnC,IAAI,CAAC8C,MAAM,CAAC,CAAC;MACb,IAAI,CAACC,kBAAkB,CAAC,IAAI,CAAC;MAC7B,IAAI,CAACC,WAAW,CAACV,GAAG,CAAC;MACrBD,KAAK,GAAG,IAAI,CAACI,UAAU,CAACJ,KAAK,EAAE,CAACvC,KAAK,CAACE,MAAM,EAAEF,KAAK,CAACG,MAAM,EAAEH,KAAK,CAACI,MAAM,EAAEJ,KAAK,CAACC,KAAK,EAAED,KAAK,CAACO,SAAS,CAAC,CAAC;MAExG,IAAIR,GAAG,CAACoD,IAAI,CAAC,UAAU,CAAC,EAAE;QACtB,IAAI,CAACC,oBAAoB,CAAC,CAAC;MAC/B;MAEA,OAAOb,KAAK;IAChB;IAEA,IAAIU,kBAAkB,GAAG,KAAK;IAE9B,MAAM;MAAEI;IAAM,CAAC,GAAG,IAAI;IACtB,MAAM;MAAEC;IAAW,CAAC,GAAGD,KAAK;IAC5B,IAAIE,YAAY,GAAG,IAAI,CAACd,OAAO,CAACF,KAAK,EAAEvC,KAAK,CAACI,MAAM,CAAC;IAEpD,IAAImD,YAAY,EAAE;MACd,IAAI,CAACC,cAAc,CAACH,KAAK,EAAEC,UAAU,CAACvB,MAAM,EAAES,GAAG,CAAC;MAClDD,KAAK,GAAG,IAAI,CAACI,UAAU,CAACJ,KAAK,EAAEvC,KAAK,CAACI,MAAM,CAAC;MAC5C6C,kBAAkB,GAAG,IAAI;IAC7B;IAEA,MAAMQ,SAAS,GAAG,IAAI,CAAChB,OAAO,CAACF,KAAK,EAAEvC,KAAK,CAACG,MAAM,CAAC;IACnD,MAAMuD,eAAe,GAAG,IAAI,CAACjB,OAAO,CAACF,KAAK,EAAEvC,KAAK,CAACO,SAAS,CAAC;IAC5D,IAAIkD,SAAS,IAAIC,eAAe,EAAE;MAC9B,IAAI,CAACD,SAAS,EAAE;QACZ;QACA,IAAI,CAACE,UAAU,CAAC,CAAC;QACjB,IAAI,CAACC,SAAS,CAAC,CAAC;MACpB,CAAC,MAAM,IAAIpB,GAAG,CAACqB,WAAW,IAAIR,KAAK,CAACS,wBAAwB,CAACtB,GAAG,CAACqB,WAAW,CAAC,EAAE;QAC3E;QACA;QACA;QACA,IAAI,CAACE,SAAS,CAACvB,GAAG,CAACwB,EAAE,EAAExB,GAAG,CAACyB,EAAE,CAAC;MAClC,CAAC,MAAM;QACH,IAAI,CAACC,MAAM,CAAC,CAAC;MACjB;MACA,IAAI,CAAChB,WAAW,CAACV,GAAG,CAAC;MACrBD,KAAK,GAAG,IAAI,CAACI,UAAU,CAACJ,KAAK,EAAE,CAACvC,KAAK,CAACG,MAAM,EAAEH,KAAK,CAACC,KAAK,EAAED,KAAK,CAACO,SAAS,CAAC,CAAC;MAC5EgD,YAAY,GAAG,KAAK;MACpBN,kBAAkB,GAAG,IAAI;IAC7B;IAEA,IAAIM,YAAY,EAAE;MACd,IAAI,CAACY,oBAAoB,CAAC,CAAC;IAC/B;IAEA,IAAIlB,kBAAkB,EAAE;MACpB,IAAI,CAACA,kBAAkB,CAAC,CAAC;IAC7B;IAEA,IAAI,IAAI,CAACR,OAAO,CAACF,KAAK,EAAEvC,KAAK,CAACC,KAAK,CAAC,EAAE;MAClC,IAAI,CAACiD,WAAW,CAACV,GAAG,CAAC;MACrBD,KAAK,GAAG,IAAI,CAACI,UAAU,CAACJ,KAAK,EAAEvC,KAAK,CAACC,KAAK,CAAC;IAC/C;IAEA,OAAOsC,KAAK;EAChB,CAAC;EAEDa,oBAAoB,EAAE,SAAAA,CAAA,EAAW;IAC7B;IACA;IACA,MAAM;MAAEgB;IAAG,CAAC,GAAG,IAAI;IACnB,MAAMC,UAAU,GAAGC,KAAK,CAACC,IAAI,CAACH,EAAE,CAACC,UAAU,CAAC;IAC5C,MAAMG,QAAQ,GAAGC,QAAQ,CAACC,sBAAsB,CAAC,CAAC;IAClD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGP,UAAU,CAACQ,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;MAC/CP,EAAE,CAACU,WAAW,CAACT,UAAU,CAACM,CAAC,CAAC,CAAC;MAC7BH,QAAQ,CAACO,WAAW,CAACV,UAAU,CAACM,CAAC,CAAC,CAAC;IACvC;IACAP,EAAE,CAACW,WAAW,CAACP,QAAQ,CAAC;EAC5B,CAAC;EAEDQ,uBAAuB,EAAE,SAAAA,CAASxC,GAAG,EAAE;IACnC,IAAI,CAACyC,aAAa,CAAC,IAAI,CAACC,OAAO,CAAClF,KAAK,CAACG,MAAM,CAAC,EAAEqC,GAAG,CAAC;EACvD,CAAC;EAED2C,sBAAsB,EAAE,SAAAA,CAAS3C,GAAG,GAAG,CAAC,CAAC,EAAE;IAEvC,MAAM4C,cAAc,GAAG,IAAI,CAAC/B,KAAK,CAACgC,QAAQ,CAAC,QAAQ,CAAC;IACpD,IAAI,CAACD,cAAc,EAAE,OAAO,IAAI;;IAEhC;IACA;IACA,IAAK,mBAAmB,IAAI5C,GAAG,IAAM,eAAe,IAAIA,GAAI,EAAE;MAC1D;MACA,IAAI8C,SAAS,GAAG9C,GAAG,CAAC+C,iBAAiB,IAAI,EAAE;MAC3C,IAAIC,UAAU,GAAGF,SAAS,CAACT,MAAM;MACjC,IAAIW,UAAU,GAAG,CAAC,EAAE;QAChB;QACA,IAAIC,WAAW,GAAG,CAAC,CAACL,cAAc,CAACE,SAAS,CAAC,CAAC,CAAC,CAAC;QAChD,IAAIG,WAAW,EAAE;UACb,IAAID,UAAU,KAAK,CAAC,EAAE;YAClB;YACA;YACA,OAAQ,QAAQ,IAAIE,MAAM,CAAClD,GAAG,CAACmD,aAAa,CAAC;UACjD,CAAC,MAAM,IAAIL,SAAS,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;YAClC;YACA,OAAO,KAAK;UAChB;QACJ;MACJ;IACJ;IAEA,OAAO,IAAI;EACf,CAAC;EAED9B,cAAc,EAAE,SAAAA,CAASoC,KAAK,EAAEC,OAAO,EAAErD,GAAG,EAAE;IAE1C;IACA,IAAI,IAAI,CAAC2C,sBAAsB,CAAC3C,GAAG,CAAC,EAAE;MAClC,IAAI,CAACsD,YAAY,CAAC,CAAC;IACvB,CAAC,MAAM;MACH,IAAI,CAACvC,YAAY,CAAC,CAAC;IACvB;EACJ,CAAC;EAED;EACA;;EAEAP,MAAM,EAAE,SAAAA,CAAA,EAAW;IAEf,IAAI,CAAC+C,GAAG,CAACC,KAAK,CAAC,CAAC;IAChB,IAAI,CAACC,aAAa,CAAC,CAAC;IACpB,IAAI,CAAC9E,EAAE,GAAG,CAAC,CAAC;IACZ,IAAI,CAAC+E,YAAY,CAAC,CAAC;IACnB;IACA;IACA,IAAI,CAACJ,YAAY,CAAC,CAAC;IACnB,IAAI,CAAC5B,MAAM,CAAC,CAAC;IAEb,OAAO,IAAI;EACf,CAAC;EAEDgC,YAAY,EAAE,SAAAA,CAAA,EAAW;IAErB,IAAIC,IAAI,GAAG,IAAI,CAAC9C,KAAK;IACrB,IAAI1B,MAAM,GAAGwE,IAAI,CAACC,GAAG,CAAC,QAAQ,CAAC,IAAID,IAAI,CAACxE,MAAM;IAC9C,IAAI,CAACA,MAAM,EAAE,MAAM,IAAI0E,KAAK,CAAC,+BAA+B,CAAC;IAC7D,IAAI/B,KAAK,CAACgC,OAAO,CAAC3E,MAAM,CAAC,EAAE,OAAO,IAAI,CAAC4E,gBAAgB,CAAC5E,MAAM,CAAC;IAC/D,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE,OAAO,IAAI,CAAC6E,kBAAkB,CAAC7E,MAAM,CAAC;IACtE,MAAM,IAAI0E,KAAK,CAAC,8BAA8B,CAAC;EACnD,CAAC;EAEDE,gBAAgB,EAAE,SAAAA,CAAS5E,MAAM,EAAE;IAE/B,IAAI8E,GAAG,GAAG,IAAI,CAACC,YAAY,CAAC/E,MAAM,EAAE,IAAI,CAACyC,EAAE,CAAC;IAC5C;IACA,IAAI,CAACuC,SAAS,GAAGF,GAAG,CAACE,SAAS;IAC9B;IACA,IAAI,CAACZ,GAAG,CAACa,MAAM,CAACH,GAAG,CAACjC,QAAQ,CAAC;EACjC,CAAC;EAEDgC,kBAAkB,EAAE,SAAAA,CAAS7E,MAAM,EAAE;IAEjC;IACA;IACA;IACA;IACA;IACA,IAAIkF,QAAQ,GAAGhI,CAAC,CAAC8C,MAAM,CAAC;IACxB;IACA,IAAI,CAAC2C,KAAK,CAACgC,OAAO,CAACO,QAAQ,CAAC,EAAEA,QAAQ,GAAG,CAACA,QAAQ,CAAC;IAEnD,IAAI,CAACd,GAAG,CAACa,MAAM,CAACC,QAAQ,CAAC;EAC7B,CAAC;EAEDC,eAAe,EAAE,SAAAA,CAAS9E,WAAW,EAAE;IAEnC,IAAI,CAACA,WAAW,EAAE,OAAO+E,SAAS;IAElC,IAAIzC,KAAK,CAACgC,OAAO,CAACtE,WAAW,CAAC,EAAE,OAAO,IAAI,CAAC0E,YAAY,CAAC1E,WAAW,EAAE,IAAI,CAAC;IAC3E,IAAI,OAAOA,WAAW,KAAK,QAAQ,EAAE,OAAO,IAAI,CAACgF,qBAAqB,CAAChF,WAAW,CAAC;IACnF,MAAM,IAAIqE,KAAK,CAAC,oCAAoC,CAAC;EACzD,CAAC;EAEDW,qBAAqB,EAAE,SAAAA,CAAShF,WAAW,EAAE;IAEzC,IAAI6E,QAAQ,GAAGhI,CAAC,CAACmD,WAAW,CAAC;IAC7B,IAAIwC,QAAQ,GAAGC,QAAQ,CAACC,sBAAsB,CAAC,CAAC;IAEhD,IAAI,CAACJ,KAAK,CAACgC,OAAO,CAACO,QAAQ,CAAC,EAAE;MAC1BrC,QAAQ,CAACO,WAAW,CAAC8B,QAAQ,CAACI,IAAI,CAAC;IAEvC,CAAC,MAAM;MACH,KAAK,IAAItC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGiC,QAAQ,CAAChC,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;QAC7C,IAAIuC,YAAY,GAAGL,QAAQ,CAAClC,CAAC,CAAC,CAACsC,IAAI;QACnCzC,QAAQ,CAACO,WAAW,CAACmC,YAAY,CAAC;MACtC;IACJ;IAEA,OAAO;MAAE1C,QAAQ,EAAEA,QAAQ;MAAEmC,SAAS,EAAE,CAAC;IAAC,CAAC,CAAC,CAAC;EACjD,CAAC;EAED;EACA;EACAQ,qBAAqB,EAAE,SAAAA,CAASxF,MAAM,EAAE;IAEpC,IAAI,CAACA,MAAM,EAAE,OAAOoF,SAAS;IAE7B,IAAIvC,QAAQ,GAAG7C,MAAM,CAAC6C,QAAQ;IAC9B,IAAI,EAAE7C,MAAM,CAAC6C,QAAQ,YAAY4C,gBAAgB,CAAC,IAAI,CAACzF,MAAM,CAAC6C,QAAQ,CAAC6C,aAAa,CAAC,CAAC,EAAE,MAAM,IAAIhB,KAAK,CAAC,qCAAqC,CAAC;IAE9I,IAAIiB,KAAK;IACT,IAAIjD,UAAU,GAAGG,QAAQ,CAACH,UAAU;IAEpC,IAAKA,UAAU,CAACQ,MAAM,GAAG,CAAC,IAAKR,UAAU,CAAC,CAAC,CAAC,CAACkD,QAAQ,CAACC,WAAW,CAAC,CAAC,KAAK,GAAG,EAAE;MACzE;MACA;MACAF,KAAK,GAAGzI,CAAC,CAAC,GAAG,CAAC,CAAC+H,MAAM,CAACpC,QAAQ,CAAC;IACnC,CAAC,MAAM;MACH8C,KAAK,GAAGzI,CAAC,CAACwF,UAAU,CAAC,CAAC,CAAC,CAAC;IAC5B;IAEAiD,KAAK,CAACG,QAAQ,CAAC,OAAO,CAAC;IAEvB,OAAO;MAAER,IAAI,EAAEK,KAAK,CAACL,IAAI;MAAEN,SAAS,EAAEhF,MAAM,CAACgF;IAAU,CAAC;EAC5D,CAAC;EAEDb,YAAY,EAAE,SAAAA,CAAA,EAAW;IAErB,IAAI4B,KAAK,GAAG,IAAI,CAACvG,EAAE;IACnB,IAAIwG,OAAO,GAAGD,KAAK,CAAC3F,MAAM;IAC1B,IAAI6F,UAAU,GAAG,IAAI,CAAC3G,WAAW,GAAG,CAAC,CAAC;IACtC,IAAI4G,cAAc,GAAG,IAAI,CAAC3G,eAAe,GAAG,CAAC,CAAC;IAC9C,IAAImC,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAItB,MAAM,GAAGsB,KAAK,CAACC,UAAU,CAACvB,MAAM,IAAI,EAAE;IAC1C,IAAI+F,WAAW,GAAG/F,MAAM,CAAC8C,MAAM;IAE/B,IAAIiD,WAAW,KAAK,CAAC,EAAE;MACnB,IAAIH,OAAO,EAAEA,OAAO,CAACI,MAAM,CAAC,CAAC;MAC7B,OAAO,IAAI;IACf;IAEA,IAAIJ,OAAO,EAAE;MACTA,OAAO,CAAC3B,KAAK,CAAC,CAAC;IACnB,CAAC,MAAO;MACJ;MACA;MACA2B,OAAO,GAAGD,KAAK,CAAC3F,MAAM,GAAGlD,CAAC,CAAC,GAAG,CAAC,CAAC4I,QAAQ,CAAC,QAAQ,CAAC;MAClD,IAAI,IAAI,CAACO,OAAO,CAACC,WAAW,EAAE;QAC1BN,OAAO,CAACF,QAAQ,CAAC3I,kBAAkB,CAACO,MAAM,CAAC,IAAI,EAAE,WAAW,CAAC,CAAC,CAAC;QAC/DsI,OAAO,CAACO,IAAI,CAAC,UAAU,EAAE7E,KAAK,CAAC8E,EAAE,CAAC;MACtC;IACJ;IAEA,KAAK,IAAIxD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGmD,WAAW,EAAEnD,CAAC,EAAE,EAAE;MAElC,IAAIyD,KAAK,GAAGrG,MAAM,CAAC4C,CAAC,CAAC;MACrB,IAAI3C,WAAW,GAAG,IAAI,CAACmF,qBAAqB,CAAC,IAAI,CAACL,eAAe,CAACsB,KAAK,CAACzG,MAAM,CAAC,CAAC;MAChF,IAAI0G,SAAS;MACb,IAAI1B,SAAS;MACb,IAAI3E,WAAW,EAAE;QAEbqG,SAAS,GAAGrG,WAAW,CAACiF,IAAI;QAC5BN,SAAS,GAAG3E,WAAW,CAAC2E,SAAS;MAErC,CAAC,MAAM;QAEH,IAAI2B,mBAAmB,GAAIjF,KAAK,CAACkF,SAAS,CAACC,YAAY;QACvD,IAAIC,yBAAyB,GAAG,IAAI,CAACtB,qBAAqB,CAAC,IAAI,CAACL,eAAe,CAACwB,mBAAmB,CAAC3G,MAAM,CAAC,CAAC;QAC5G,IAAI6G,YAAY,GAAGnF,KAAK,CAACqF,gBAAgB,CAAC,CAAC;QAC3C,IAAIC,kBAAkB,GAAG,IAAI,CAACxB,qBAAqB,CAAC,IAAI,CAACL,eAAe,CAAC0B,YAAY,CAAC7G,MAAM,CAAC,CAAC;QAC9F,IAAIiH,aAAa,GAAGD,kBAAkB,IAAIF,yBAAyB;QAEnEJ,SAAS,GAAGO,aAAa,CAAC3B,IAAI;QAC9BN,SAAS,GAAGiC,aAAa,CAACjC,SAAS;MACvC;MAEA0B,SAAS,CAACQ,YAAY,CAAC,WAAW,EAAElE,CAAC,CAAC,CAAC,CAAC;MACxCgD,OAAO,CAACf,MAAM,CAACyB,SAAS,CAAC;MACzBT,UAAU,CAACjD,CAAC,CAAC,GAAG0D,SAAS,CAAC,CAAC;;MAE3B,IAAIS,YAAY,GAAG,IAAI,CAACC,QAAQ;MAChC,IAAIpC,SAAS,CAACmC,YAAY,CAAC,EAAE,MAAM,IAAIzC,KAAK,CAAC,8CAA8C,CAAC;MAC5FM,SAAS,CAACmC,YAAY,CAAC,GAAGT,SAAS;MAEnCR,cAAc,CAAClD,CAAC,CAAC,GAAGgC,SAAS,CAAC,CAAC;IACnC;IACA,IAAI,CAACgB,OAAO,CAACqB,MAAM,CAAC,CAAC,EAAE;MACnB,IAAI,CAACC,WAAW,CAAC,CAAC;IACtB;IAEA,IAAI,CAAC1F,YAAY,CAAC,CAAC;IAEnB,OAAO,IAAI;EACf,CAAC;EAED0F,WAAW,EAAE,SAAAA,CAAA,EAAW;IACpB,MAAM;MAAE7E,EAAE;MAAExB,KAAK;MAAES,KAAK;MAAElC,EAAE;MAAE6G;IAAQ,CAAC,GAAG,IAAI;IAC9C,MAAM;MAAEjG,MAAM,EAAE4F;IAAQ,CAAC,GAAGxG,EAAE;IAC9B,IAAI,CAACwG,OAAO,IAAI,CAACtE,KAAK,CAAC6F,SAAS,CAAC,CAAC,EAAE;IACpC,MAAM;MAAEjC;IAAK,CAAC,GAAGU,OAAO;IACxB,IAAIK,OAAO,CAACC,WAAW,EAAE;MACrBrF,KAAK,CAACuG,YAAY,CAACnB,OAAO,CAACC,WAAW,CAAC,CAACmB,gBAAgB,CAACnC,IAAI,EAAE5D,KAAK,CAAC+C,GAAG,CAAC,GAAG,CAAC,CAAC;IAClF,CAAC,MAAM;MACH,IAAIa,IAAI,CAACoC,UAAU,KAAKjF,EAAE,EAAE;QACxBA,EAAE,CAACW,WAAW,CAACkC,IAAI,CAAC;MACxB;IACJ;EACJ,CAAC;EAEDhB,aAAa,EAAE,SAAAA,CAAA,EAAW;IACtB,MAAM;MAAE+B,OAAO;MAAE7G;IAAG,CAAC,GAAG,IAAI;IAC5B,IAAI,CAACA,EAAE,EAAE;IACT,MAAM;MAAEY,MAAM,EAAE4F;IAAQ,CAAC,GAAGxG,EAAE;IAC9B,IAAIwG,OAAO,IAAIK,OAAO,CAACC,WAAW,EAAE;MAChCN,OAAO,CAACI,MAAM,CAAC,CAAC;IACpB;EACJ,CAAC;EAEDuB,cAAc,EAAE,SAAAA,CAASC,UAAU,EAAER,QAAQ,EAAE;IAC3C,MAAMS,SAAS,GAAG,IAAI,CAACvI,WAAW,CAACsI,UAAU,CAAC;IAC9C,IAAI,CAACC,SAAS,EAAE,OAAO,EAAE;IACzB,MAAM3B,cAAc,GAAG,IAAI,CAAC3G,eAAe,CAACqI,UAAU,CAAC;IACvD,OAAO,IAAI,CAACE,cAAc,CAACV,QAAQ,EAAES,SAAS,EAAE3B,cAAc,CAAC;EACnE,CAAC;EAED6B,aAAa,EAAE,SAAAA,CAASH,UAAU,EAAER,QAAQ,EAAE;IAC1C,MAAM,CAAC9B,IAAI,GAAG,IAAI,CAAC,GAAG,IAAI,CAACqC,cAAc,CAACC,UAAU,EAAER,QAAQ,CAAC;IAC/D,OAAO9B,IAAI;EACf,CAAC;EAED;EACA;EACA0C,gBAAgB,EAAE,SAAAA,CAASC,eAAe,EAAEC,UAAU,EAAEC,iBAAiB,EAAEC,wBAAwB,EAAE;IAEjG,IAAIF,UAAU,KAAK,IAAI,EAAE,OAAO,IAAI;IACpC,IAAIA,UAAU,KAAK9C,SAAS,EAAE;MAE1B,IAAI+C,iBAAiB,KAAK,IAAI,EAAE,OAAO,IAAI;MAC3C,IAAIA,iBAAiB,KAAK/C,SAAS,EAAE;QAEjC,IAAI6C,eAAe,EAAE,OAAO7C,SAAS;QACrC,OAAOgD,wBAAwB;MACnC;MAEA,IAAIH,eAAe,EAAE,OAAOE,iBAAiB;MAC7C,OAAO/K,KAAK,CAAC,CAAC,CAAC,EAAEgL,wBAAwB,EAAED,iBAAiB,CAAC;IACjE;IAEA,IAAIF,eAAe,EAAE,OAAO7K,KAAK,CAAC,CAAC,CAAC,EAAE+K,iBAAiB,EAAED,UAAU,CAAC;IACpE,OAAO9K,KAAK,CAAC,CAAC,CAAC,EAAEgL,wBAAwB,EAAED,iBAAiB,EAAED,UAAU,CAAC;EAC7E,CAAC;EAED;EACA;EACAG,eAAe,EAAE,SAAAA,CAASC,SAAS,EAAEC,gBAAgB,EAAE;IAEnD,IAAID,SAAS,KAAK,IAAI,EAAE,OAAO,IAAI;IACnC,IAAIA,SAAS,KAAKlD,SAAS,EAAE;MAEzB,IAAImD,gBAAgB,KAAK,IAAI,EAAE,OAAO,IAAI;MAC1C,IAAIA,gBAAgB,KAAKnD,SAAS,EAAE,OAAOA,SAAS;MAEpD,OAAOmD,gBAAgB;IAC3B;IAEA,OAAOnL,KAAK,CAAC,CAAC,CAAC,EAAEmL,gBAAgB,EAAED,SAAS,CAAC;EACjD,CAAC;EAED1G,YAAY,EAAE,SAAAA,CAAA,EAAW;IAErB,IAAI,CAAC,IAAI,CAACpC,EAAE,CAACY,MAAM,EAAE,OAAO,IAAI;IAEhC,IAAIsB,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAItB,MAAM,GAAGsB,KAAK,CAAC+C,GAAG,CAAC,QAAQ,CAAC,IAAI,EAAE;IACtC,IAAI+D,YAAY,GAAG,IAAI,CAACC,GAAG,CAAC,WAAW,CAAC;IAExC,IAAI9B,mBAAmB,GAAGjF,KAAK,CAACkF,SAAS,CAACC,YAAY;IACtD,IAAIuB,wBAAwB,GAAGzB,mBAAmB,CAAC1G,KAAK;IAExD,IAAI4G,YAAY,GAAGnF,KAAK,CAACqF,gBAAgB,CAAC,CAAC;IAC3C,IAAIC,kBAAkB,GAAGH,YAAY,CAAC7G,MAAM;IAC5C,IAAImI,iBAAiB,GAAGtB,YAAY,CAAC5G,KAAK;IAC1C,IAAIsI,gBAAgB,GAAG1B,YAAY,CAAC6B,IAAI;IAExC,KAAK,IAAI1F,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG7C,MAAM,CAAC8C,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;MAE3C,IAAI0D,SAAS,GAAG,IAAI,CAACpH,WAAW,CAAC0D,CAAC,CAAC;MACnC0D,SAAS,CAACQ,YAAY,CAAC,QAAQ,EAAGsB,YAAY,GAAG,MAAM,GAAG,SAAU,CAAC;MAErE,IAAIxD,SAAS,GAAG,IAAI,CAACzF,eAAe,CAACyD,CAAC,CAAC;MAEvC,IAAIyD,KAAK,GAAGrG,MAAM,CAAC4C,CAAC,CAAC;MACrB,IAAI3C,WAAW,GAAGoG,KAAK,CAACzG,MAAM;MAC9B,IAAIkI,UAAU,GAAGzB,KAAK,CAACxG,KAAK;MAC5B,IAAIqI,SAAS,GAAG7B,KAAK,CAACiC,IAAI;MAE1B,IAAIzI,KAAK,GAAG,IAAI,CAAC+H,gBAAgB,CAC5B3H,WAAW,IAAI2G,kBAAkB,EAClCkB,UAAU,EACVC,iBAAiB,EACjBC,wBACJ,CAAC;MAED,IAAIM,IAAI,GAAG,IAAI,CAACL,eAAe,CAC3BC,SAAS,EACTC,gBACJ,CAAC;MAED,IAAI,CAACI,0BAA0B,CAACjC,SAAS,EAAEzG,KAAK,EAAE;QAC9C2I,QAAQ,EAAE,IAAI5K,IAAI,CAAC0K,IAAI,CAAC;QACxB1D,SAAS,EAAEA;MACf,CAAC,CAAC;IACN;IAEA,OAAO,IAAI;EACf,CAAC;EAED;EACA;EACA6D,6BAA6B,EAAE,SAAAA,CAAShI,GAAG,EAAE;IAEzC,MAAMiI,kBAAkB,GAAG,KAAK;IAEhC,MAAMtE,IAAI,GAAG,IAAI,CAAC9C,KAAK;IACvB,MAAMpB,QAAQ,GAAGkE,IAAI,CAAClE,QAAQ,CAAC,CAAC;IAChC,MAAMyI,WAAW,GAAG,CAAC,IAAI,CAACC,YAAY,EAAE,GAAG1I,QAAQ,EAAE,IAAI,CAAC2I,YAAY,CAAC;IACvE,MAAMC,cAAc,GAAGH,WAAW,CAAC7F,MAAM;;IAEzC;IACA,MAAMiG,QAAQ,GAAG,IAAIlL,QAAQ,CAAC8K,WAAW,CAAC;IAC1CI,QAAQ,CAACC,QAAQ,CAAC;MAAEC,SAAS,EAAEP;IAAmB,CAAC,CAAC;IACpD,MAAMQ,cAAc,GAAGH,QAAQ,CAACI,MAAM,CAACC,GAAG,CAAEC,KAAK,IAAMA,KAAK,CAACC,MAAM,CAAC,CAAE,CAAC,CAAC,CAAC;IACzE,MAAMC,iBAAiB,GAAGL,cAAc,CAACpG,MAAM,CAAC,CAAC;;IAEjD;IACA,IAAIgG,cAAc,KAAKS,iBAAiB,EAAE,OAAO,CAAC;;IAElD;IACA;IACAnF,IAAI,CAAClE,QAAQ,CAACgJ,cAAc,CAACM,KAAK,CAAC,CAAC,EAAED,iBAAiB,GAAG,CAAC,CAAC,EAAE9I,GAAG,CAAC;IAClE,OAAQqI,cAAc,GAAGS,iBAAiB;EAC9C,CAAC;EAEDE,UAAU,EAAE,SAAAA,CAASC,IAAI,EAAE;IACvB,QAAQA,IAAI;MACR,KAAK,QAAQ;QACT,OAAO,IAAI,CAAC5I,UAAU,IAAI,IAAI;MAClC,KAAK,QAAQ;QACT,OAAO,IAAI,CAACC,UAAU,IAAI,IAAI;MAClC;QACI,MAAM,IAAIuD,KAAK,CAAC,wCAAwC,CAAC;IACjE;EACJ,CAAC;EAEDqF,YAAY,EAAE,SAAAA,CAASD,IAAI,EAAE;IACzB,QAAQA,IAAI;MACR,KAAK,QAAQ;QACT,OAAO,IAAIlM,KAAK,CAAC,IAAI,CAACoL,YAAY,CAAC;MACvC,KAAK,QAAQ;QACT,OAAO,IAAIpL,KAAK,CAAC,IAAI,CAACqL,YAAY,CAAC;MACvC;QACI,MAAM,IAAIvE,KAAK,CAAC,wCAAwC,CAAC;IACjE;EACJ,CAAC;EAEDsF,qBAAqB,EAAE,SAAAA,CAASF,IAAI,EAAE;IAClC,QAAQA,IAAI;MACR,KAAK,QAAQ;QACT,OAAO,IAAIlM,KAAK,CAAC,IAAI,CAACqM,WAAW,CAAC;MACtC,KAAK,QAAQ;QACT,OAAO,IAAIrM,KAAK,CAAC,IAAI,CAACsM,WAAW,CAAC;MACtC;QACI,MAAM,IAAIxF,KAAK,CAAC,wCAAwC,CAAC;IACjE;EACJ,CAAC;EAEDyF,YAAY,EAAE,SAAAA,CAASL,IAAI,EAAE;IACzB,QAAQA,IAAI;MACR,KAAK,QAAQ;QACT,IAAI5I,UAAU,GAAG,IAAI,CAACA,UAAU;QAChC,IAAI,CAACA,UAAU,EAAE;QACjB,OAAO,IAAI,CAACkJ,YAAY,IAAIlJ,UAAU,CAACuB,EAAE;MAC7C,KAAK,QAAQ;QACT,IAAItB,UAAU,GAAG,IAAI,CAACA,UAAU;QAChC,IAAI,CAACA,UAAU,EAAE;QACjB,OAAO,IAAI,CAACkJ,YAAY,IAAIlJ,UAAU,CAACsB,EAAE;MAC7C;QACI,MAAM,IAAIiC,KAAK,CAAC,wCAAwC,CAAC;IACjE;IACA,OAAO,IAAI;EACf,CAAC;EAGD;EACA;;EAEAnC,MAAM,EAAE,SAAAA,CAAA,EAAW;IACf,IAAI,CAAC+H,WAAW,CAAC,CAAC;IAClB,IAAI,CAACtI,UAAU,CAAC,CAAC;IACjB,IAAI,CAACC,SAAS,CAAC,CAAC;IAChB,OAAO,IAAI;EACf,CAAC;EAEDG,SAAS,EAAE,SAAAA,CAASC,EAAE,GAAG,CAAC,EAAEC,EAAE,GAAG,CAAC,EAAE;IAChC,MAAM;MAAEiI,KAAK;MAAEC;IAAK,CAAC,GAAG,IAAI;IAC5B,IAAI,CAACD,KAAK,IAAI,CAACC,IAAI,EAAE;IACrB;IACA,MAAMrB,QAAQ,GAAG,IAAIlL,QAAQ,CAACsM,KAAK,CAAC;IACpCpB,QAAQ,CAAC/G,SAAS,CAACC,EAAE,EAAEC,EAAE,CAAC;IAC1B,IAAI,CAACiI,KAAK,GAAGpB,QAAQ,CAACI,MAAM;IAC5B;IACA,IAAI,CAACU,WAAW,CAACQ,MAAM,CAACpI,EAAE,EAAEC,EAAE,CAAC;IAC/B,IAAI,CAAC4H,WAAW,CAACO,MAAM,CAACpI,EAAE,EAAEC,EAAE,CAAC;IAC/B,IAAI,CAAC0G,YAAY,CAACyB,MAAM,CAACpI,EAAE,EAAEC,EAAE,CAAC;IAChC,IAAI,CAAC2G,YAAY,CAACwB,MAAM,CAACpI,EAAE,EAAEC,EAAE,CAAC;IAChC;IACAkI,IAAI,CAACpI,SAAS,CAACC,EAAE,EAAEC,EAAE,CAAC;IACtB,IAAI,CAACL,SAAS,CAAC,CAAC;EACpB,CAAC;EAEDA,SAASA,CAAA,EAAG;IACR,MAAM;MAAEQ,EAAE;MAAEf,KAAK;MAAEsD;IAAU,CAAC,GAAG,IAAI;IACrC,IAAI,CAAClF,eAAe,CAAC,CAAC;IACtB;IACA,IAAI,CAAC6I,0BAA0B,CAAClG,EAAE,EAAEf,KAAK,CAAC6E,IAAI,CAAC,CAAC,EAAE;MAAEvB;IAAU,CAAC,CAAC;IAChE;IACA,IAAI,CAACxC,oBAAoB,CAAC,CAAC;IAC3B;IACA;IACA;IACA;IACA,IAAI,CAAC6D,OAAO,CAACqE,aAAa,GAAG,IAAI;EACrC,CAAC;EAEDJ,WAAW,EAAE,SAAAA,CAAA,EAAW;IACpB,MAAM;MAAE5I;IAAM,CAAC,GAAG,IAAI;IACtB,MAAMpB,QAAQ,GAAGoB,KAAK,CAACpB,QAAQ,CAAC,CAAC;IACjC;IACA,MAAMqK,OAAO,GAAG,IAAI,CAACC,WAAW,CAACtK,QAAQ,CAAC;IAC1C,MAAM0I,YAAY,GAAG,IAAI,CAACA,YAAY,GAAG2B,OAAO,CAACpK,MAAM;IACvD,MAAM0I,YAAY,GAAG,IAAI,CAACA,YAAY,GAAG0B,OAAO,CAACnK,MAAM;IACvD;IACA,MAAM+J,KAAK,GAAG,IAAI,CAACM,SAAS,CAACvK,QAAQ,CAAC;IACtC,IAAI,CAACiK,KAAK,GAAGA,KAAK;IAClB;IACA,IAAIO,gBAAgB,GAAG,IAAI,CAACC,oBAAoB,CAACR,KAAK,EAAEvB,YAAY,EAAEC,YAAY,CAAC;IACnF,IAAI,CAACgB,WAAW,GAAGa,gBAAgB,CAACvK,MAAM;IAC1C,IAAI,CAAC2J,WAAW,GAAGY,gBAAgB,CAACtK,MAAM;EAC9C,CAAC;EAEDwB,UAAU,EAAE,SAAAA,CAAA,EAAW;IACnB,MAAM;MAAEuI,KAAK;MAAEN,WAAW;MAAEC;IAAY,CAAC,GAAG,IAAI;IAChD;IACA,MAAMM,IAAI,GAAG,IAAI,CAACQ,QAAQ,CAACT,KAAK,EAAEN,WAAW,CAACzM,KAAK,CAAC,CAAC,EAAE0M,WAAW,CAAC1M,KAAK,CAAC,CAAC,CAAC;IAC3E,IAAI,CAACgN,IAAI,GAAGA,IAAI;EACpB,CAAC;EAEDS,kBAAkB,EAAE,SAAAA,CAASC,YAAY,EAAEC,QAAQ,EAAEC,aAAa,EAAEC,SAAS,EAAE;IAE3E,IAAIC,WAAW,EAAEC,YAAY;IAC7B,IAAIC,cAAc,EAAEC,eAAe;IACnC,IAAI/J,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAIgK,QAAQ,GAAGhK,KAAK,CAAC+C,GAAG,CAACyG,YAAY,CAAC;IACtC,IAAIS,SAAS,GAAGjK,KAAK,CAAC+C,GAAG,CAAC2G,aAAa,CAAC;IACxC,IAAIQ,SAAS,GAAG,IAAI,CAAC/B,UAAU,CAACqB,YAAY,CAAC;IAC7C,IAAIW,UAAU,GAAG,IAAI,CAAChC,UAAU,CAACuB,aAAa,CAAC;IAC/C,IAAIU,WAAW,GAAG,IAAI,CAAC3B,YAAY,CAACe,YAAY,CAAC;IACjD,IAAIa,YAAY,GAAG,IAAI,CAAC5B,YAAY,CAACiB,aAAa,CAAC;;IAEnD;IACA,IAAIQ,SAAS,EAAE;MACX,IAAIT,QAAQ,EAAE;QACVK,cAAc,GAAG,IAAI5N,KAAK,CAACuN,QAAQ,CAAC;MACxC,CAAC,MAAM,IAAIU,UAAU,EAAE;QACnBL,cAAc,GAAGO,YAAY;MACjC,CAAC,MAAM;QACHP,cAAc,GAAG,IAAI5N,KAAK,CAAC+N,SAAS,CAAC;MACzC;MACAL,WAAW,GAAG,IAAI,CAACU,SAAS,CAACN,QAAQ,CAACO,MAAM,EAAEL,SAAS,EAAEE,WAAW,EAAEN,cAAc,EAAEN,YAAY,CAAC;IACvG,CAAC,MAAM;MACHI,WAAW,GAAG,IAAI1N,KAAK,CAAC8N,QAAQ,CAAC;IACrC;;IAEA;IACA,IAAIG,UAAU,EAAE;MACZJ,eAAe,GAAG,IAAI7N,KAAK,CAACyN,SAAS,IAAIC,WAAW,CAAC;MACrDC,YAAY,GAAG,IAAI,CAACS,SAAS,CAACL,SAAS,CAACM,MAAM,EAAEJ,UAAU,EAAEE,YAAY,EAAEN,eAAe,EAAEL,aAAa,CAAC;IAC7G,CAAC,MAAM;MACHG,YAAY,GAAG,IAAI3N,KAAK,CAAC+N,SAAS,CAAC;IACvC;IAEA,IAAIO,GAAG,GAAG,CAAC,CAAC;IACZA,GAAG,CAAChB,YAAY,CAAC,GAAGI,WAAW;IAC/BY,GAAG,CAACd,aAAa,CAAC,GAAGG,YAAY;IACjC,OAAOW,GAAG;EACd,CAAC;EAEDtB,WAAW,EAAE,SAAAA,CAAStK,QAAQ,EAAE;IAE5B,IAAIoB,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAIyK,WAAW,GAAG7L,QAAQ,CAAC,CAAC,CAAC;IAC7B,IAAI8L,UAAU,GAAG9L,QAAQ,CAACA,QAAQ,CAAC4C,MAAM,GAAG,CAAC,CAAC;IAE9C,IAAIxB,KAAK,CAAClB,MAAM,CAAC,CAAC,CAAC6L,QAAQ,IAAI,CAAC3K,KAAK,CAACnB,MAAM,CAAC,CAAC,CAAC8L,QAAQ,EAAE;MACrD;MACA,OAAO,IAAI,CAACpB,kBAAkB,CAAC,QAAQ,EAAEmB,UAAU,EAAE,QAAQ,EAAED,WAAW,CAAC;IAC/E;;IAEA;IACA,OAAO,IAAI,CAAClB,kBAAkB,CAAC,QAAQ,EAAEkB,WAAW,EAAE,QAAQ,EAAEC,UAAU,CAAC;EAC/E,CAAC;EAEDrB,oBAAoB,EAAE,SAAAA,CAASR,KAAK,EAAEvB,YAAY,EAAEC,YAAY,EAAE;IAE9D,IAAIqD,aAAa,GAAG/B,KAAK,CAAC,CAAC,CAAC;IAC5B,IAAIgC,YAAY,GAAGhC,KAAK,CAACA,KAAK,CAACrH,MAAM,GAAG,CAAC,CAAC;IAC1C,IAAIxB,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAI8K,SAAS,GAAG9K,KAAK,CAAC+C,GAAG,CAAC,QAAQ,CAAC;IACnC,IAAIgI,SAAS,GAAG/K,KAAK,CAAC+C,GAAG,CAAC,QAAQ,CAAC;IACnC,IAAIvD,UAAU,GAAG,IAAI,CAACA,UAAU;IAChC,IAAIC,UAAU,GAAG,IAAI,CAACA,UAAU;IAChC,IAAIuL,YAAY,GAAG,IAAI,CAACzL,KAAK,CAACoF,OAAO;IACrC,IAAI+D,YAAY,EAAEC,YAAY;;IAE9B;IACA,IAAIJ,WAAW;IACf,IAAI/I,UAAU,IAAI,CAACA,UAAU,CAACyL,gBAAgB,CAAC,IAAI,CAACvC,YAAY,CAAC,EAAE;MAC/DA,YAAY,GAAI,IAAI,CAACA,YAAY,IAAIlJ,UAAU,CAACuB,EAAG;MACnD,IAAImK,wBAAwB,GAAGJ,SAAS,CAACK,eAAe,IAAIH,YAAY,CAACI,sBAAsB;MAC/F,IAAIC,cAAc,GAAGT,aAAa,IAAIrD,YAAY;MAClD,IAAI+D,UAAU,GAAG,IAAInP,IAAI,CAACkP,cAAc,EAAE/D,YAAY,CAAC;MACvDiB,WAAW,GAAG,IAAI,CAACgD,kBAAkB,CACjCL,wBAAwB,EACxB1L,UAAU,EACVkJ,YAAY,EACZ4C,UAAU,EACV,QACJ,CAAC;IACL,CAAC,MAAM;MACH/C,WAAW,GAAGjB,YAAY;IAC9B;IACA;IACA,IAAIkB,WAAW;IACf,IAAI/I,UAAU,IAAI,CAACA,UAAU,CAACwL,gBAAgB,CAAC,IAAI,CAACtC,YAAY,CAAC,EAAE;MAC/DA,YAAY,GAAI,IAAI,CAACA,YAAY,IAAIlJ,UAAU,CAACsB,EAAG;MACnD,IAAIyK,wBAAwB,GAAGT,SAAS,CAACI,eAAe,IAAIH,YAAY,CAACI,sBAAsB;MAC/F,IAAIK,cAAc,GAAGZ,YAAY,IAAIvD,YAAY;MACjD,IAAIoE,UAAU,GAAG,IAAIvP,IAAI,CAACsP,cAAc,EAAElE,YAAY,CAAC;MACvDiB,WAAW,GAAG,IAAI,CAAC+C,kBAAkB,CACjCC,wBAAwB,EACxB/L,UAAU,EACVkJ,YAAY,EACZ+C,UAAU,EACV,QACJ,CAAC;IACL,CAAC,MAAM;MACHlD,WAAW,GAAGjB,YAAY;IAC9B;IAEA,OAAO;MACH1I,MAAM,EAAE0J,WAAW;MACnBzJ,MAAM,EAAE0J;IACZ,CAAC;EACL,CAAC;EAED8B,SAAS,EAAE,SAAAA,CAASqB,SAAS,EAAEC,QAAQ,EAAEC,MAAM,EAAEC,GAAG,EAAEC,OAAO,EAAE;IAE3D,IAAIC,YAAY,GAAGJ,QAAQ,CAACX,gBAAgB,CAACY,MAAM,CAAC;IACpD,IAAIb,YAAY,GAAG,IAAI,CAACzL,KAAK,CAACoF,OAAO;IACrC,IAAI,CAACgH,SAAS,EAAE;MACZ,IAAIK,YAAY,EAAE;QACdL,SAAS,GAAGX,YAAY,CAACiB,iBAAiB;MAC9C,CAAC,MAAM;QACH,IAAI,IAAI,CAACtH,OAAO,CAACqE,aAAa,EAAE;UAC5B;UACA;UACA2C,SAAS,GAAG;YAAEO,IAAI,EAAE;UAAgB,CAAC;QACzC,CAAC,MAAM;UACHP,SAAS,GAAGX,YAAY,CAACmB,aAAa;QAC1C;MACJ;IACJ;IAEA,IAAI,CAACR,SAAS,EAAE,MAAM,IAAI3I,KAAK,CAAC,kBAAkB,CAAC;IACnD,IAAIoJ,QAAQ;IACZ,IAAI,OAAOT,SAAS,KAAK,UAAU,EAAE;MACjCS,QAAQ,GAAGT,SAAS;IACxB,CAAC,MAAM;MACH,IAAIU,UAAU,GAAGV,SAAS,CAACO,IAAI;MAC/B,IAAII,eAAe,GAAGN,YAAY,GAAG,qBAAqB,GAAG,iBAAiB;MAC9EI,QAAQ,GAAGpB,YAAY,CAACsB,eAAe,CAAC,CAACD,UAAU,CAAC;MACpD,IAAI,OAAOD,QAAQ,KAAK,UAAU,EAAE,MAAM,IAAIpJ,KAAK,CAAC,kBAAkB,GAAGqJ,UAAU,CAAC;IACxF;IACA,IAAI9B,MAAM,GAAG6B,QAAQ,CAACG,IAAI,CACtB,IAAI,EACJX,QAAQ,EACRC,MAAM,EACNC,GAAG,EACHH,SAAS,CAACa,IAAI,IAAI,CAAC,CAAC,EACpBT,OAAO,EACP,IACJ,CAAC;IACD,IAAI,CAACxB,MAAM,EAAE,OAAO,IAAIrO,KAAK,CAAC,CAAC;IAC/B,OAAOqO,MAAM,CAACkC,KAAK,CAAC,IAAI,CAACxO,gBAAgB,CAAC;EAC9C,CAAC;EAGDsN,kBAAkB,EAAE,SAAAA,CAASmB,kBAAkB,EAAEC,IAAI,EAAEd,MAAM,EAAEe,IAAI,EAAEb,OAAO,EAAE;IAE1E,IAAIZ,eAAe;IACnB,IAAIZ,MAAM,GAAGqC,IAAI,CAACC,GAAG;IACrB,IAAI7B,YAAY,GAAG,IAAI,CAACzL,KAAK,CAACoF,OAAO;IAErC,IAAI,CAAC+H,kBAAkB,EAAE,OAAOnC,MAAM;IACtC,IAAIuC,iBAAiB;IACrB,IAAI,OAAOJ,kBAAkB,KAAK,UAAU,EAAE;MAC1CI,iBAAiB,GAAGJ,kBAAkB;IAC1C,CAAC,MAAM;MACH,IAAIK,mBAAmB,GAAGL,kBAAkB,CAACR,IAAI;MACjDY,iBAAiB,GAAG9B,YAAY,CAACgC,wBAAwB,CAACD,mBAAmB,CAAC;MAC9E,IAAI,OAAOD,iBAAiB,KAAK,UAAU,EAAE,MAAM,IAAI9J,KAAK,CAAC,4BAA4B,GAAG+J,mBAAmB,CAAC;IACpH;IACA5B,eAAe,GAAG2B,iBAAiB,CAACP,IAAI,CAAC,IAAI,EAAEK,IAAI,EAAED,IAAI,EAAEd,MAAM,EAAEa,kBAAkB,CAACF,IAAI,IAAI,CAAC,CAAC,EAAET,OAAO,EAAE,IAAI,CAAC;IAChH,IAAI,CAACZ,eAAe,EAAE,OAAOZ,MAAM;IACnC,OAAOY,eAAe,CAACsB,KAAK,CAAC,IAAI,CAACxO,gBAAgB,CAAC;EACvD,CAAC;EAED;EACAgP,gCAAgC,EAAE,SAAAA,CAAA,EAAW;IAEzC,IAAIjN,KAAK,GAAG,IAAI,CAACA,KAAK;IAEtB,IAAIiF,mBAAmB,GAAGjF,KAAK,CAACkF,SAAS,CAACC,YAAY;IACtD,IAAI+H,2BAA2B,GAAGjI,mBAAmB,CAACkI,QAAQ;IAE9D,IAAIhI,YAAY,GAAGnF,KAAK,CAACqF,gBAAgB,CAAC,CAAC;IAC3C,IAAI+H,oBAAoB,GAAG,IAAI,CAACC,uBAAuB,CAAClI,YAAY,CAACgI,QAAQ,CAAC;IAE9E,OAAOzR,KAAK,CAAC,CAAC,CAAC,EAAEwR,2BAA2B,EAAEE,oBAAoB,CAAC;EACvE,CAAC;EAED;EACA;EACAC,uBAAuB,EAAE,SAAAA,CAASC,aAAa,EAAE;IAE7C,IAAI,OAAOA,aAAa,KAAK,QAAQ,EAAE,OAAO;MAAEC,QAAQ,EAAED,aAAa;MAAEvE,MAAM,EAAE,IAAI;MAAEyE,KAAK,EAAE,CAAC;MAAEhB,IAAI,EAAE;IAAK,CAAC;IAC7G,OAAOc,aAAa;EACxB,CAAC;EAED;EACA;EACAG,2BAA2B,EAAE,SAAAA,CAASC,uBAAuB,EAAEC,8BAA8B,EAAE;IAE3F,IAAID,uBAAuB,KAAK,IAAI,EAAE,OAAO,IAAI;IACjD,IAAIA,uBAAuB,KAAKhK,SAAS,EAAE;MAEvC,IAAIiK,8BAA8B,KAAK,IAAI,EAAE,OAAO,IAAI;MACxD,OAAOA,8BAA8B;IACzC;IAEA,OAAOjS,KAAK,CAAC,CAAC,CAAC,EAAEiS,8BAA8B,EAAED,uBAAuB,CAAC;EAC7E,CAAC;EAED5M,oBAAoB,EAAE,SAAAA,CAAA,EAAW;IAE7B,IAAI,CAAC,IAAI,CAAChD,EAAE,CAACY,MAAM,EAAE,OAAO,IAAI;IAEhC,IAAIoK,IAAI,GAAG,IAAI,CAACA,IAAI;IACpB,IAAI,CAACA,IAAI,EAAE,OAAO,IAAI;;IAEtB;IACA;;IAEA,IAAI9I,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAItB,MAAM,GAAGsB,KAAK,CAAC+C,GAAG,CAAC,QAAQ,CAAC,IAAI,EAAE;IACtC,IAAI,CAACrE,MAAM,CAAC8C,MAAM,EAAE,OAAO,IAAI;IAE/B,IAAI4L,oBAAoB,GAAG,IAAI,CAACH,gCAAgC,CAAC,CAAC;IAElE,KAAK,IAAIW,GAAG,GAAG,CAAC,EAAErM,CAAC,GAAG7C,MAAM,CAAC8C,MAAM,EAAEoM,GAAG,GAAGrM,CAAC,EAAEqM,GAAG,EAAE,EAAE;MACjD,IAAI5I,SAAS,GAAG,IAAI,CAACpH,WAAW,CAACgQ,GAAG,CAAC;MACrC,IAAI,CAAC5I,SAAS,EAAE;MAChB,IAAID,KAAK,GAAGrG,MAAM,CAACkP,GAAG,CAAC;MACvB,IAAIN,aAAa,GAAG,IAAI,CAACD,uBAAuB,CAACtI,KAAK,CAACoI,QAAQ,CAAC;MAChE,IAAIA,QAAQ,GAAG,IAAI,CAACM,2BAA2B,CAACH,aAAa,EAAEF,oBAAoB,CAAC;MACpF,IAAIS,oBAAoB,GAAG,IAAI,CAACC,6BAA6B,CAACX,QAAQ,CAAC;MACvEnI,SAAS,CAACQ,YAAY,CAAC,WAAW,EAAEhK,CAAC,CAACuS,uBAAuB,CAACF,oBAAoB,CAAC,CAAC;MACpF,IAAI,CAACG,mBAAmB,CAACJ,GAAG,CAAC;IACjC;IAEA,OAAO,IAAI;EACf,CAAC;EAEDI,mBAAmB,EAAE,SAAAA,CAASC,KAAK,EAAE;IACjC;IACA;IACA;IACA,MAAM;MAAEjQ,OAAO;MAAEH;IAAgB,CAAC,GAAG,IAAI;IACzC,MAAMyF,SAAS,GAAGzF,eAAe,CAACoQ,KAAK,CAAC;IACxC,IAAI,CAAC3K,SAAS,EAAE;IAChB,KAAK,IAAIoC,QAAQ,IAAIpC,SAAS,EAAE;MAC5B,MAAM;QAAEwB;MAAG,CAAC,GAAGxB,SAAS,CAACoC,QAAQ,CAAC;MAClC,IAAIZ,EAAE,IAAKA,EAAE,IAAI9G,OAAQ,EAAE,OAAOA,OAAO,CAAC8G,EAAE,CAAC,CAACoJ,YAAY;IAC9D;EACJ,CAAC;EAED7O,mBAAmB,EAAE,SAAAA,CAAS0M,OAAO,EAAE;IAEnC,MAAM;MAAE/L,KAAK;MAAET;IAAM,CAAC,GAAG,IAAI;IAC7B,MAAM4O,eAAe,GAAG,GAAGpC,OAAO,MAAM;IACxC,MAAMqC,MAAM,GAAGpO,KAAK,CAAC+C,GAAG,CAACgJ,OAAO,CAAC;IACjC,MAAMsC,KAAK,GAAGD,MAAM,IAAIA,MAAM,CAACtJ,EAAE;IAEjC,IAAI,CAACuJ,KAAK,EAAE;MACR;MACA,IAAI,CAACF,eAAe,CAAC,GAAG,IAAI;MAC5B,IAAI,CAACG,eAAe,CAACvC,OAAO,CAAC;MAC7B,OAAO,IAAI;IACf;IAEA,MAAMwC,QAAQ,GAAGhP,KAAK,CAACiP,YAAY,CAACH,KAAK,CAAC;IAC1C,IAAI,CAACE,QAAQ,EAAE,MAAM,IAAIvL,KAAK,CAAC,oBAAoB,GAAG+I,OAAO,GAAG,QAAQ,CAAC;IAEzE,MAAM0C,OAAO,GAAGF,QAAQ,CAACG,QAAQ,CAACnP,KAAK,CAAC;IACxC,IAAI,CAACkP,OAAO,EAAE;MACV;MACA,OAAO,KAAK;IAChB;IAEA,IAAI,CAACN,eAAe,CAAC,GAAGM,OAAO;IAC/B,IAAI,CAACH,eAAe,CAACvC,OAAO,CAAC;IAC7B,OAAO,IAAI;EACf,CAAC;EAEDuC,eAAe,EAAE,SAAAA,CAASvC,OAAO,EAAE;IAE/B,MAAM4C,iBAAiB,GAAG,GAAG5C,OAAO,QAAQ;IAC5C,MAAM0C,OAAO,GAAG,IAAI,CAACtG,UAAU,CAAC4D,OAAO,CAAC;IACxC,IAAI0C,OAAO,EAAE;MACT,IAAIG,eAAe,GAAGH,OAAO,CAACI,oBAAoB,CAAC,IAAI,CAAC7O,KAAK,CAAC+C,GAAG,CAACgJ,OAAO,CAAC,CAAC;MAC3E,IAAI6C,eAAe,KAAKH,OAAO,CAAC1N,EAAE,EAAE6N,eAAe,GAAG,IAAI;MAC1D,IAAI,CAACD,iBAAiB,CAAC,GAAGC,eAAe;IAC7C,CAAC,MAAM;MACH,IAAI,CAACD,iBAAiB,CAAC,GAAG,IAAI;IAClC;EACJ,CAAC;EAEDG,yBAAyB,EAAE,SAAAA,CAASlB,GAAG,EAAE;IAErC,OAAQ,IAAI,CAAC5N,KAAK,CAAC+E,KAAK,CAAC6I,GAAG,CAAC,CAACT,QAAQ,IAAI,CAAC,CAAC;EAChD,CAAC;EAED4B,sBAAsB,EAAE,SAAAA,CAASnB,GAAG,EAAE;IAElC,IAAIN,aAAa,GAAG,IAAI,CAACwB,yBAAyB,CAAClB,GAAG,CAAC;IACvD,OAAQN,aAAa,CAACE,KAAK,IAAI,CAAC;EACpC,CAAC;EAEDwB,qBAAqB,EAAE,SAAAA,CAASpB,GAAG,EAAE;IAEjC,IAAIN,aAAa,GAAG,IAAI,CAACwB,yBAAyB,CAAClB,GAAG,CAAC;IACvD,OAAON,aAAa,CAACd,IAAI;EAC7B,CAAC;EAEDyC,4BAA4B,EAAE,SAAAA,CAAA,EAAW;IAErC,IAAI9J,YAAY,GAAG,IAAI,CAACnF,KAAK,CAACqF,gBAAgB,CAAC,CAAC;IAChD,IAAI+H,oBAAoB,GAAGjI,YAAY,CAACgI,QAAQ,IAAI,CAAC,CAAC;IACtD,OAAOC,oBAAoB,CAACZ,IAAI;EACpC,CAAC;EAED;EACA;EACA0C,uBAAuB,EAAE,SAAAA,CAASC,iBAAiB,EAAEC,wBAAwB,EAAE;IAE3E,IAAID,iBAAiB,KAAK,IAAI,EAAE,OAAO,IAAI;IAC3C,IAAIA,iBAAiB,KAAKzL,SAAS,EAAE;MAEjC,IAAI0L,wBAAwB,KAAK,IAAI,EAAE,OAAO,IAAI;MAClD,OAAOA,wBAAwB;IACnC;IAEA,OAAO1T,KAAK,CAAC,CAAC,CAAC,EAAE0T,wBAAwB,EAAED,iBAAiB,CAAC;EACjE,CAAC;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACAE,QAAQ,EAAE,SAAAA,CAASC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAE;IAE/B;IACA,IAAIC,MAAM;IACV,IAAIC,MAAM;IACV,IAAIC,UAAU,GAAG,CAAC;IAClB,IAAIC,QAAQ;IACZ,IAAI,OAAOP,EAAE,KAAK,QAAQ,EAAE;MACxB;MACAI,MAAM,GAAGJ,EAAE,CAACQ,CAAC;MACbH,MAAM,GAAGL,EAAE,CAACS,CAAC;MACb,IAAI,OAAOR,EAAE,KAAK,QAAQ,EAAE;QACxB;QACAK,UAAU,GAAGL,EAAE;QACfM,QAAQ,GAAGL,EAAE;MACjB,CAAC,MAAM;QACH;QACAK,QAAQ,GAAGN,EAAE;MACjB;IACJ,CAAC,MAAM;MACH;MACAG,MAAM,GAAGJ,EAAE;MACXK,MAAM,GAAGJ,EAAE;MACX,IAAI,OAAOC,EAAE,KAAK,QAAQ,EAAE;QACxB;QACAI,UAAU,GAAGJ,EAAE;QACfK,QAAQ,GAAGJ,EAAE;MACjB,CAAC,MAAM;QACH;QACAI,QAAQ,GAAGL,EAAE;MACjB;IACJ;;IAEA;IACA,IAAIJ,wBAAwB,GAAG,IAAI,CAACH,4BAA4B,CAAC,CAAC;IAClE,IAAIE,iBAAiB,GAAGU,QAAQ;IAChC,IAAIG,YAAY,GAAG,IAAI,CAACd,uBAAuB,CAACC,iBAAiB,EAAEC,wBAAwB,CAAC;;IAE5F;IACA,IAAIrK,KAAK,GAAG;MAAEoI,QAAQ,EAAE,IAAI,CAAC8C,gBAAgB,CAACP,MAAM,EAAEC,MAAM,EAAEC,UAAU,EAAEI,YAAY;IAAE,CAAC;IACzF,IAAIpC,GAAG,GAAG,CAAC,CAAC;IACZ,IAAI,CAAC5N,KAAK,CAACkQ,WAAW,CAACtC,GAAG,EAAE7I,KAAK,EAAE8K,QAAQ,CAAC;IAC5C,OAAOjC,GAAG;EACd,CAAC;EAED;EACAuC,SAAS,EAAE,SAAAA,CAASL,CAAC,EAAEC,CAAC,EAAE5Q,GAAG,EAAE;IAE3B;IACA,IAAIiR,eAAe,GAAI,OAAON,CAAC,KAAK,QAAS;IAC7C,IAAIJ,MAAM,GAAGU,eAAe,GAAGN,CAAC,CAACA,CAAC,GAAGA,CAAC;IACtC,IAAIH,MAAM,GAAGS,eAAe,GAAGN,CAAC,CAACC,CAAC,GAAGA,CAAC;IACtC,IAAIF,QAAQ,GAAGO,eAAe,GAAGL,CAAC,GAAG5Q,GAAG;IAExC,IAAIkR,MAAM,GAAG;MAAEP,CAAC,EAAEJ,MAAM;MAAEK,CAAC,EAAEJ;IAAO,CAAC;IACrC,IAAI/B,GAAG,GAAG,IAAI,CAAC0C,cAAc,CAACZ,MAAM,EAAEC,MAAM,CAAC;IAC7C,IAAI,CAAC3P,KAAK,CAACuQ,YAAY,CAAC3C,GAAG,EAAEyC,MAAM,EAAER,QAAQ,CAAC;IAC9C,OAAOjC,GAAG;EACd,CAAC;EAED;EACA;EACA;EACA;EACA;EACA;EACA4C,SAAS,EAAE,SAAAA,CAASC,KAAK,EAAEtR,GAAG,EAAEuR,QAAQ,EAAE;IAEtC,SAASC,cAAcA,CAACC,MAAM,EAAEF,QAAQ,EAAE;MACtC,OAAO,YAAW;QACdE,MAAM,CAAClM,MAAM,CAAC,CAAC;QACf,IAAI,OAAOgM,QAAQ,KAAK,UAAU,EAAE;UAChCA,QAAQ,CAAC,CAAC;QACd;MACJ,CAAC;IACL;IAEA,IAAIG,QAAQ,EAAEC,UAAU,EAAEpL,QAAQ;IAClC,IAAI9J,QAAQ,CAACuD,GAAG,CAAC,EAAE;MACf0R,QAAQ,GAAG1R,GAAG,CAAC0R,QAAQ;MACvBC,UAAU,GAAI3R,GAAG,CAAC4R,SAAS,KAAK,SAAU;MAC1CrL,QAAQ,GAAGvG,GAAG,CAAC6R,UAAU;IAC7B,CAAC,MAAM;MACH;MACAH,QAAQ,GAAG1R,GAAG;MACd2R,UAAU,GAAG,KAAK;MAClBpL,QAAQ,GAAG,IAAI;IACnB;IAEAmL,QAAQ,GAAGA,QAAQ,IAAI,IAAI;IAE3B,IAAII,mBAAmB,GAAG;MACtBC,GAAG,EAAEL,QAAQ,GAAG,IAAI;MACpBM,WAAW,EAAE,CAAC;MACdC,QAAQ,EAAE,QAAQ;MAClBC,IAAI,EAAE;IACV,CAAC;IAED,IAAIP,UAAU,EAAE;MACZG,mBAAmB,CAACK,SAAS,GAAG,KAAK;MACrCL,mBAAmB,CAACM,QAAQ,GAAG,KAAK;IACxC;IAEA,IAAIX,MAAM,GAAGpV,CAAC,CAACiV,KAAK,CAAC;IACrB,IAAIO,UAAU;IACd,IAAI,OAAOtL,QAAQ,KAAK,QAAQ,EAAE;MAC9B;MACAsL,UAAU,GAAG,IAAI,CAACQ,QAAQ,CAAC9L,QAAQ,CAAC;IACxC,CAAC,MAAM;MACH;MACA,IAAIrB,KAAK,GAAG,IAAI,CAACvG,EAAE;MACnBkT,UAAU,GAAI3M,KAAK,CAAC2M,UAAU,GAAI3M,KAAK,CAAC2M,UAAU,CAACpN,IAAI,GAAG,IAAI,CAAC7C,EAAE,CAAC0Q,aAAa,CAAC,MAAM,CAAC;IAC3F;IAEA,IAAI,EAAET,UAAU,YAAYU,cAAc,CAAC,EAAE;MACzC,MAAM,IAAI1O,KAAK,CAAC,iEAAiE,CAAC;IACtF;IAEA4N,MAAM,CACDe,QAAQ,CAAC,IAAI,CAACpS,KAAK,CAACqS,KAAK,CAAC,CAC1BC,gBAAgB,CAACZ,mBAAmB,EAAED,UAAU,CAAC;IAEtDc,UAAU,CAACnB,cAAc,CAACC,MAAM,EAAEF,QAAQ,CAAC,EAAEG,QAAQ,CAAC;EAC1D,CAAC;EAED1H,SAAS,EAAE,SAAAA,CAASvK,QAAQ,EAAE;IAE1BA,QAAQ,KAAKA,QAAQ,GAAG,EAAE,CAAC;IAE3B,IAAImT,SAAS,GAAG,IAAI,CAACxS,KAAK,CAACoF,OAAO,CAACqN,eAAe,IAAIxV,OAAO;IAC7D,IAAIgC,MAAM,GAAG,IAAI,CAACwB,KAAK,CAACxB,MAAM,CAAC,CAAC;IAChC,IAAIyT,aAAa,GAAG,IAAI,CAAC1S,KAAK,CAACoF,OAAO,CAACsN,aAAa;IAEpD,IAAI,CAACzT,MAAM,EAAE;MACT,IAAIyT,aAAa,EAAEzT,MAAM,GAAGyT,aAAa,CAAC,KACrC,OAAOrT,QAAQ,CAACkJ,GAAG,CAAC5L,KAAK,CAAC,CAAC,CAAC;IACrC;IAEA,IAAIgW,QAAQ,GAAGrW,UAAU,CAAC2C,MAAM,CAAC,GAAGA,MAAM,GAAGuT,SAAS,CAACvT,MAAM,CAAC0N,IAAI,CAAC;IACnE,IAAI,CAACrQ,UAAU,CAACqW,QAAQ,CAAC,EAAE;MACvB,MAAM,IAAIlP,KAAK,CAAC,iCAAiC,GAAGxE,MAAM,CAAC0N,IAAI,GAAG,IAAI,CAAC;IAC3E;IAEA,IAAIM,IAAI,GAAGhO,MAAM,CAACgO,IAAI,IAAI,CAAC,CAAC;IAE5B,IAAI3D,KAAK,GAAGqJ,QAAQ,CAAC3F,IAAI,CACrB,IAAI;IAAE;IACN3N,QAAQ;IAAE;IACV4N,IAAI;IAAE;IACN,IAAI,CAAC;IACT,CAAC;IAED,IAAI,CAAC3D,KAAK,EAAE,OAAOjK,QAAQ,CAACkJ,GAAG,CAAC5L,KAAK,CAAC;IACtC,OAAO2M,KAAK;EAChB,CAAC;EAED;EACA;EACAS,QAAQ,EAAE,SAAAA,CAAST,KAAK,EAAEN,WAAW,EAAEC,WAAW,EAAE;IAEhD,IAAIuJ,SAAS,GAAG,IAAI,CAACxS,KAAK,CAACoF,OAAO,CAACwN,kBAAkB,IAAI1V,UAAU;IACnE,IAAIgC,SAAS,GAAG,IAAI,CAACuB,KAAK,CAACvB,SAAS,CAAC,CAAC;IACtC,IAAI2T,gBAAgB,GAAG,IAAI,CAAC7S,KAAK,CAACoF,OAAO,CAACyN,gBAAgB;IAE1D,IAAI,CAAC3T,SAAS,EAAE;MACZA,SAAS,GAAG2T,gBAAgB,IAAI,CAAC,CAAC;IACtC;IAEA,IAAIC,WAAW,GAAGxW,UAAU,CAAC4C,SAAS,CAAC,GAAGA,SAAS,GAAGsT,SAAS,CAACtT,SAAS,CAACyN,IAAI,CAAC;IAC/E,IAAI,CAACrQ,UAAU,CAACwW,WAAW,CAAC,EAAE;MAC1B,MAAM,IAAIrP,KAAK,CAAC,oCAAoC,GAAGvE,SAAS,CAACyN,IAAI,GAAG,IAAI,CAAC;IACjF;IAEA,IAAIM,IAAI,GAAG1Q,KAAK,CAAC2C,SAAS,CAAC+N,IAAI,IAAI,CAAC,CAAC,CAAC;IACtCA,IAAI,CAAC8F,GAAG,GAAG,IAAI,CAAC,CAAC;;IAEjB,IAAIxJ,IAAI,GAAGuJ,WAAW,CAAC9F,IAAI,CACvB,IAAI;IAAE;IACNhE,WAAW;IAAE;IACbC,WAAW;IAAE;IACbK,KAAK;IAAE;IACP2D,IAAI;IAAE;IACN,IAAI,CAAC;IACT,CAAC;IAED,IAAI,OAAO1D,IAAI,KAAK,QAAQ,EAAE;MAC1B;MACAA,IAAI,GAAG,IAAI1M,IAAI,CAACZ,CAAC,CAAC+W,iBAAiB,CAACzJ,IAAI,CAAC,CAAC;IAC9C;IAEA,OAAOA,IAAI;EACf,CAAC;EAED;EACA;;EAEA0J,aAAa,EAAE,SAAAA,CAAA,EAAW;IAEtB,IAAI1J,IAAI,GAAG,IAAI,CAACA,IAAI;IACpB,IAAI,CAACA,IAAI,EAAE,OAAO,IAAI;IAEtB,OAAOA,IAAI,CAAChN,KAAK,CAAC,CAAC;EACvB,CAAC;EAED2W,uBAAuB,EAAE,SAAAA,CAAA,EAAW;IAEhC,IAAI3J,IAAI,GAAG,IAAI,CAACA,IAAI;IACpB,IAAI,CAACA,IAAI,EAAE,OAAO,IAAI;IAEtB,IAAI9K,OAAO,GAAG,IAAI,CAACA,OAAO;IAC1B,IAAIA,OAAO,CAAC0U,cAAc,CAAC,MAAM,CAAC,EAAE,OAAO1U,OAAO,CAAC2U,IAAI;IACvD,IAAIA,IAAI,GAAG7J,IAAI,CAAC8J,SAAS,CAAC,CAAC;IAC3B5U,OAAO,CAAC2U,IAAI,GAAGA,IAAI;IACnB,OAAOA,IAAI;EACf,CAAC;EAEDE,yBAAyB,EAAE,SAAAA,CAAA,EAAW;IAElC,IAAI/J,IAAI,GAAG,IAAI,CAACA,IAAI;IACpB,IAAI,CAACA,IAAI,EAAE,OAAO,IAAI;IAEtB,IAAI9K,OAAO,GAAG,IAAI,CAACA,OAAO;IAC1B,IAAIA,OAAO,CAAC0U,cAAc,CAAC,qBAAqB,CAAC,EAAE,OAAO1U,OAAO,CAAC8U,mBAAmB;IACrF,IAAIC,YAAY,GAAGjK,IAAI,CAACkK,sBAAsB,CAAC,CAAC;IAChDhV,OAAO,CAAC8U,mBAAmB,GAAGC,YAAY;IAC1C,OAAOA,YAAY;EACvB,CAAC;EAEDE,mBAAmB,EAAE,SAAAA,CAAA,EAAW;IAE5B,IAAInK,IAAI,GAAG,IAAI,CAACA,IAAI;IACpB,IAAI,CAACA,IAAI,EAAE,OAAO,CAAC;IAEnB,IAAI9K,OAAO,GAAG,IAAI,CAACA,OAAO;IAC1B,IAAIA,OAAO,CAAC0U,cAAc,CAAC,QAAQ,CAAC,EAAE,OAAO1U,OAAO,CAACwD,MAAM;IAC3D,IAAIA,MAAM,GAAGsH,IAAI,CAACtH,MAAM,CAAC;MAAEsR,mBAAmB,EAAE,IAAI,CAACD,yBAAyB,CAAC;IAAE,CAAC,CAAC;IACnF7U,OAAO,CAACwD,MAAM,GAAGA,MAAM;IACvB,OAAOA,MAAM;EACjB,CAAC;EAED0R,gBAAgB,EAAE,SAAAA,CAAS1R,MAAM,EAAE;IAE/B,IAAIsH,IAAI,GAAG,IAAI,CAACA,IAAI;IACpB,IAAI,CAACA,IAAI,EAAE,OAAO,IAAI;IAEtB,OAAOA,IAAI,CAACqK,aAAa,CAAC3R,MAAM,EAAE;MAAEsR,mBAAmB,EAAE,IAAI,CAACD,yBAAyB,CAAC;IAAE,CAAC,CAAC;EAChG,CAAC;EAEDO,eAAe,EAAE,SAAAA,CAASC,KAAK,EAAE;IAE7B,IAAIvK,IAAI,GAAG,IAAI,CAACA,IAAI;IACpB,IAAI,CAACA,IAAI,EAAE,OAAO,IAAI;IACtB,IAAI/M,YAAY,CAACsX,KAAK,CAAC,EAAEA,KAAK,GAAGC,UAAU,CAACD,KAAK,CAAC,GAAG,GAAG;IACxD,OAAOvK,IAAI,CAACyK,OAAO,CAACF,KAAK,EAAE;MAAEP,mBAAmB,EAAE,IAAI,CAACD,yBAAyB,CAAC;IAAE,CAAC,CAAC;EACzF,CAAC;EAEDW,kBAAkB,EAAE,SAAAA,CAAShS,MAAM,EAAE;IAEjC,IAAIsH,IAAI,GAAG,IAAI,CAACA,IAAI;IACpB,IAAI,CAACA,IAAI,EAAE,OAAO,IAAI;IAEtB,OAAOA,IAAI,CAAC2K,eAAe,CAACjS,MAAM,EAAE;MAAEsR,mBAAmB,EAAE,IAAI,CAACD,yBAAyB,CAAC;IAAE,CAAC,CAAC;EAClG,CAAC;EAEDa,iBAAiB,EAAE,SAAAA,CAASL,KAAK,EAAE;IAE/B,IAAIvK,IAAI,GAAG,IAAI,CAACA,IAAI;IACpB,IAAI,CAACA,IAAI,EAAE,OAAO,IAAI;IAEtB,OAAOA,IAAI,CAAC6K,SAAS,CAACN,KAAK,EAAE;MAAEP,mBAAmB,EAAE,IAAI,CAACD,yBAAyB,CAAC;IAAE,CAAC,CAAC;EAC3F,CAAC;EAEDe,eAAe,EAAE,SAAAA,CAAS7L,KAAK,EAAE;IAE7B,IAAIe,IAAI,GAAG,IAAI,CAACA,IAAI;IACpB,IAAI,CAACA,IAAI,EAAE,OAAO,IAAI;IAEtB,OAAOA,IAAI,CAAC+K,YAAY,CAAC9L,KAAK,EAAE;MAAE+K,mBAAmB,EAAE,IAAI,CAACD,yBAAyB,CAAC;IAAE,CAAC,CAAC;EAC9F,CAAC;EAEDiB,qBAAqB,EAAE,SAAAA,CAAS/L,KAAK,EAAE;IAEnC,IAAIe,IAAI,GAAG,IAAI,CAACA,IAAI;IACpB,IAAI,CAACA,IAAI,EAAE,OAAO,IAAI;IAEtB,OAAOA,IAAI,CAACiL,kBAAkB,CAAChM,KAAK,EAAE;MAAE+K,mBAAmB,EAAE,IAAI,CAACD,yBAAyB,CAAC;IAAE,CAAC,CAAC;EACpG,CAAC;EAEDmB,oBAAoB,EAAE,SAAAA,CAASjM,KAAK,EAAE;IAElC,IAAIe,IAAI,GAAG,IAAI,CAACA,IAAI;IACpB,IAAI,CAACA,IAAI,EAAE,OAAO,IAAI;IAEtB,OAAOA,IAAI,CAACmL,4BAA4B,CAAClM,KAAK,EAAE;MAAE+K,mBAAmB,EAAE,IAAI,CAACD,yBAAyB,CAAC;IAAE,CAAC,CAAC;EAC9G,CAAC;EAED;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA5C,gBAAgB,EAAE,SAAAA,CAASH,CAAC,EAAEC,CAAC,EAAEP,EAAE,EAAEC,EAAE,EAAE;IAErC,IAAItC,QAAQ,GAAG,CAAC,CAAC;;IAEjB;IACA,IAAIyC,UAAU,GAAG,CAAC;IAClB,IAAIC,QAAQ;IACZ,IAAI,OAAOL,EAAE,KAAK,QAAQ,EAAE;MACxB;MACAI,UAAU,GAAGJ,EAAE;MACfK,QAAQ,GAAGJ,EAAE;IACjB,CAAC,MAAM;MACH;MACAI,QAAQ,GAAGL,EAAE;IACjB;;IAEA;IACA,IAAIK,QAAQ,EAAE1C,QAAQ,CAACX,IAAI,GAAGqD,QAAQ;;IAEtC;IACA,IAAIqE,kBAAkB,GAAG,EAAErE,QAAQ,IAAIA,QAAQ,CAACsE,gBAAgB,CAAC,CAAC,CAAC;IACnE,IAAIC,yBAAyB,GAAIvE,QAAQ,IAAIA,QAAQ,CAACsE,gBAAgB,IAAItE,QAAQ,CAACwE,eAAgB,CAAC,CAAC;IACrG,IAAIC,gBAAgB,GAAGzE,QAAQ,IAAIA,QAAQ,CAAC0E,cAAc,CAAC,CAAC;;IAE5D;IACA,IAAIzL,IAAI,GAAG,IAAI,CAACA,IAAI;IACpB,IAAI0L,OAAO,GAAG;MAAE1B,mBAAmB,EAAE,IAAI,CAACD,yBAAyB,CAAC;IAAE,CAAC;IACvE,IAAI4B,UAAU,GAAG,IAAIvY,KAAK,CAAC4T,CAAC,EAAEC,CAAC,CAAC;IAChC,IAAI2E,CAAC,GAAG5L,IAAI,CAAC6L,aAAa,CAACF,UAAU,EAAED,OAAO,CAAC;;IAE/C;IACA,IAAII,aAAa,GAAG9L,IAAI,CAAC+L,SAAS,CAACH,CAAC,EAAEF,OAAO,CAAC;IAC9C,IAAIN,kBAAkB,EAAEU,aAAa,GAAIA,aAAa,GAAG,IAAI,CAAC3B,mBAAmB,CAAC,CAAC,IAAK,CAAC,CAAC,CAAC;IAC3F,IAAImB,yBAAyB,EAAEQ,aAAa,GAAI,CAAC,CAAC,IAAI,IAAI,CAAC3B,mBAAmB,CAAC,CAAC,GAAG2B,aAAa,CAAC,IAAK,CAAC,CAAC,CAAC;IACzGzH,QAAQ,CAACI,QAAQ,GAAGqH,aAAa;;IAEjC;IACA;IACA;IACA;IACA,IAAIE,OAAO;IACX,IAAI,CAACR,gBAAgB,EAAEQ,OAAO,GAAGhM,IAAI,CAACiM,UAAU,CAACL,CAAC,CAAC;IACnD,IAAIM,WAAW;IACf,IAAIF,OAAO,EAAE;MACTE,WAAW,GAAGF,OAAO,CAACG,WAAW,CAACR,UAAU,CAAC;IACjD,CAAC,MAAM;MACH,IAAIZ,YAAY,GAAG/K,IAAI,CAACoM,QAAQ,CAACR,CAAC,CAAC;MACnC,IAAIS,eAAe,GAAGV,UAAU,CAACW,UAAU,CAACvB,YAAY,CAAC;MACzDmB,WAAW,GAAG;QAAElF,CAAC,EAAEqF,eAAe,CAACrF,CAAC;QAAEC,CAAC,EAAEoF,eAAe,CAACpF;MAAE,CAAC;IAChE;IACA5C,QAAQ,CAACpE,MAAM,GAAGiM,WAAW;;IAE7B;IACA7H,QAAQ,CAACK,KAAK,GAAGoC,UAAU;IAE3B,OAAOzC,QAAQ;EACnB,CAAC;EAEDW,6BAA6B,EAAE,SAAAA,CAASR,aAAa,EAAE;IAEnD,IAAIsH,aAAa;IACjB,IAAIS,UAAU,GAAG,CAAC;IAClB,IAAI7I,IAAI,GAAG,CAAC,CAAC;IACb,IAAI,OAAOc,aAAa,KAAK,QAAQ,EAAE;MACnCsH,aAAa,GAAGtH,aAAa;IACjC,CAAC,MAAM,IAAI,OAAOA,aAAa,CAACC,QAAQ,KAAK,QAAQ,EAAE;MACnDf,IAAI,GAAGc,aAAa,CAACd,IAAI,IAAI,CAAC,CAAC;MAC/BoI,aAAa,GAAGtH,aAAa,CAACC,QAAQ;MACtC8H,UAAU,GAAG/H,aAAa,CAACE,KAAK,IAAI,CAAC;IACzC,CAAC,MAAM;MACH,MAAM,IAAIxK,KAAK,CAAC,gDAAgD,CAAC;IACrE;IAEA,IAAIkR,kBAAkB,GAAKU,aAAa,GAAG,CAAC,IAAMA,aAAa,IAAI,CAAG;IAEtE,IAAII,WAAW,GAAG,CAAC;IACnB,IAAIM,sBAAsB,GAAG;MAAExF,CAAC,EAAE,CAAC;MAAEC,CAAC,EAAE;IAAE,CAAC;IAC3C,IAAIzC,aAAa,CAACvE,MAAM,EAAE;MACtB,IAAIwM,cAAc,GAAGjI,aAAa,CAACvE,MAAM;MACzC,IAAI,OAAOwM,cAAc,KAAK,QAAQ,EAAEP,WAAW,GAAGO,cAAc;MACpE,IAAIA,cAAc,CAACzF,CAAC,EAAEwF,sBAAsB,CAACxF,CAAC,GAAGyF,cAAc,CAACzF,CAAC;MACjE,IAAIyF,cAAc,CAACxF,CAAC,EAAEuF,sBAAsB,CAACvF,CAAC,GAAGwF,cAAc,CAACxF,CAAC;IACrE;IAEA,IAAIuE,gBAAgB,GAAKgB,sBAAsB,CAACxF,CAAC,KAAK,CAAC,IAAMwF,sBAAsB,CAACvF,CAAC,KAAK,CAAE,IAAIiF,WAAW,KAAK,CAAE;IAElH,IAAIQ,cAAc,GAAGhJ,IAAI,CAACiJ,YAAY;IACtC,IAAIC,kBAAkB,GAAGlJ,IAAI,CAACmJ,gBAAgB;IAE9C,IAAI7M,IAAI,GAAG,IAAI,CAACA,IAAI;IACpB,IAAI0L,OAAO,GAAG;MAAE1B,mBAAmB,EAAE,IAAI,CAACD,yBAAyB,CAAC;IAAE,CAAC;IAEvE,IAAItF,QAAQ,GAAG2G,kBAAkB,GAAIU,aAAa,GAAG,IAAI,CAAC3B,mBAAmB,CAAC,CAAC,GAAI2B,aAAa;IAChG,IAAIE,OAAO,GAAGhM,IAAI,CAAC2K,eAAe,CAAClG,QAAQ,EAAEiH,OAAO,CAAC;IAErD,IAAIoB,WAAW;IACf,IAAIpI,KAAK,GAAG6H,UAAU;IACtB,IAAIP,OAAO,EAAE;MACT,IAAIR,gBAAgB,EAAE;QAClBsB,WAAW,GAAGd,OAAO,CAACe,KAAK,CAAC/Z,KAAK,CAAC,CAAC;QACnC8Z,WAAW,CAAC7M,MAAM,CAACuM,sBAAsB,CAAC;MAC9C,CAAC,MAAM;QACH,IAAIQ,MAAM,GAAGhB,OAAO,CAAChZ,KAAK,CAAC,CAAC;QAC5Bga,MAAM,CAACC,MAAM,CAACjB,OAAO,CAACe,KAAK,EAAE,CAAC,EAAE,CAAC;QACjCC,MAAM,CAACE,SAAS,CAAChB,WAAW,CAAC;QAC7BY,WAAW,GAAGE,MAAM,CAACjJ,GAAG;MAC5B;MAEA,IAAI2I,cAAc,EAAE;QAChBhI,KAAK,GAAIsH,OAAO,CAACtH,KAAK,CAAC,CAAC,GAAG6H,UAAW;QACtC,IAAIK,kBAAkB,EAAE;UACpBlI,KAAK,GAAGnR,cAAc,CAAE,CAACmR,KAAK,GAAG,EAAE,IAAI,GAAG,GAAI,EAAE,CAAC;QACrD;MACJ;IAEJ,CAAC,MAAM;MACH;MACAoI,WAAW,GAAG9M,IAAI,CAAC+M,KAAK,CAAC/Z,KAAK,CAAC,CAAC;MAChC,IAAIwY,gBAAgB,EAAEsB,WAAW,CAAC7M,MAAM,CAACuM,sBAAsB,CAAC;IACpE;IAEA,OAAO9Z,CAAC,CAACya,eAAe,CAAC,CAAC,CACrBvV,SAAS,CAACkV,WAAW,CAAC9F,CAAC,EAAE8F,WAAW,CAAC7F,CAAC,CAAC,CACvCgG,MAAM,CAACvI,KAAK,CAAC;EACtB,CAAC;EAED0I,mBAAmB,EAAE,SAAAA,CAAS5I,aAAa,EAAE;IAEzC,IAAIO,oBAAoB,GAAG,IAAI,CAACC,6BAA6B,CAACR,aAAa,CAAC;IAC5E,OAAO,IAAIpR,KAAK,CAAC2R,oBAAoB,CAACsI,CAAC,EAAEtI,oBAAoB,CAACuI,CAAC,CAAC;EACpE,CAAC;EAED9F,cAAc,EAAE,SAAAA,CAASR,CAAC,EAAEC,CAAC,EAAE;IAE3B,IAAI/P,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAIpB,QAAQ,GAAGoB,KAAK,CAACpB,QAAQ,CAAC,CAAC;IAE/B,IAAIyX,YAAY,GAAG,IAAI,CAACvC,qBAAqB,CAAC,IAAI5X,KAAK,CAAC4T,CAAC,EAAEC,CAAC,CAAC,CAAC;IAE9D,IAAInC,GAAG,GAAG,CAAC;IACX,KAAK,IAAIrM,CAAC,GAAG3C,QAAQ,CAAC4C,MAAM,EAAEoM,GAAG,GAAGrM,CAAC,EAAEqM,GAAG,EAAE,EAAE;MAC1C,IAAI0I,aAAa,GAAG1X,QAAQ,CAACgP,GAAG,CAAC;MACjC,IAAI2I,mBAAmB,GAAG,IAAI,CAACzC,qBAAqB,CAACwC,aAAa,CAAC;MACnE,IAAID,YAAY,GAAGE,mBAAmB,EAAE;IAC5C;IAEA,OAAO3I,GAAG;EACd,CAAC;EAED;EACA;;EAEA4I,iBAAiBA,CAACC,GAAG,EAAE3G,CAAC,EAAEC,CAAC,EAAE;IACzBzU,QAAQ,CAACiC,SAAS,CAACmZ,WAAW,CAACnK,IAAI,CAAC,IAAI,EAAEkK,GAAG,EAAE3G,CAAC,EAAEC,CAAC,CAAC;IACpD,IAAI,CAAC4G,MAAM,CAAC,kBAAkB,EAAEF,GAAG,EAAE3G,CAAC,EAAEC,CAAC,CAAC;EAC9C,CAAC;EAED6G,iBAAiBA,CAACH,GAAG,EAAE3G,CAAC,EAAEC,CAAC,EAAE;IACzBzU,QAAQ,CAACiC,SAAS,CAACsZ,WAAW,CAACtK,IAAI,CAAC,IAAI,EAAEkK,GAAG,EAAE3G,CAAC,EAAEC,CAAC,CAAC;IACpD,IAAI,CAAC4G,MAAM,CAAC,kBAAkB,EAAEF,GAAG,EAAE3G,CAAC,EAAEC,CAAC,CAAC;EAC9C,CAAC;EAED+G,eAAeA,CAACL,GAAG,EAAE3G,CAAC,EAAEC,CAAC,EAAE;IACvB,IAAI,CAAC4G,MAAM,CAAC,gBAAgB,EAAEF,GAAG,EAAE3G,CAAC,EAAEC,CAAC,CAAC;IACxCzU,QAAQ,CAACiC,SAAS,CAACwZ,SAAS,CAACxK,IAAI,CAAC,IAAI,EAAEkK,GAAG,EAAE3G,CAAC,EAAEC,CAAC,CAAC;EACtD,CAAC;EAEDiH,eAAe,EAAE,SAAAA,CAASP,GAAG,EAAE3G,CAAC,EAAEC,CAAC,EAAE;IAEjCzU,QAAQ,CAACiC,SAAS,CAACyZ,eAAe,CAACxZ,KAAK,CAAC,IAAI,EAAEW,SAAS,CAAC;IACzD,IAAI,CAACwY,MAAM,CAAC,sBAAsB,EAAEF,GAAG,EAAE3G,CAAC,EAAEC,CAAC,CAAC;EAClD,CAAC;EAEDkH,YAAY,EAAE,SAAAA,CAASR,GAAG,EAAE3G,CAAC,EAAEC,CAAC,EAAE;IAE9BzU,QAAQ,CAACiC,SAAS,CAAC0Z,YAAY,CAACzZ,KAAK,CAAC,IAAI,EAAEW,SAAS,CAAC;IACtD,IAAI,CAACwY,MAAM,CAAC,mBAAmB,EAAEF,GAAG,EAAE3G,CAAC,EAAEC,CAAC,CAAC;EAC/C,CAAC;EAEDmH,WAAW,EAAE,SAAAA,CAAST,GAAG,EAAE3G,CAAC,EAAEC,CAAC,EAAE;IAE7BzU,QAAQ,CAACiC,SAAS,CAAC2Z,WAAW,CAAC1Z,KAAK,CAAC,IAAI,EAAEW,SAAS,CAAC;IACrD,IAAI,CAACwY,MAAM,CAAC,kBAAkB,EAAEF,GAAG,EAAE3G,CAAC,EAAEC,CAAC,CAAC;EAC9C,CAAC;EAED2G,WAAW,EAAE,SAAAA,CAASD,GAAG,EAAE3G,CAAC,EAAEC,CAAC,EAAE;IAE7B,IAAI,CAACyG,iBAAiB,CAACC,GAAG,EAAE3G,CAAC,EAAEC,CAAC,CAAC;IACjC,IAAI,CAACoH,SAAS,CAACV,GAAG,EAAE3G,CAAC,EAAEC,CAAC,CAAC;EAC7B,CAAC;EAED8G,WAAW,EAAE,SAAAA,CAASJ,GAAG,EAAE3G,CAAC,EAAEC,CAAC,EAAE;IAE7B;IACA,IAAIqH,QAAQ,GAAG,IAAI,CAACrZ,SAAS;IAC7B,IAAIqZ,QAAQ,EAAE,IAAI,CAACC,SAAS,CAACZ,GAAG,EAAEW,QAAQ,CAAC;IAE3C,IAAIzE,IAAI,GAAG,IAAI,CAAC0E,SAAS,CAACZ,GAAG,CAAC;IAC9B,QAAQ9D,IAAI,CAAC2E,MAAM;MAEf,KAAK,YAAY;QACb,IAAI,CAACC,SAAS,CAACd,GAAG,EAAE3G,CAAC,EAAEC,CAAC,CAAC;QACzB;MAEJ,KAAK,gBAAgB;QACjB,IAAI,CAACyH,aAAa,CAACf,GAAG,EAAE3G,CAAC,EAAEC,CAAC,CAAC;QAC7B;MAEJ,KAAK,MAAM;QACP,IAAI,CAAC0H,IAAI,CAAChB,GAAG,EAAE3G,CAAC,EAAEC,CAAC,CAAC;QACpB;IACR;;IAEA;IACA,IAAIqH,QAAQ,EAAEzb,MAAM,CAACyb,QAAQ,EAAE,IAAI,CAACC,SAAS,CAACZ,GAAG,CAAC,CAAC;IAEnD,IAAI,CAACG,iBAAiB,CAACH,GAAG,EAAE3G,CAAC,EAAEC,CAAC,CAAC;EACrC,CAAC;EAEDgH,SAAS,EAAE,SAAAA,CAASN,GAAG,EAAE3G,CAAC,EAAEC,CAAC,EAAE;IAE3B;IACA,IAAIqH,QAAQ,GAAG,IAAI,CAACrZ,SAAS;IAC7B,IAAIqZ,QAAQ,EAAE;MACV,IAAI,CAACC,SAAS,CAACZ,GAAG,EAAEW,QAAQ,CAAC;MAC7B,IAAI,CAACrZ,SAAS,GAAG,IAAI;IACzB;IAEA,IAAI4U,IAAI,GAAG,IAAI,CAAC0E,SAAS,CAACZ,GAAG,CAAC;IAC9B,QAAQ9D,IAAI,CAAC2E,MAAM;MAEf,KAAK,YAAY;QACb,IAAI,CAACI,YAAY,CAACjB,GAAG,EAAE3G,CAAC,EAAEC,CAAC,CAAC;QAC5B;MAEJ,KAAK,gBAAgB;QACjB,IAAI,CAAC4H,gBAAgB,CAAClB,GAAG,EAAE3G,CAAC,EAAEC,CAAC,CAAC;QAChC;MAEJ,KAAK,MAAM;QACP,IAAI,CAAC6H,OAAO,CAACnB,GAAG,EAAE3G,CAAC,EAAEC,CAAC,CAAC;IAC/B;IAEA,IAAI,CAAC+G,eAAe,CAACL,GAAG,EAAE3G,CAAC,EAAEC,CAAC,CAAC;IAC/B,IAAI,CAAC8H,eAAe,CAACpB,GAAG,CAAC;EAC7B,CAAC;EAEDqB,SAAS,EAAE,SAAAA,CAASrB,GAAG,EAAE;IAErBnb,QAAQ,CAACiC,SAAS,CAACua,SAAS,CAACta,KAAK,CAAC,IAAI,EAAEW,SAAS,CAAC;IACnD,IAAI,CAACwY,MAAM,CAAC,gBAAgB,EAAEF,GAAG,CAAC;EACtC,CAAC;EAEDsB,QAAQ,EAAE,SAAAA,CAAStB,GAAG,EAAE;IAEpBnb,QAAQ,CAACiC,SAAS,CAACwa,QAAQ,CAACva,KAAK,CAAC,IAAI,EAAEW,SAAS,CAAC;IAClD,IAAI,CAACwY,MAAM,CAAC,eAAe,EAAEF,GAAG,CAAC;EACrC,CAAC;EAEDuB,UAAU,EAAE,SAAAA,CAASvB,GAAG,EAAE;IAEtBnb,QAAQ,CAACiC,SAAS,CAACya,UAAU,CAACxa,KAAK,CAAC,IAAI,EAAEW,SAAS,CAAC;IACpD,IAAI,CAACwY,MAAM,CAAC,iBAAiB,EAAEF,GAAG,CAAC;EACvC,CAAC;EAEDwB,UAAU,EAAE,SAAAA,CAASxB,GAAG,EAAE;IAEtBnb,QAAQ,CAACiC,SAAS,CAAC0a,UAAU,CAACza,KAAK,CAAC,IAAI,EAAEW,SAAS,CAAC;IACpD,IAAI,CAACwY,MAAM,CAAC,iBAAiB,EAAEF,GAAG,CAAC;EACvC,CAAC;EAEDyB,UAAU,EAAE,SAAAA,CAASzB,GAAG,EAAE3G,CAAC,EAAEC,CAAC,EAAEoI,KAAK,EAAE;IAEnC7c,QAAQ,CAACiC,SAAS,CAAC2a,UAAU,CAAC1a,KAAK,CAAC,IAAI,EAAEW,SAAS,CAAC;IACpD,IAAI,CAACwY,MAAM,CAAC,iBAAiB,EAAEF,GAAG,EAAE3G,CAAC,EAAEC,CAAC,EAAEoI,KAAK,CAAC;EACpD,CAAC;EAEDC,OAAO,EAAE,SAAAA,CAAS3B,GAAG,EAAE3G,CAAC,EAAEC,CAAC,EAAE;IAEzB,IAAI,CAACyG,iBAAiB,CAACC,GAAG,EAAE3G,CAAC,EAAEC,CAAC,CAAC;IAEjC,IAAI,CAACsI,cAAc,CAAC5B,GAAG,EAAE3G,CAAC,EAAEC,CAAC,CAAC;IAE9B,IAAIuI,eAAe,GAAG,IAAI,CAACjB,SAAS,CAACZ,GAAG,CAAC,CAAC6B,eAAe;IACzD,IAAIA,eAAe,EAAE7B,GAAG,CAAC6B,eAAe,CAAC,CAAC;EAC9C,CAAC;EAED;;EAEAD,cAAc,EAAE,SAAAA,CAAS5B,GAAG,EAAE3G,CAAC,EAAEC,CAAC,EAAE;IAEhC,IAAI,IAAI,CAAChJ,GAAG,CAAC,WAAW,CAAC,EAAE;MAEvB,IAAI,IAAI,CAACwR,6BAA6B,CAAC9B,GAAG,CAAC,EAAE;MAE7C,IAAIzR,SAAS,GAAGyR,GAAG,CAAC+B,aAAa;MACjC,IAAIC,QAAQ,GAAGC,QAAQ,CAAC1T,SAAS,CAAC2T,YAAY,CAAC,WAAW,CAAC,EAAE,EAAE,CAAC;MAEhE,IAAIvL,oBAAoB,GAAG,IAAI,CAACH,gCAAgC,CAAC,CAAC;MAClE,IAAI2L,oBAAoB,GAAG,IAAI,CAACvL,uBAAuB,CAAC,IAAI,CAACyB,yBAAyB,CAAC2J,QAAQ,CAAC,CAAC;MACjG,IAAItL,QAAQ,GAAG,IAAI,CAACM,2BAA2B,CAACmL,oBAAoB,EAAExL,oBAAoB,CAAC;MAE3F,IAAIyL,MAAM,GAAG,IAAI,CAAC3C,mBAAmB,CAAC/I,QAAQ,CAAC;MAC/C,IAAI2L,EAAE,GAAGD,MAAM,CAAC/I,CAAC,GAAGA,CAAC,CAAC,CAAC;MACvB,IAAIiJ,EAAE,GAAGF,MAAM,CAAC9I,CAAC,GAAGA,CAAC,CAAC,CAAC;;MAEvB,IAAIiJ,aAAa,GAAG,IAAI,CAACjK,sBAAsB,CAAC0J,QAAQ,CAAC;MACzD,IAAItJ,iBAAiB,GAAG,IAAI,CAACH,qBAAqB,CAACyJ,QAAQ,CAAC;MAC5D,IAAIrJ,wBAAwB,GAAG,IAAI,CAACH,4BAA4B,CAAC,CAAC;MAClE,IAAIe,YAAY,GAAG,IAAI,CAACd,uBAAuB,CAACC,iBAAiB,EAAEC,wBAAwB,CAAC;MAE5F,IAAI,CAACiI,SAAS,CAACZ,GAAG,EAAE;QAChBa,MAAM,EAAE,YAAY;QACpBmB,QAAQ,EAAEA,QAAQ;QAClBK,EAAE,EAAEA,EAAE;QACNC,EAAE,EAAEA,EAAE;QACNC,aAAa,EAAEA,aAAa;QAC5BhJ,YAAY,EAAEA,YAAY;QAC1BsI,eAAe,EAAE;MACrB,CAAC,CAAC;IAEN,CAAC,MAAM;MAEH;MACA;MACA,IAAI,CAACjB,SAAS,CAACZ,GAAG,EAAE;QAAE6B,eAAe,EAAE;MAAK,CAAC,CAAC;IAClD;IAEA,IAAI,CAAC/Y,KAAK,CAAC0Z,kBAAkB,CAAC,IAAI,EAAExC,GAAG,CAAC9D,IAAI,CAAC;EACjD,CAAC;EAEDuG,kBAAkB,EAAE,SAAAA,CAASzC,GAAG,EAAE3G,CAAC,EAAEC,CAAC,EAAE;IAEpC,IAAI,CAAC,IAAI,CAAChJ,GAAG,CAAC,eAAe,CAAC,EAAE;IAEhC,IAAIoS,aAAa,GAAG1C,GAAG,CAAC3X,MAAM;IAC9B,IAAIsa,aAAa,GAAGD,aAAa,CAACR,YAAY,CAAC,KAAK,CAAC;IACrD,IAAIhG,IAAI,GAAG,IAAI,CAAC0G,kBAAkB,CAACD,aAAa,EAAE;MAAEE,4BAA4B,EAAE;IAAK,CAAC,CAAC;IAEzF,IAAI,CAACjC,SAAS,CAACZ,GAAG,EAAE9D,IAAI,CAAC;EAC7B,CAAC;EAEDwE,SAAS,EAAE,SAAAA,CAASV,GAAG,EAAE3G,CAAC,EAAEC,CAAC,EAAE;IAE3B,IAAI,IAAI,CAACwI,6BAA6B,CAAC9B,GAAG,CAAC,EAAE;IAE7C,IAAI,CAAC,IAAI,CAAC1P,GAAG,CAAC,UAAU,CAAC,EAAE;IAE3B,IAAI,CAACsQ,SAAS,CAACZ,GAAG,EAAE;MAChBa,MAAM,EAAE,MAAM;MACdwB,EAAE,EAAEhJ,CAAC;MACLiJ,EAAE,EAAEhJ;IACR,CAAC,CAAC;EACN,CAAC;EAED;EACAwH,SAAS,EAAE,SAAAA,CAASd,GAAG,EAAE3G,CAAC,EAAEC,CAAC,EAAE;IAE3B,IAAI4C,IAAI,GAAG,IAAI,CAAC0E,SAAS,CAACZ,GAAG,CAAC;IAC9B,IAAI1R,KAAK,GAAG;MAAEoI,QAAQ,EAAE,IAAI,CAAC8C,gBAAgB,CAAEH,CAAC,GAAG6C,IAAI,CAACmG,EAAE,EAAI/I,CAAC,GAAG4C,IAAI,CAACoG,EAAE,EAAGpG,IAAI,CAACqG,aAAa,EAAErG,IAAI,CAAC3C,YAAY;IAAE,CAAC;IACpH,IAAI,IAAI,CAACzQ,KAAK,CAACoF,OAAO,CAAC4U,UAAU,EAAE,OAAOxU,KAAK,CAACoI,QAAQ,CAACpE,MAAM;IAC/D;IACA;IACA;IACA;IACA;IACA;IACA,MAAMyQ,UAAU,GAAG;MAAEC,EAAE,EAAE;IAAK,CAAC;IAC/B,IAAI,IAAI,CAACla,KAAK,CAACma,OAAO,CAAC,CAAC,IAAIjD,GAAG,CAACrO,IAAI,KAAK,WAAW,EAAE;MAClDoR,UAAU,CAACG,KAAK,GAAG,KAAK;IAC5B;IACA,IAAI,CAAC3Z,KAAK,CAAC+E,KAAK,CAAC4N,IAAI,CAAC8F,QAAQ,EAAE1T,KAAK,EAAEyU,UAAU,CAAC;EACtD,CAAC;EAEDhC,aAAa,EAAE,SAAAA,CAASf,GAAG,EAAE3G,CAAC,EAAEC,CAAC,EAAE;IAC/B,IAAI,IAAI,CAACxQ,KAAK,CAACoF,OAAO,CAACiV,SAAS,EAAE;MAC9B,MAAMC,SAAS,GAAG,IAAI,CAACC,cAAc,CAACrD,GAAG,EAAE3G,CAAC,EAAEC,CAAC,CAAC;MAChD,IAAI,CAAC8J,SAAS,IAAI,IAAI,CAACta,KAAK,CAACoF,OAAO,CAACoV,aAAa,EAAE;QAChD,IAAI,CAACC,kBAAkB,CAACvD,GAAG,EAAE3G,CAAC,EAAEC,CAAC,CAAC;MACtC;IACJ,CAAC,MAAM;MACH,IAAI,IAAI,CAACxQ,KAAK,CAACoF,OAAO,CAACoV,aAAa,EAAE;QAClC,IAAI,CAACC,kBAAkB,CAACvD,GAAG,EAAE3G,CAAC,EAAEC,CAAC,CAAC;MACtC,CAAC,MAAM;QACH,IAAI,CAACkK,iBAAiB,CAAC,IAAI,CAACC,cAAc,CAACzD,GAAG,CAAC,EAAE3G,CAAC,EAAEC,CAAC,EAAE,IAAI,CAACsH,SAAS,CAACZ,GAAG,CAAC,CAAC;MAC/E;IACJ;EACJ,CAAC;EAEDgB,IAAI,EAAE,SAAAA,CAAShB,GAAG,EAAE3G,CAAC,EAAEC,CAAC,EAAE;IAEtB,IAAI4C,IAAI,GAAG,IAAI,CAAC0E,SAAS,CAACZ,GAAG,CAAC;IAC9B,IAAI,CAACzW,KAAK,CAACU,SAAS,CAACoP,CAAC,GAAG6C,IAAI,CAACmG,EAAE,EAAE/I,CAAC,GAAG4C,IAAI,CAACoG,EAAE,EAAE;MAAEU,EAAE,EAAE;IAAK,CAAC,CAAC;IAC5D,IAAI,CAACpC,SAAS,CAACZ,GAAG,EAAE;MAChBqC,EAAE,EAAEhJ,CAAC;MACLiJ,EAAE,EAAEhJ;IACR,CAAC,CAAC;EACN,CAAC;EAED;;EAEA2H,YAAY,EAAE,SAAAA,CAAA,EAAW;IACrB;EAAA,CACH;EAEDC,gBAAgB,EAAE,SAAAA,CAASlB,GAAG,EAAE3G,CAAC,EAAEC,CAAC,EAAE;IAElC,IAAI4C,IAAI,GAAG,IAAI,CAAC0E,SAAS,CAACZ,GAAG,CAAC;IAC9B,IAAIlX,KAAK,GAAG,IAAI,CAACA,KAAK;IAEtB,IAAIA,KAAK,CAACoF,OAAO,CAACiV,SAAS,EAAE;MACzB,IAAI,CAACO,iBAAiB,CAACxH,IAAI,CAAC;IAChC,CAAC,MAAM;MACH,IAAI,CAACyH,oBAAoB,CAACzH,IAAI,EAAE7C,CAAC,EAAEC,CAAC,CAAC;IACzC;IAEA,IAAI,CAACxQ,KAAK,CAAC8a,WAAW,CAAC,IAAI,CAAC,EAAE;MAC1B;MACA,IAAI,CAACC,SAAS,CAAC3H,IAAI,CAAC;IACxB,CAAC,MAAM;MACH,IAAI,CAAC4H,gBAAgB,CAAC5H,IAAI,CAAC;MAC3B,IAAI,CAAC6H,mBAAmB,CAAC7H,IAAI,EAAE8D,GAAG,CAAC;IACvC;IAEA,IAAI,CAACgE,mBAAmB,CAAC9H,IAAI,CAAC;EAClC,CAAC;EAEDiF,OAAO,EAAE,SAAAA,CAAA,EAAW;IAChB;EAAA,CACH;EAED0C,SAAS,EAAE,SAAAA,CAAS3H,IAAI,EAAE;IAEtB,QAAQA,IAAI,CAAC+H,cAAc;MAEvB,KAAK,QAAQ;QACT,IAAI,CAAC1a,KAAK,CAAC0E,MAAM,CAAC;UAAE+U,EAAE,EAAE;QAAK,CAAC,CAAC;QAC/B;MAEJ,KAAK,QAAQ;MACb;QACI,IAAI,CAACzZ,KAAK,CAAC2a,GAAG,CAAChI,IAAI,CAACiI,SAAS,EAAEjI,IAAI,CAACkI,UAAU,EAAE;UAAEpB,EAAE,EAAE;QAAK,CAAC,CAAC;QAC7D;IACR;EACJ,CAAC;EAEDc,gBAAgB,EAAE,SAAAA,CAAS5H,IAAI,EAAE;IAE7B;IACA,IAAI,IAAI,CAACpT,KAAK,CAACoF,OAAO,CAACmW,aAAa,IAAI,IAAI,CAAC9a,KAAK,CAAC+a,QAAQ,CAAC,CAAC,EAAE;MAC3D;MACApI,IAAI,CAACqI,CAAC,GAAG,IAAI;IACjB;EACJ,CAAC;EAEDR,mBAAmB,EAAE,SAAAA,CAAS7H,IAAI,EAAE8D,GAAG,EAAE;IAErC,IAAImE,SAAS,GAAGjI,IAAI,CAACiI,SAAS;IAC9B,IAAIC,UAAU,GAAGlI,IAAI,CAACkI,UAAU;IAChC,IAAII,UAAU,GAAG,IAAI,CAACjb,KAAK,CAACkb,IAAI,CAACN,SAAS,CAAC;IAC3C,IAAIO,UAAU,GAAGF,UAAU,IAAI,CAAC1f,IAAI,CAAC6f,SAAS,CAACP,UAAU,EAAEI,UAAU,CAAC;IACtE,IAAIE,UAAU,EAAE;MACZ,IAAI5b,KAAK,GAAG,IAAI,CAACA,KAAK;MACtB,IAAIsb,UAAU,CAAC/V,EAAE,EAAE;QACf,IAAI,CAAC6R,MAAM,CAAC,iBAAiB,EAAEF,GAAG,EAAElX,KAAK,CAAC8b,eAAe,CAACR,UAAU,CAAC/V,EAAE,CAAC,EAAE6N,IAAI,CAAC2I,aAAa,EAAEV,SAAS,CAAC;MAC5G;MACA,IAAIK,UAAU,CAACnW,EAAE,EAAE;QACf,IAAI,CAAC6R,MAAM,CAAC,cAAc,EAAEF,GAAG,EAAElX,KAAK,CAAC8b,eAAe,CAACJ,UAAU,CAACnW,EAAE,CAAC,EAAE6N,IAAI,CAAC4I,kBAAkB,EAAEX,SAAS,CAAC;MAC9G;IACJ;EACJ,CAAC;EAEDY,aAAa,EAAE,SAAAA,CAASC,SAAS,EAAE5T,MAAM,EAAE6T,MAAM,EAAE;IAC/C,IAAIC,aAAa,GAAG,IAAI;IACxB,IAAIC,gBAAgB,GAAGC,QAAQ;IAE/B,IAAIC,aAAa,GAAG,IAAI;IACxB,IAAIC,gBAAgB,GAAGF,QAAQ;IAE/B,IAAI/L,CAAC,GAAG2L,SAAS,CAAC3L,CAAC;IACnB,IAAIC,CAAC,GAAG0L,SAAS,CAAC1L,CAAC;IAEnB,KAAK,IAAIzO,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGuG,MAAM,CAACrG,MAAM,EAAEF,CAAC,EAAE,EAAE;MACpC,MAAM0a,KAAK,GAAGC,IAAI,CAACC,GAAG,CAACrU,MAAM,CAACvG,CAAC,CAAC,CAACwO,CAAC,GAAG2L,SAAS,CAAC3L,CAAC,CAAC;MACjD,IAAIkM,KAAK,GAAGJ,gBAAgB,EAAE;QAC1BA,gBAAgB,GAAGI,KAAK;QACxBL,aAAa,GAAG9T,MAAM,CAACvG,CAAC,CAAC;MAC7B;MAEA,MAAM6a,KAAK,GAAGF,IAAI,CAACC,GAAG,CAACrU,MAAM,CAACvG,CAAC,CAAC,CAACyO,CAAC,GAAG0L,SAAS,CAAC1L,CAAC,CAAC;MACjD,IAAIoM,KAAK,GAAGJ,gBAAgB,EAAE;QAC1BA,gBAAgB,GAAGI,KAAK;QACxBL,aAAa,GAAGjU,MAAM,CAACvG,CAAC,CAAC;MAC7B;IACJ;IAEA,IAAIsa,gBAAgB,GAAGF,MAAM,EAAE;MAC3B5L,CAAC,GAAG6L,aAAa,CAAC7L,CAAC;IACvB;IACA,IAAIiM,gBAAgB,GAAGL,MAAM,EAAE;MAC3B3L,CAAC,GAAG+L,aAAa,CAAC/L,CAAC;IACvB;IAEA,OAAO;MAAED,CAAC;MAAEC;IAAE,CAAC;EACnB,CAAC;EAEDiK,kBAAkB,EAAE,SAAAA,CAASvD,GAAG,EAAE3G,CAAC,EAAEC,CAAC,EAAE;IAEpC,MAAM;MAAExQ,KAAK;MAAES;IAAM,CAAC,GAAG,IAAI;IAC7B,MAAM;MAAE+Z;IAAc,CAAC,GAAGxa,KAAK,CAACoF,OAAO;IACvC,MAAMgO,IAAI,GAAG,IAAI,CAAC0E,SAAS,CAACZ,GAAG,CAAC;IAChC,MAAMiF,MAAM,GAAG3B,aAAa,CAAC2B,MAAM,IAAI,EAAE;IAEzC,MAAMnR,MAAM,GAAG,IAAI,CAAClC,YAAY,CAACsK,IAAI,CAACiI,SAAS,KAAK,QAAQ,GAAG,QAAQ,GAAG,QAAQ,CAAC;IACnF,MAAMhc,QAAQ,GAAGoB,KAAK,CAACpB,QAAQ,CAAC,CAAC;IACjC,MAAMiJ,MAAM,GAAG,CAAC0C,MAAM,EAAE,GAAG3L,QAAQ,CAAC;IAEpC,MAAM6c,SAAS,GAAG,IAAI,CAACD,aAAa,CAAC;MAAE1L,CAAC,EAAEA,CAAC;MAAEC,CAAC,EAAEA;IAAE,CAAC,EAAElI,MAAM,EAAE6T,MAAM,CAAC;IAEpE,MAAM3T,KAAK,GAAGxI,KAAK,CAAC6c,kBAAkB,CAACX,SAAS,CAAC;IACjD,IAAI,CAACxB,iBAAiB,CAAC7Y,QAAQ,CAACib,gBAAgB,CAACtU,KAAK,CAAC+H,CAAC,EAAE/H,KAAK,CAACgI,CAAC,CAAC,EAAE0L,SAAS,CAAC3L,CAAC,EAAE2L,SAAS,CAAC1L,CAAC,EAAE,IAAI,CAACsH,SAAS,CAACZ,GAAG,CAAC,CAAC;EACtH,CAAC;EAEDqD,cAAc,EAAE,SAAAA,CAASrD,GAAG,EAAE3G,CAAC,EAAEC,CAAC,EAAE;IAEhC,MAAM;MAAExQ;IAAM,CAAC,GAAG,IAAI;IACtB,MAAM;MAAEqa,SAAS;MAAE0C;IAAmB,CAAC,GAAG/c,KAAK,CAACoF,OAAO;IACvD,MAAMgO,IAAI,GAAG,IAAI,CAAC0E,SAAS,CAACZ,GAAG,CAAC;IAChC,IAAIoD,SAAS,GAAG,KAAK;IACrB;;IAEA,IAAI0C,CAAC,GAAG3C,SAAS,CAAC8B,MAAM,IAAI,EAAE;IAC9B,IAAIc,WAAW,GAAGjd,KAAK,CAACkd,eAAe,CAAC;MAAE3M,CAAC,EAAEA,CAAC,GAAGyM,CAAC;MAAExM,CAAC,EAAEA,CAAC,GAAGwM,CAAC;MAAEG,KAAK,EAAE,CAAC,GAAGH,CAAC;MAAEI,MAAM,EAAE,CAAC,GAAGJ;IAAE,CAAC,CAAC;IAE5F,IAAIK,eAAe,GAAGjK,IAAI,CAACkK,WAAW,IAAI,IAAI;IAC9C,IAAIC,iBAAiB,GAAGnK,IAAI,CAACoK,aAAa,IAAI,IAAI;IAClD,IAAIC,eAAe,GAAGrK,IAAI,CAACsK,WAAW,IAAI,IAAI;IAE9CtK,IAAI,CAACkK,WAAW,GAAGlK,IAAI,CAACoK,aAAa,GAAGpK,IAAI,CAACsK,WAAW,GAAG,IAAI;IAE/D,IAAIC,WAAW,GAAGC,MAAM,CAACC,SAAS;IAClC,IAAIC,OAAO,GAAG,IAAInhB,KAAK,CAAC4T,CAAC,EAAEC,CAAC,CAAC;IAE7ByM,WAAW,CAACc,OAAO,CAAC,UAAS3Q,IAAI,EAAE;MAC/B,MAAM4Q,UAAU,GAAG,EAAE;MACrB;MACA,IAAI5Q,IAAI,CAAC5L,EAAE,CAAC4X,YAAY,CAAC,QAAQ,CAAC,KAAK,OAAO,EAAE;QAC5C4E,UAAU,CAAC7f,IAAI,CAAC;UACZ8f,IAAI,EAAE7Q,IAAI,CAAC3M,KAAK,CAACyd,OAAO,CAAC,CAAC;UAC1B5R,MAAM,EAAEc,IAAI,CAAC5L;QACjB,CAAC,CAAC;MACN;MAEA4L,IAAI,CAAC+Q,CAAC,CAAC,UAAU,CAAC,CAACC,OAAO,CAAC,CAAC,CAACL,OAAO,CAACzR,MAAM,IAAI;QAC3C0R,UAAU,CAAC7f,IAAI,CAAC;UACZ8f,IAAI,EAAE7Q,IAAI,CAACiR,WAAW,CAAC/R,MAAM,CAAC;UAC9BA;QACJ,CAAC,CAAC;MACN,CAAC,CAAC;MAEF0R,UAAU,CAACD,OAAO,CAACO,SAAS,IAAI;QAC5B,MAAM;UAAEhS,MAAM;UAAE2R;QAAK,CAAC,GAAGK,SAAS;QAClC;QACA,MAAMtQ,QAAQ,GAAGiQ,IAAI,CAACM,MAAM,CAAC,CAAC,CAACC,eAAe,CAACV,OAAO,CAAC;QACvD;QACA,IAAI9P,QAAQ,GAAG2P,WAAW,EAAE;UACxB,MAAMc,kBAAkB,GAAGlB,iBAAiB,KAAKjR,MAAM;UACvD,IAAImS,kBAAkB,IAAIze,KAAK,CAACoF,OAAO,CAACsZ,kBAAkB,CAACzgB,KAAK,CAC5D+B,KAAK,EAAEoT,IAAI,CAACuL,sBAAsB,CAACvR,IAAI,EAAGA,IAAI,CAAC5L,EAAE,KAAK8K,MAAM,GAAI,IAAI,GAAGA,MAAM,CACjF,CAAC,EAAE;YACCqR,WAAW,GAAG3P,QAAQ;YACtBoF,IAAI,CAACkK,WAAW,GAAGlQ,IAAI;YACvBgG,IAAI,CAACoK,aAAa,GAAGlR,MAAM;UAC/B;QACJ;MACJ,CAAC,CAAC;IAEN,CAAC,EAAE,IAAI,CAAC;IAER,IAAIgB,GAAG;IACP,IAAIoQ,WAAW,GAAG,IAAI;IACtB,IAAIJ,WAAW,GAAGlK,IAAI,CAACkK,WAAW;IAClC,IAAIE,aAAa,GAAGpK,IAAI,CAACoK,aAAa;IACtC,IAAIA,aAAa,EAAE;MACfE,WAAW,GAAGtK,IAAI,CAACsK,WAAW,GAAGJ,WAAW,CAACsB,aAAa,CAACpB,aAAa,EAAE,aAAa,CAAC;IAC5F;IACA,IAAIhR,OAAO,GAAG4G,IAAI,CAACiI,SAAS;IAC5B,IAAIwD,gBAAgB,GAAItB,iBAAiB,KAAKC,aAAc;IAC5D,IAAIH,eAAe,IAAIwB,gBAAgB,EAAE;MACrCxB,eAAe,CAACyB,WAAW,CAACrB,eAAe,EAAE;QACzCsB,UAAU,EAAE,IAAI;QAChBC,QAAQ,EAAE;MACd,CAAC,CAAC;IACN;IAEA,IAAI1B,WAAW,EAAE;MACb,MAAM;QAAE2B,OAAO;QAAEC,KAAK;QAAEC;MAAM,CAAC,GAAG/L,IAAI;MACtCA,IAAI,CAAC8L,KAAK,GAAG3O,CAAC;MACd6C,IAAI,CAAC+L,KAAK,GAAG3O,CAAC;MACd8J,SAAS,GAAG,IAAI;MAEhB,IAAI,CAACuE,gBAAgB,EAAG;QACpB,IAAI,OAAO9B,kBAAkB,KAAK,UAAU,IAAKmC,KAAK,KAAK3O,CAAC,IAAI4O,KAAK,KAAK3O,CAAE,EAAE;UAC1E;UACA,OAAO8J,SAAS;QACpB;MACJ;MAEAhN,GAAG,GAAGgQ,WAAW,CAAC8B,UAAU,CAAC5B,aAAa,EAAEjN,CAAC,EAAEC,CAAC,EAAE,IAAI,CAAC/P,KAAK,EAAE+L,OAAO,CAAC;MACtE,IAAI,CAACqS,gBAAgB,IAAIniB,OAAO,CAACuiB,OAAO,EAAE3R,GAAG,CAAC,EAAE;QAC5C;QACA,OAAOgN,SAAS;MACpB;MAEAlH,IAAI,CAAC6L,OAAO,GAAG3R,GAAG;MAElB,IAAIuR,gBAAgB,EAAE;QAClBvB,WAAW,CAAC+B,SAAS,CAAC3B,WAAW,EAAE;UAC/BqB,UAAU,EAAE,IAAI;UAChBC,QAAQ,EAAE;QACd,CAAC,CAAC;MACN;IAEJ,CAAC,MAAM;MAEH1R,GAAG,GAAG;QAAEiD,CAAC,EAAEA,CAAC;QAAEC,CAAC,EAAEA;MAAE,CAAC;IACxB;IAEA,IAAI,CAAC/P,KAAK,CAAC2a,GAAG,CAAC5O,OAAO,EAAEc,GAAG,IAAI;MAAEiD,CAAC,EAAEA,CAAC;MAAEC,CAAC,EAAEA;IAAE,CAAC,EAAE;MAAE0J,EAAE,EAAE;IAAK,CAAC,CAAC;IAE5D,IAAImD,eAAe,EAAE;MACjB,IAAI,CAACjG,MAAM,CAAC,sBAAsB,EAAEF,GAAG,EAAEmG,eAAe,EAAEE,iBAAiB,EAAE/Q,OAAO,CAAC;IACzF;IACA,IAAI8Q,WAAW,EAAE;MACb,IAAI,CAAClG,MAAM,CAAC,mBAAmB,EAAEF,GAAG,EAAEoG,WAAW,EAAEE,aAAa,EAAEhR,OAAO,CAAC;IAC9E;IAEA,OAAO8N,SAAS;EACpB,CAAC;EAEDM,iBAAiB,EAAE,SAAAA,CAASxH,IAAI,EAAE;IAE9B;IACA;IACA,IAAIkK,WAAW,GAAGlK,IAAI,CAACkK,WAAW;IAClC,IAAIE,aAAa,GAAGpK,IAAI,CAACoK,aAAa;IACtC,IAAIF,WAAW,IAAIE,aAAa,EAAE;MAE9BF,WAAW,CAACwB,WAAW,CAAC1L,IAAI,CAACsK,WAAW,EAAE;QAAEqB,UAAU,EAAE,IAAI;QAAEC,QAAQ,EAAE;MAAK,CAAC,CAAC;MAC/E5L,IAAI,CAAC4I,kBAAkB,GAAGsB,WAAW,CAACgC,UAAU,CAAC9B,aAAa,CAAC;IACnE;IAEApK,IAAI,CAACkK,WAAW,GAAGlK,IAAI,CAACoK,aAAa,GAAG,IAAI;EAChD,CAAC;EAED9C,iBAAiB,EAAE,SAAAA,CAASnb,MAAM,EAAEgR,CAAC,EAAEC,CAAC,EAAE4C,IAAI,EAAE;IAE5C;IACA,MAAM;MAAEpT,KAAK;MAAES;IAAM,CAAC,GAAG,IAAI;IAE7B,IAAI2S,IAAI,CAACmM,WAAW,KAAKhgB,MAAM,EAAE;MAC7B;MACA,IAAI6T,IAAI,CAACsK,WAAW,EAAE;QAClBtK,IAAI,CAACoM,gBAAgB,CAACV,WAAW,CAAC1L,IAAI,CAACsK,WAAW,EAAE;UAChDqB,UAAU,EAAE;QAChB,CAAC,CAAC;MACN;MAEA,MAAMS,gBAAgB,GAAGpM,IAAI,CAACoM,gBAAgB,GAAGxf,KAAK,CAACmP,QAAQ,CAAC5P,MAAM,CAAC;MACvE,IAAIigB,gBAAgB,EAAE;QAClB;QACA;QACA,MAAMxD,kBAAkB,GAAG5I,IAAI,CAAC4I,kBAAkB,GAAGwD,gBAAgB,CAACF,UAAU,CAAC/f,MAAM,CAAC;QACxF,MAAMme,WAAW,GAAGtK,IAAI,CAACsK,WAAW,GAAG8B,gBAAgB,CAACZ,aAAa,CAAC5C,kBAAkB,EAAE,aAAa,CAAC;QAExG,IAAIA,kBAAkB,IAAI,IAAI,CAAChc,KAAK,CAACoF,OAAO,CAACsZ,kBAAkB,CAACzgB,KAAK,CACjE+B,KAAK,EACLoT,IAAI,CAACuL,sBAAsB,CAACa,gBAAgB,EAAExD,kBAAkB,CACpE,CAAC,EAAE;UACC;UACA;UACA;UACA,IAAI0B,WAAW,EAAE;YACb8B,gBAAgB,CAACH,SAAS,CAAC3B,WAAW,EAAE;cACpCqB,UAAU,EAAE;YAChB,CAAC,CAAC;UACN;QACJ,CAAC,MAAM;UACH;UACA3L,IAAI,CAAC4I,kBAAkB,GAAG,IAAI;UAC9B5I,IAAI,CAACsK,WAAW,GAAG,IAAI;QAC3B;MACJ,CAAC,MAAM;QACH;QACAtK,IAAI,CAAC4I,kBAAkB,GAAG,IAAI;QAC9B5I,IAAI,CAACsK,WAAW,GAAG,IAAI;MAC3B;IACJ;IAEAtK,IAAI,CAACmM,WAAW,GAAGhgB,MAAM;IAEzBkB,KAAK,CAAC2a,GAAG,CAAChI,IAAI,CAACiI,SAAS,EAAE;MAAE9K,CAAC,EAAEA,CAAC;MAAEC,CAAC,EAAEA;IAAE,CAAC,EAAE;MAAE0J,EAAE,EAAE;IAAK,CAAC,CAAC;EAC3D,CAAC;EAEDW,oBAAoB,EAAE,SAAAA,CAASzH,IAAI,GAAG,CAAC,CAAC,EAAE7C,CAAC,EAAEC,CAAC,EAAE;IAE5C,MAAM;MAAE/P;IAAM,CAAC,GAAG,IAAI;IACtB,MAAM;MAAE+e,gBAAgB;MAAExD,kBAAkB;MAAE0B,WAAW;MAAErC;IAAU,CAAC,GAAGjI,IAAI;IAE7E,IAAI,CAAC4I,kBAAkB,IAAI,CAAC0B,WAAW,IAAI,CAAC8B,gBAAgB,EAAE;IAE9DA,gBAAgB,CAACV,WAAW,CAACpB,WAAW,EAAE;MAAEqB,UAAU,EAAE;IAAK,CAAC,CAAC;;IAE/D;IACA,MAAMzR,GAAG,GAAGkS,gBAAgB,CAACJ,UAAU,CAACpD,kBAAkB,EAAEzL,CAAC,EAAEC,CAAC,EAAE/P,KAAK,EAAE4a,SAAS,CAAC;IACnF5a,KAAK,CAAC2a,GAAG,CAACC,SAAS,EAAE/N,GAAG,EAAE;MAAE4M,EAAE,EAAE;IAAK,CAAC,CAAC;EAC3C,CAAC;EAEDuF,oBAAoB,EAAE,SAAAA,CAASrM,IAAI,EAAE;IAEjCA,IAAI,CAACqI,CAAC,GAAG,IAAI,CAAChb,KAAK,CAAC+C,GAAG,CAAC,GAAG,CAAC;IAC5B,IAAI,CAAC/C,KAAK,CAACif,OAAO,CAAC,CAAC;;IAEpB;IACA;IACA,IAAIC,KAAK,GAAG,IAAI,CAACne,EAAE,CAACme,KAAK;IACzBvM,IAAI,CAACwM,aAAa,GAAGD,KAAK,CAACC,aAAa;IACxCD,KAAK,CAACC,aAAa,GAAG,MAAM;IAE5B,IAAI,IAAI,CAAC5f,KAAK,CAACoF,OAAO,CAACya,aAAa,EAAE;MAClC,IAAI,CAACC,qBAAqB,CAAC1M,IAAI,CAAC;IACpC;EACJ,CAAC;EAED8H,mBAAmB,EAAE,SAAAA,CAAS9H,IAAI,EAAE;IAEhC,IAAIA,IAAI,CAACqI,CAAC,KAAK,IAAI,EAAE;MACjB,IAAI,CAAChb,KAAK,CAAC2a,GAAG,CAAC,GAAG,EAAEhI,IAAI,CAACqI,CAAC,EAAE;QAAEvB,EAAE,EAAE;MAAK,CAAC,CAAC;MACzC9G,IAAI,CAACqI,CAAC,GAAG,IAAI;IACjB;;IAEA;IACA,IAAI,CAACja,EAAE,CAACme,KAAK,CAACC,aAAa,GAAGxM,IAAI,CAACwM,aAAa;IAEhD,IAAI,IAAI,CAAC5f,KAAK,CAACoF,OAAO,CAACya,aAAa,EAAE;MAClC,IAAI,CAACE,uBAAuB,CAAC3M,IAAI,CAAC;IACtC;EACJ,CAAC;EAED4M,6BAA6B,EAAE,SAAAA,CAAS3E,SAAS,EAAE;IAC/C;IACA;IACA,IAAIpO,IAAI,GAAG,EAAE;IAEbA,IAAI,CAAC,CAAC,CAAC,GAAGoO,SAAS;IACnBpO,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI;IAEd,IAAIgT,iBAAiB;IACrB,IAAIle,CAAC,GAAG,CAAC;IACT,IAAIme,CAAC,GAAG,CAAC;IAET,IAAI7E,SAAS,KAAK,QAAQ,EAAE;MACxBtZ,CAAC,GAAG,CAAC;MACLke,iBAAiB,GAAG,QAAQ;IAChC,CAAC,MAAM;MACHC,CAAC,GAAG,CAAC;MACLD,iBAAiB,GAAG,QAAQ;IAChC;IAEA,IAAI3S,GAAG,GAAG,IAAI,CAAC7M,KAAK,CAAC+C,GAAG,CAACyc,iBAAiB,CAAC;IAE3C,IAAI3S,GAAG,CAAC/H,EAAE,EAAE;MACR,IAAI6H,IAAI,GAAGH,IAAI,CAAClL,CAAC,CAAC,GAAG,IAAI,CAAC/B,KAAK,CAAC8b,eAAe,CAACxO,GAAG,CAAC/H,EAAE,CAAC;MACvD,IAAI+G,MAAM,GAAGc,IAAI,CAACkC,oBAAoB,CAAChC,GAAG,CAAC;MAC3C,IAAIhB,MAAM,KAAKc,IAAI,CAAC5L,EAAE,EAAE8K,MAAM,GAAGnI,SAAS;MAC1C8I,IAAI,CAAClL,CAAC,GAAG,CAAC,CAAC,GAAGuK,MAAM;IACxB;IAEA,SAASqS,sBAAsBA,CAACtS,QAAQ,EAAEC,MAAM,EAAE;MAC9CW,IAAI,CAACiT,CAAC,CAAC,GAAG7T,QAAQ;MAClBY,IAAI,CAACiT,CAAC,GAAG,CAAC,CAAC,GAAG7T,QAAQ,CAAC7K,EAAE,KAAK8K,MAAM,GAAGnI,SAAS,GAAGmI,MAAM;MACzD,OAAOW,IAAI;IACf;IAEA,OAAO0R,sBAAsB;EACjC,CAAC;EAEDmB,qBAAqB,EAAE,SAAAA,CAAS1M,IAAI,EAAE;IAElC,SAAS+M,iBAAiBA,CAAC/S,IAAI,EAAEd,MAAM,EAAE;MACrC,IAAItM,KAAK,GAAGoN,IAAI,CAACpN,KAAK;MACtB,IAAIogB,QAAQ,GAAGpgB,KAAK,CAACoF,OAAO,CAACsZ,kBAAkB;MAC/C,OAAO0B,QAAQ,CAACniB,KAAK,CAAC+B,KAAK,EAAE,IAAI,CAAC2e,sBAAsB,CAACvR,IAAI,EAAEd,MAAM,CAAC,CAAC;IAC3E;IAEA,IAAItM,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAIqgB,QAAQ,GAAGrgB,KAAK,CAACS,KAAK,CAAC6f,QAAQ,CAAC,CAAC;IACrClN,IAAI,CAACmN,MAAM,GAAG,CAAC,CAAC;IAEhB,KAAK,IAAIxe,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGqe,QAAQ,CAACpe,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;MAC7C,IAAIqL,IAAI,GAAGiT,QAAQ,CAACte,CAAC,CAAC,CAACoN,QAAQ,CAACnP,KAAK,CAAC;MAEtC,IAAI,CAACoN,IAAI,EAAE;QACP;MACJ;MAEA,IAAIoT,OAAO,GAAG9e,KAAK,CAAC1D,SAAS,CAAC2K,KAAK,CAACqE,IAAI,CAACI,IAAI,CAAC5L,EAAE,CAACif,gBAAgB,CAAC,UAAU,CAAC,CAAC;MAC9E,IAAIrT,IAAI,CAAC5L,EAAE,CAAC4X,YAAY,CAAC,QAAQ,CAAC,KAAK,OAAO,EAAE;QAC5C;QACAoH,OAAO,CAACriB,IAAI,CAACiP,IAAI,CAAC5L,EAAE,CAAC;MACzB;MAEA,IAAIkf,gBAAgB,GAAGF,OAAO,CAACG,MAAM,CAACR,iBAAiB,CAACS,IAAI,CAACxN,IAAI,EAAEhG,IAAI,CAAC,CAAC;MAEzE,IAAIsT,gBAAgB,CAACze,MAAM,GAAG,CAAC,EAAE;QAC7B;QACA,KAAK,IAAIie,CAAC,GAAG,CAAC,EAAEW,CAAC,GAAGH,gBAAgB,CAACze,MAAM,EAAEie,CAAC,GAAGW,CAAC,EAAEX,CAAC,EAAE,EAAE;UACrD9S,IAAI,CAACiS,SAAS,CAACqB,gBAAgB,CAACR,CAAC,CAAC,EAAE;YAAEY,kBAAkB,EAAE;UAAK,CAAC,CAAC;QACrE;QACA;QACA1T,IAAI,CAACiS,SAAS,CAAC,IAAI,EAAE;UAAE0B,mBAAmB,EAAE;QAAK,CAAC,CAAC;QAEnD3N,IAAI,CAACmN,MAAM,CAACnT,IAAI,CAAC3M,KAAK,CAAC8E,EAAE,CAAC,GAAGmb,gBAAgB;MACjD;IACJ;EACJ,CAAC;EAEDX,uBAAuB,EAAE,SAAAA,CAAS3M,IAAI,EAAE;IAEpC,IAAI4N,UAAU,GAAGle,MAAM,CAACme,IAAI,CAAC7N,IAAI,CAACmN,MAAM,CAAC;IACzC,IAAIhb,EAAE;IACN,IAAI2b,aAAa;IAEjB,KAAK,IAAInf,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGgf,UAAU,CAAC/e,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;MAC/CwD,EAAE,GAAGyb,UAAU,CAACjf,CAAC,CAAC;MAClBmf,aAAa,GAAG9N,IAAI,CAACmN,MAAM,CAAChb,EAAE,CAAC;MAE/B,IAAI6H,IAAI,GAAG,IAAI,CAACpN,KAAK,CAAC8b,eAAe,CAACvW,EAAE,CAAC;MACzC,IAAI6H,IAAI,EAAE;QACN,KAAK,IAAI8S,CAAC,GAAG,CAAC,EAAEW,CAAC,GAAGK,aAAa,CAACjf,MAAM,EAAEie,CAAC,GAAGW,CAAC,EAAEX,CAAC,EAAE,EAAE;UAClD9S,IAAI,CAAC0R,WAAW,CAACoC,aAAa,CAAChB,CAAC,CAAC,EAAE;YAAEY,kBAAkB,EAAE;UAAK,CAAC,CAAC;QACpE;QACA1T,IAAI,CAAC0R,WAAW,CAAC,IAAI,EAAE;UAAEiC,mBAAmB,EAAE;QAAK,CAAC,CAAC;MACzD;IACJ;IAEA3N,IAAI,CAACmN,MAAM,GAAG,IAAI;EACtB,CAAC;EAEDzG,kBAAkB,EAAE,SAAAA,CAASxM,GAAG,EAAE1N,GAAG,EAAE;IAEnCA,GAAG,KAAKA,GAAG,GAAG,CAAC,CAAC,CAAC;;IAEjB;IACA;IACA,IAAIwT,IAAI,GAAG;MACP2E,MAAM,EAAE,gBAAgB;MACxBsD,SAAS,EAAE/N,GAAG;MACd6N,cAAc,EAAEvb,GAAG,CAACub,cAAc,IAAI,QAAQ;MAC9CY,aAAa,EAAE,IAAI,CAACzO,GAAG,GAAG,QAAQ,CAAC,KAAK,IAAI,CAACA,GAAG,GAAG,MAAM,CAAC,GAAG,IAAI,CAACA,GAAG,GAAG,MAAM,CAAC,CAAC9L,EAAE,GAAG,IAAI,CAAC;MAC1F8Z,UAAU,EAAE/e,KAAK,CAAC,IAAI,CAACkE,KAAK,CAAC+C,GAAG,CAAC8J,GAAG,CAAC,CAAC;MACtCqR,sBAAsB,EAAE,IAAI,CAACqB,6BAA6B,CAAC1S,GAAG;IAClE,CAAC;IAED,IAAI,CAACmS,oBAAoB,CAACrM,IAAI,CAAC;IAE/B,IAAIxT,GAAG,CAACma,4BAA4B,KAAK,IAAI,EAAE;MAC3C,IAAI,CAACvb,SAAS,GAAG4U,IAAI;IACzB;IAEA,OAAOA,IAAI;EACf,CAAC;EAED;;EAEA+N,OAAO,EAAE,SAAAA,CAAA,EAAW;IAChBplB,QAAQ,CAACiC,SAAS,CAACmjB,OAAO,CAACljB,KAAK,CAAC,IAAI,EAAEW,SAAS,CAAC;IACjD,IAAI,CAACyH,WAAW,CAAC,CAAC;EACtB,CAAC;EAED+a,QAAQ,EAAE,SAAAA,CAAA,EAAW;IACjBrlB,QAAQ,CAACiC,SAAS,CAACojB,QAAQ,CAACnjB,KAAK,CAAC,IAAI,EAAEW,SAAS,CAAC;IAClD,IAAI,CAACyE,aAAa,CAAC,CAAC;EACxB,CAAC;EAEDge,QAAQ,EAAE,SAAAA,CAAA,EAAW;IACjBtlB,QAAQ,CAACiC,SAAS,CAACqjB,QAAQ,CAACpjB,KAAK,CAAC,IAAI,EAAEW,SAAS,CAAC;IAClD,IAAI,CAACyE,aAAa,CAAC,CAAC;EACxB;AAEJ,CAAC,EAAE;EAECjG,KAAK,EAAEA;AACX,CAAC,CAAC;AAEF0F,MAAM,CAACwe,cAAc,CAAC1jB,QAAQ,CAACI,SAAS,EAAE,YAAY,EAAE;EAEpDujB,UAAU,EAAE,IAAI;EAEhB/d,GAAG,EAAE,SAAAA,CAAA,EAAW;IACZ,IAAIvD,UAAU,GAAG,IAAI,CAACA,UAAU;IAChC,IAAI,CAACA,UAAU,EAAE;MACb,IAAIsL,SAAS,GAAG,IAAI,CAAC9K,KAAK,CAACnB,MAAM,CAAC,CAAC;MACnC,OAAO,IAAIvC,IAAI,CAACwO,SAAS,CAACgF,CAAC,EAAEhF,SAAS,CAACiF,CAAC,CAAC;IAC7C;IACA,IAAIrH,YAAY,GAAG,IAAI,CAACA,YAAY;IACpC,IAAIlJ,UAAU,CAACyL,gBAAgB,CAACvC,YAAY,CAAC,EAAE;MAC3C,OAAO,IAAIpM,IAAI,CAAC,IAAI,CAACgL,YAAY,CAAC;IACtC;IACA,OAAO9H,UAAU,CAACoe,WAAW,CAAClV,YAAY,IAAIlJ,UAAU,CAACuB,EAAE,CAAC;EAChE;AAEJ,CAAC,CAAC;AAEFsB,MAAM,CAACwe,cAAc,CAAC1jB,QAAQ,CAACI,SAAS,EAAE,YAAY,EAAE;EAEpDujB,UAAU,EAAE,IAAI;EAEhB/d,GAAG,EAAE,SAAAA,CAAA,EAAW;IACZ,IAAItD,UAAU,GAAG,IAAI,CAACA,UAAU;IAChC,IAAI,CAACA,UAAU,EAAE;MACb,IAAIsL,SAAS,GAAG,IAAI,CAAC/K,KAAK,CAAClB,MAAM,CAAC,CAAC;MACnC,OAAO,IAAIxC,IAAI,CAACyO,SAAS,CAAC+E,CAAC,EAAE/E,SAAS,CAACgF,CAAC,CAAC;IAC7C;IACA,IAAIpH,YAAY,GAAG,IAAI,CAACA,YAAY;IACpC,IAAIlJ,UAAU,CAACwL,gBAAgB,CAACtC,YAAY,CAAC,EAAE;MAC3C,OAAO,IAAIrM,IAAI,CAAC,IAAI,CAACiL,YAAY,CAAC;IACtC;IACA,OAAO9H,UAAU,CAACme,WAAW,CAACjV,YAAY,IAAIlJ,UAAU,CAACsB,EAAE,CAAC;EAChE;AACJ,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}