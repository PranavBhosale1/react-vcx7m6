{"ast":null,"code":"import { assign, isPlainObject, isObject, isPercentage, breakText } from '../../util/util.mjs';\nimport { isCalcAttribute, evalCalcAttribute } from './calc.mjs';\nimport $ from '../../mvc/Dom/index.mjs';\nimport V from '../../V/index.mjs';\nfunction isTextInUse(_value, _node, attrs) {\n  return attrs.text !== undefined;\n}\nconst FONT_ATTRIBUTES = ['font-weight', 'font-family', 'font-size', 'letter-spacing', 'text-transform'];\nconst textAttributesNS = {\n  'line-height': {\n    qualify: isTextInUse\n  },\n  'text-vertical-anchor': {\n    qualify: isTextInUse\n  },\n  'text-path': {\n    qualify: isTextInUse\n  },\n  'annotations': {\n    qualify: isTextInUse\n  },\n  'eol': {\n    qualify: isTextInUse\n  },\n  'display-empty': {\n    qualify: isTextInUse\n  },\n  'text': {\n    qualify: function (_text, _node, attrs) {\n      const textWrap = attrs['text-wrap'];\n      return !textWrap || !isPlainObject(textWrap);\n    },\n    set: function (text, refBBox, node, attrs) {\n      const cacheName = 'joint-text';\n      const cache = $.data.get(node, cacheName);\n      const lineHeight = attrs['line-height'];\n      const textVerticalAnchor = attrs['text-vertical-anchor'];\n      const displayEmpty = attrs['display-empty'];\n      const fontSize = attrs['font-size'];\n      const annotations = attrs.annotations;\n      const eol = attrs.eol;\n      const x = attrs.x;\n      let textPath = attrs['text-path'];\n      // Update the text only if there was a change in the string\n      // or any of its attributes.\n      const textHash = JSON.stringify([text, lineHeight, annotations, textVerticalAnchor, eol, displayEmpty, textPath, x, fontSize]);\n      if (cache === undefined || cache !== textHash) {\n        // Chrome bug:\n        // <tspan> positions defined as `em` are not updated\n        // when container `font-size` change.\n        if (fontSize) node.setAttribute('font-size', fontSize);\n        // Text Along Path Selector\n        if (isObject(textPath)) {\n          const pathSelector = textPath.selector;\n          if (typeof pathSelector === 'string') {\n            const pathNode = this.findNode(pathSelector);\n            if (pathNode instanceof SVGPathElement) {\n              textPath = assign({\n                'xlink:href': '#' + pathNode.id\n              }, textPath);\n            }\n          }\n        }\n        V(node).text('' + text, {\n          lineHeight,\n          annotations,\n          textPath,\n          x,\n          textVerticalAnchor,\n          eol,\n          displayEmpty\n        });\n        $.data.set(node, cacheName, textHash);\n      }\n    }\n  },\n  'text-wrap': {\n    qualify: isPlainObject,\n    set: function (value, refBBox, node, attrs) {\n      var size = {};\n      // option `width`\n      var width = value.width || 0;\n      if (isPercentage(width)) {\n        size.width = refBBox.width * parseFloat(width) / 100;\n      } else if (isCalcAttribute(width)) {\n        size.width = Number(evalCalcAttribute(width, refBBox));\n      } else {\n        if (value.width === null) {\n          // breakText() requires width to be specified.\n          size.width = Infinity;\n        } else if (width <= 0) {\n          size.width = refBBox.width + width;\n        } else {\n          size.width = width;\n        }\n      }\n      // option `height`\n      var height = value.height || 0;\n      if (isPercentage(height)) {\n        size.height = refBBox.height * parseFloat(height) / 100;\n      } else if (isCalcAttribute(height)) {\n        size.height = Number(evalCalcAttribute(height, refBBox));\n      } else {\n        if (value.height === null) {\n          // if height is not specified breakText() does not\n          // restrict the height of the text.\n        } else if (height <= 0) {\n          size.height = refBBox.height + height;\n        } else {\n          size.height = height;\n        }\n      }\n      // option `text`\n      var wrappedText;\n      var text = value.text;\n      if (text === undefined) text = attrs.text;\n      if (text !== undefined) {\n        const breakTextFn = value.breakText || breakText;\n        const computedStyles = getComputedStyle(node);\n        const wrapFontAttributes = {};\n        // The font size attributes must be set on the node\n        // to get the correct text wrapping.\n        // TODO: set the native SVG attributes before special attributes\n        for (let i = 0; i < FONT_ATTRIBUTES.length; i++) {\n          const name = FONT_ATTRIBUTES[i];\n          if (name in attrs) {\n            node.setAttribute(name, attrs[name]);\n          }\n          // Note: computedStyles is a live object\n          // i.e. the properties are evaluated when accessed.\n          wrapFontAttributes[name] = computedStyles[name];\n        }\n\n        // The `line-height` attribute in SVG is JoinJS specific.\n        // TODO: change the `lineHeight` to breakText option.\n        wrapFontAttributes.lineHeight = attrs['line-height'];\n        wrappedText = breakTextFn('' + text, size, wrapFontAttributes, {\n          // Provide an existing SVG Document here\n          // instead of creating a temporary one over again.\n          svgDocument: this.paper.svg,\n          ellipsis: value.ellipsis,\n          hyphen: value.hyphen,\n          separator: value.separator,\n          maxLineCount: value.maxLineCount,\n          preserveSpaces: value.preserveSpaces\n        });\n      } else {\n        wrappedText = '';\n      }\n      textAttributesNS.text.set.call(this, wrappedText, refBBox, node, attrs);\n    },\n    // We expose the font attributes list to allow\n    // the user to take other custom font attributes into account\n    // when wrapping the text.\n    FONT_ATTRIBUTES\n  },\n  'title': {\n    qualify: function (title, node) {\n      // HTMLElement title is specified via an attribute (i.e. not an element)\n      return node instanceof SVGElement;\n    },\n    set: function (title, refBBox, node) {\n      var cacheName = 'joint-title';\n      var cache = $.data.get(node, cacheName);\n      if (cache === undefined || cache !== title) {\n        $.data.set(node, cacheName, title);\n        if (node.tagName === 'title') {\n          // The target node is a <title> element.\n          node.textContent = title;\n          return;\n        }\n        // Generally <title> element should be the first child element of its parent.\n        var firstChild = node.firstElementChild;\n        if (firstChild && firstChild.tagName === 'title') {\n          // Update an existing title\n          firstChild.textContent = title;\n        } else {\n          // Create a new title\n          var titleNode = document.createElementNS(node.namespaceURI, 'title');\n          titleNode.textContent = title;\n          node.insertBefore(titleNode, firstChild);\n        }\n      }\n    }\n  }\n};\nexport default textAttributesNS;","map":{"version":3,"names":["assign","isPlainObject","isObject","isPercentage","breakText","isCalcAttribute","evalCalcAttribute","$","V","isTextInUse","_value","_node","attrs","text","undefined","FONT_ATTRIBUTES","textAttributesNS","qualify","_text","textWrap","set","refBBox","node","cacheName","cache","data","get","lineHeight","textVerticalAnchor","displayEmpty","fontSize","annotations","eol","x","textPath","textHash","JSON","stringify","setAttribute","pathSelector","selector","pathNode","findNode","SVGPathElement","id","value","size","width","parseFloat","Number","Infinity","height","wrappedText","breakTextFn","computedStyles","getComputedStyle","wrapFontAttributes","i","length","name","svgDocument","paper","svg","ellipsis","hyphen","separator","maxLineCount","preserveSpaces","call","title","SVGElement","tagName","textContent","firstChild","firstElementChild","titleNode","document","createElementNS","namespaceURI","insertBefore"],"sources":["D:/react-vcx7m6/node_modules/@joint/core/src/dia/attributes/text.mjs"],"sourcesContent":["import { assign, isPlainObject, isObject, isPercentage, breakText } from '../../util/util.mjs';\nimport { isCalcAttribute, evalCalcAttribute } from './calc.mjs';\nimport $ from '../../mvc/Dom/index.mjs';\nimport V from '../../V/index.mjs';\n\nfunction isTextInUse(_value, _node, attrs) {\n    return (attrs.text !== undefined);\n}\n\nconst FONT_ATTRIBUTES = ['font-weight', 'font-family', 'font-size', 'letter-spacing', 'text-transform'];\n\nconst textAttributesNS = {\n\n    'line-height': {\n        qualify: isTextInUse\n    },\n\n    'text-vertical-anchor': {\n        qualify: isTextInUse\n    },\n\n    'text-path': {\n        qualify: isTextInUse\n    },\n\n    'annotations': {\n        qualify: isTextInUse\n    },\n\n    'eol': {\n        qualify: isTextInUse\n    },\n\n    'display-empty': {\n        qualify: isTextInUse\n    },\n\n    'text': {\n        qualify: function(_text, _node, attrs) {\n            const textWrap = attrs['text-wrap'];\n            return !textWrap || !isPlainObject(textWrap);\n        },\n        set: function(text, refBBox, node, attrs) {\n            const cacheName = 'joint-text';\n            const cache = $.data.get(node, cacheName);\n            const lineHeight = attrs['line-height'];\n            const textVerticalAnchor = attrs['text-vertical-anchor'];\n            const displayEmpty = attrs['display-empty'];\n            const fontSize = attrs['font-size'];\n            const annotations = attrs.annotations;\n            const eol = attrs.eol;\n            const x = attrs.x;\n            let textPath = attrs['text-path'];\n            // Update the text only if there was a change in the string\n            // or any of its attributes.\n            const textHash = JSON.stringify([text, lineHeight, annotations, textVerticalAnchor, eol, displayEmpty, textPath, x, fontSize]);\n            if (cache === undefined || cache !== textHash) {\n                // Chrome bug:\n                // <tspan> positions defined as `em` are not updated\n                // when container `font-size` change.\n                if (fontSize) node.setAttribute('font-size', fontSize);\n                // Text Along Path Selector\n                if (isObject(textPath)) {\n                    const pathSelector = textPath.selector;\n                    if (typeof pathSelector === 'string') {\n                        const pathNode = this.findNode(pathSelector);\n                        if (pathNode instanceof SVGPathElement) {\n                            textPath = assign({ 'xlink:href': '#' + pathNode.id }, textPath);\n                        }\n                    }\n                }\n                V(node).text('' + text, {\n                    lineHeight,\n                    annotations,\n                    textPath,\n                    x,\n                    textVerticalAnchor,\n                    eol,\n                    displayEmpty\n                });\n                $.data.set(node, cacheName, textHash);\n            }\n        }\n    },\n\n    'text-wrap': {\n        qualify: isPlainObject,\n        set: function(value, refBBox, node, attrs) {\n            var size = {};\n            // option `width`\n            var width = value.width || 0;\n            if (isPercentage(width)) {\n                size.width = refBBox.width * parseFloat(width) / 100;\n            } else if (isCalcAttribute(width)) {\n                size.width = Number(evalCalcAttribute(width, refBBox));\n            } else {\n                if (value.width === null) {\n                    // breakText() requires width to be specified.\n                    size.width = Infinity;\n                } else if (width <= 0) {\n                    size.width = refBBox.width + width;\n                } else {\n                    size.width = width;\n                }\n            }\n            // option `height`\n            var height = value.height || 0;\n            if (isPercentage(height)) {\n                size.height = refBBox.height * parseFloat(height) / 100;\n            } else if (isCalcAttribute(height)) {\n                size.height = Number(evalCalcAttribute(height, refBBox));\n            } else {\n                if (value.height === null) {\n                    // if height is not specified breakText() does not\n                    // restrict the height of the text.\n                } else if (height <= 0) {\n                    size.height = refBBox.height + height;\n                } else {\n                    size.height = height;\n                }\n            }\n            // option `text`\n            var wrappedText;\n            var text = value.text;\n            if (text === undefined) text = attrs.text;\n            if (text !== undefined) {\n\n                const breakTextFn = value.breakText || breakText;\n                const computedStyles = getComputedStyle(node);\n                const wrapFontAttributes = {};\n                // The font size attributes must be set on the node\n                // to get the correct text wrapping.\n                // TODO: set the native SVG attributes before special attributes\n                for (let i = 0; i < FONT_ATTRIBUTES.length; i++) {\n                    const name = FONT_ATTRIBUTES[i];\n                    if (name in attrs) {\n                        node.setAttribute(name, attrs[name]);\n                    }\n                    // Note: computedStyles is a live object\n                    // i.e. the properties are evaluated when accessed.\n                    wrapFontAttributes[name] = computedStyles[name];\n                }\n\n                // The `line-height` attribute in SVG is JoinJS specific.\n                // TODO: change the `lineHeight` to breakText option.\n                wrapFontAttributes.lineHeight = attrs['line-height'];\n\n                wrappedText = breakTextFn('' + text, size, wrapFontAttributes, {\n                    // Provide an existing SVG Document here\n                    // instead of creating a temporary one over again.\n                    svgDocument: this.paper.svg,\n                    ellipsis: value.ellipsis,\n                    hyphen: value.hyphen,\n                    separator: value.separator,\n                    maxLineCount: value.maxLineCount,\n                    preserveSpaces: value.preserveSpaces\n                });\n            } else {\n                wrappedText = '';\n            }\n            textAttributesNS.text.set.call(this, wrappedText, refBBox, node, attrs);\n        },\n        // We expose the font attributes list to allow\n        // the user to take other custom font attributes into account\n        // when wrapping the text.\n        FONT_ATTRIBUTES\n    },\n\n    'title': {\n        qualify: function(title, node) {\n            // HTMLElement title is specified via an attribute (i.e. not an element)\n            return node instanceof SVGElement;\n        },\n        set: function(title, refBBox, node) {\n            var cacheName = 'joint-title';\n            var cache = $.data.get(node, cacheName);\n            if (cache === undefined || cache !== title) {\n                $.data.set(node, cacheName, title);\n                if (node.tagName === 'title') {\n                    // The target node is a <title> element.\n                    node.textContent = title;\n                    return;\n                }\n                // Generally <title> element should be the first child element of its parent.\n                var firstChild = node.firstElementChild;\n                if (firstChild && firstChild.tagName === 'title') {\n                    // Update an existing title\n                    firstChild.textContent = title;\n                } else {\n                    // Create a new title\n                    var titleNode = document.createElementNS(node.namespaceURI, 'title');\n                    titleNode.textContent = title;\n                    node.insertBefore(titleNode, firstChild);\n                }\n            }\n        }\n    },\n};\n\nexport default textAttributesNS;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}