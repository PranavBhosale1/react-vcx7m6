{"ast":null,"code":"import * as g from '../g/index.mjs';\nconst Directions = {\n  AUTO: 'auto',\n  LEFT: 'left',\n  RIGHT: 'right',\n  TOP: 'top',\n  BOTTOM: 'bottom',\n  ANCHOR_SIDE: 'anchor-side',\n  MAGNET_SIDE: 'magnet-side'\n};\nconst DEFINED_DIRECTIONS = [Directions.LEFT, Directions.RIGHT, Directions.TOP, Directions.BOTTOM];\nconst OPPOSITE_DIRECTIONS = {\n  [Directions.LEFT]: Directions.RIGHT,\n  [Directions.RIGHT]: Directions.LEFT,\n  [Directions.TOP]: Directions.BOTTOM,\n  [Directions.BOTTOM]: Directions.TOP\n};\nconst VERTICAL_DIRECTIONS = [Directions.TOP, Directions.BOTTOM];\nconst ANGLE_DIRECTION_MAP = {\n  0: Directions.RIGHT,\n  180: Directions.LEFT,\n  270: Directions.TOP,\n  90: Directions.BOTTOM\n};\nfunction getSegmentAngle(line) {\n  // TODO: the angle() method is general and therefore unnecessarily heavy for orthogonal links\n  return line.angle();\n}\nfunction simplifyPoints(points) {\n  // TODO: use own more efficient implementation (filter points that do not change direction).\n  // To simplify segments that are almost aligned (start and end points differ by e.g. 0.5px), use a threshold of 1.\n  return new g.Polyline(points).simplify({\n    threshold: 1\n  }).points;\n}\nfunction resolveSides(source, target) {\n  const {\n    point: sourcePoint,\n    x0: sx0,\n    y0: sy0,\n    view: sourceView,\n    bbox: sourceBBox,\n    direction: sourceDirection\n  } = source;\n  const {\n    point: targetPoint,\n    x0: tx0,\n    y0: ty0,\n    view: targetView,\n    bbox: targetBBox,\n    direction: targetDirection\n  } = target;\n  let sourceSide;\n  if (!sourceView) {\n    const sourceLinkAnchorBBox = new g.Rect(sx0, sy0, 0, 0);\n    sourceSide = DEFINED_DIRECTIONS.includes(sourceDirection) ? sourceDirection : sourceLinkAnchorBBox.sideNearestToPoint(targetPoint);\n  } else if (sourceView.model.isLink()) {\n    sourceSide = getDirectionForLinkConnection(targetPoint, sourcePoint, sourceView);\n  } else if (sourceDirection === Directions.ANCHOR_SIDE) {\n    sourceSide = sourceBBox.sideNearestToPoint(sourcePoint);\n  } else if (sourceDirection === Directions.MAGNET_SIDE) {\n    sourceSide = sourceView.model.getBBox().sideNearestToPoint(sourcePoint);\n  } else {\n    sourceSide = sourceDirection;\n  }\n  let targetSide;\n  if (!targetView) {\n    const targetLinkAnchorBBox = new g.Rect(tx0, ty0, 0, 0);\n    targetSide = DEFINED_DIRECTIONS.includes(targetDirection) ? targetDirection : targetLinkAnchorBBox.sideNearestToPoint(sourcePoint);\n  } else if (targetView.model.isLink()) {\n    targetSide = getDirectionForLinkConnection(sourcePoint, targetPoint, targetView);\n  } else if (targetDirection === Directions.ANCHOR_SIDE) {\n    targetSide = targetBBox.sideNearestToPoint(targetPoint);\n  } else if (targetDirection === Directions.MAGNET_SIDE) {\n    targetSide = targetView.model.getBBox().sideNearestToPoint(targetPoint);\n  } else {\n    targetSide = targetDirection;\n  }\n  return [sourceSide, targetSide];\n}\nfunction resolveForTopSourceSide(source, target, nextInLine) {\n  const {\n    x0: sx0,\n    y0: sy0,\n    width,\n    height,\n    point: anchor,\n    margin\n  } = source;\n  const sx1 = sx0 + width;\n  const sy1 = sy0 + height;\n  const smx0 = sx0 - margin;\n  const smx1 = sx1 + margin;\n  const smy0 = sy0 - margin;\n  const {\n    x: ax\n  } = anchor;\n  const {\n    x0: tx,\n    y0: ty\n  } = target;\n  if (tx === ax && ty < sy0) return Directions.BOTTOM;\n  if (tx < ax && ty < smy0) {\n    if (nextInLine.point.x === ax) return Directions.BOTTOM;\n    return Directions.RIGHT;\n  }\n  if (tx > ax && ty < smy0) {\n    if (nextInLine.point.x === ax) return Directions.BOTTOM;\n    return Directions.LEFT;\n  }\n  if (tx < smx0 && ty >= sy0) return Directions.TOP;\n  if (tx > smx1 && ty >= sy0) return Directions.TOP;\n  if (tx >= smx0 && tx <= ax && ty > sy1) {\n    if (nextInLine.point.x < tx) {\n      return Directions.RIGHT;\n    }\n    return Directions.LEFT;\n  }\n  if (tx <= smx1 && tx >= ax && ty > sy1) {\n    if (nextInLine.point.x < tx) {\n      return Directions.RIGHT;\n    }\n    return Directions.LEFT;\n  }\n  return Directions.TOP;\n}\nfunction resolveForBottomSourceSide(source, target, nextInLine) {\n  const {\n    x0: sx0,\n    y0: sy0,\n    width,\n    height,\n    point: anchor,\n    margin\n  } = source;\n  const sx1 = sx0 + width;\n  const sy1 = sy0 + height;\n  const smx0 = sx0 - margin;\n  const smx1 = sx1 + margin;\n  const smy1 = sy1 + margin;\n  const {\n    x: ax\n  } = anchor;\n  const {\n    x0: tx,\n    y0: ty\n  } = target;\n  if (tx === ax && ty > sy1) return Directions.TOP;\n  if (tx < ax && ty > smy1) {\n    if (nextInLine.point.x === ax) return Directions.TOP;\n    return Directions.RIGHT;\n  }\n  if (tx > ax && ty > smy1) {\n    if (nextInLine.point.x === ax) return Directions.TOP;\n    return Directions.LEFT;\n  }\n  if (tx < smx0 && ty <= sy1) return Directions.BOTTOM;\n  if (tx > smx1 && ty <= sy1) return Directions.BOTTOM;\n  if (tx >= smx0 && tx <= ax && ty < sy0) {\n    if (nextInLine.point.x < tx) {\n      return Directions.RIGHT;\n    }\n    return Directions.LEFT;\n  }\n  if (tx <= smx1 && tx >= ax && ty < sy0) {\n    if (nextInLine.point.x < tx) {\n      return Directions.RIGHT;\n    }\n    return Directions.LEFT;\n  }\n  return Directions.BOTTOM;\n}\nfunction resolveForLeftSourceSide(source, target, nextInLine) {\n  const {\n    y0: sy0,\n    x0: sx0,\n    width,\n    height,\n    point: anchor,\n    margin\n  } = source;\n  const sx1 = sx0 + width;\n  const sy1 = sy0 + height;\n  const smx0 = sx0 - margin;\n  const smy0 = sy0 - margin;\n  const smy1 = sy1 + margin;\n  const {\n    x: ax,\n    y: ay\n  } = anchor;\n  const {\n    x0: tx,\n    y0: ty\n  } = target;\n  if (tx < ax && ty === ay) return Directions.RIGHT;\n  if (tx <= smx0 && ty < ay) return Directions.BOTTOM;\n  if (tx <= smx0 && ty > ay) return Directions.TOP;\n  if (tx >= sx0 && ty <= smy0) return Directions.LEFT;\n  if (tx >= sx0 && ty >= smy1) return Directions.LEFT;\n  if (tx > sx1 && ty >= smy0 && ty <= ay) {\n    if (nextInLine.point.y < ty) {\n      return Directions.BOTTOM;\n    }\n    return Directions.TOP;\n  }\n  if (tx > sx1 && ty <= smy1 && ty >= ay) {\n    if (nextInLine.point.y < ty) {\n      return Directions.BOTTOM;\n    }\n    return Directions.TOP;\n  }\n  return Directions.LEFT;\n}\nfunction resolveForRightSourceSide(source, target, nextInLine) {\n  const {\n    y0: sy0,\n    x0: sx0,\n    width,\n    height,\n    point: anchor,\n    margin\n  } = source;\n  const sx1 = sx0 + width;\n  const sy1 = sy0 + height;\n  const smx1 = sx1 + margin;\n  const smy0 = sy0 - margin;\n  const smy1 = sy1 + margin;\n  const {\n    x: ax,\n    y: ay\n  } = anchor;\n  const {\n    x0: tx,\n    y0: ty\n  } = target;\n  if (tx > ax && ty === ay) return Directions.LEFT;\n  if (tx >= smx1 && ty < ay) return Directions.BOTTOM;\n  if (tx >= smx1 && ty > ay) return Directions.TOP;\n  if (tx <= sx1 && ty <= smy0) return Directions.RIGHT;\n  if (tx <= sx1 && ty >= smy1) return Directions.RIGHT;\n  if (tx < sx0 && ty >= smy0 && ty <= ay) {\n    if (nextInLine.point.y < ty) {\n      return Directions.BOTTOM;\n    }\n    return Directions.TOP;\n  }\n  if (tx < sx0 && ty <= smy1 && ty >= ay) {\n    if (nextInLine.point.y < ty) {\n      return Directions.BOTTOM;\n    }\n    return Directions.TOP;\n  }\n  return Directions.RIGHT;\n}\nfunction resolveInitialDirection(source, target, nextInLine) {\n  const [sourceSide] = resolveSides(source, target);\n  switch (sourceSide) {\n    case Directions.TOP:\n      return resolveForTopSourceSide(source, target, nextInLine);\n    case Directions.RIGHT:\n      return resolveForRightSourceSide(source, target, nextInLine);\n    case Directions.BOTTOM:\n      return resolveForBottomSourceSide(source, target, nextInLine);\n    case Directions.LEFT:\n      return resolveForLeftSourceSide(source, target, nextInLine);\n  }\n}\nfunction getDirectionForLinkConnection(linkOrigin, connectionPoint, linkView) {\n  const tangent = linkView.getTangentAtLength(linkView.getClosestPointLength(connectionPoint));\n  const roundedAngle = Math.round(getSegmentAngle(tangent) / 90) * 90;\n  if (roundedAngle % 180 === 0 && linkOrigin.y === connectionPoint.y) {\n    return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;\n  } else if (linkOrigin.x === connectionPoint.x) {\n    return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;\n  }\n  switch (roundedAngle) {\n    case 0:\n    case 180:\n    case 360:\n      return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;\n    case 90:\n    case 270:\n      return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;\n  }\n}\nfunction pointDataFromAnchor(view, point, bbox, direction, isPort, fallBackAnchor, margin) {\n  if (direction === Directions.AUTO) {\n    direction = isPort ? Directions.MAGNET_SIDE : Directions.ANCHOR_SIDE;\n  }\n  const isElement = view && view.model.isElement();\n  const {\n    x: x0,\n    y: y0,\n    width = 0,\n    height = 0\n  } = isElement ? g.Rect.fromRectUnion(bbox, view.model.getBBox()) : fallBackAnchor;\n  return {\n    point,\n    x0,\n    y0,\n    view,\n    bbox,\n    width,\n    height,\n    direction,\n    margin: isElement ? margin : 0\n  };\n}\nfunction pointDataFromVertex({\n  x,\n  y\n}) {\n  const point = new g.Point(x, y);\n  return {\n    point,\n    x0: point.x,\n    y0: point.y,\n    view: null,\n    bbox: new g.Rect(x, y, 0, 0),\n    width: 0,\n    height: 0,\n    direction: null,\n    margin: 0\n  };\n}\nfunction getOutsidePoint(side, pointData, margin) {\n  const outsidePoint = pointData.point.clone();\n  const {\n    x0,\n    y0,\n    width,\n    height\n  } = pointData;\n  switch (side) {\n    case 'left':\n      outsidePoint.x = x0 - margin;\n      break;\n    case 'right':\n      outsidePoint.x = x0 + width + margin;\n      break;\n    case 'top':\n      outsidePoint.y = y0 - margin;\n      break;\n    case 'bottom':\n      outsidePoint.y = y0 + height + margin;\n      break;\n  }\n  return outsidePoint;\n}\nfunction routeBetweenPoints(source, target, opt = {}) {\n  const {\n    point: sourcePoint,\n    x0: sx0,\n    y0: sy0,\n    width: sourceWidth,\n    height: sourceHeight,\n    margin: sourceMargin\n  } = source;\n  const {\n    point: targetPoint,\n    x0: tx0,\n    y0: ty0,\n    width: targetWidth,\n    height: targetHeight,\n    margin: targetMargin\n  } = target;\n  const {\n    targetInSourceBBox = false\n  } = opt;\n  const tx1 = tx0 + targetWidth;\n  const ty1 = ty0 + targetHeight;\n  const sx1 = sx0 + sourceWidth;\n  const sy1 = sy0 + sourceHeight;\n\n  // Key coordinates including the margin\n  const smx0 = sx0 - sourceMargin;\n  const smx1 = sx1 + sourceMargin;\n  const smy0 = sy0 - sourceMargin;\n  const smy1 = sy1 + sourceMargin;\n  const tmx0 = tx0 - targetMargin;\n  const tmx1 = tx1 + targetMargin;\n  const tmy0 = ty0 - targetMargin;\n  const tmy1 = ty1 + targetMargin;\n  const [sourceSide, targetSide] = resolveSides(source, target);\n  const sourceOutsidePoint = getOutsidePoint(sourceSide, {\n    point: sourcePoint,\n    x0: sx0,\n    y0: sy0,\n    width: sourceWidth,\n    height: sourceHeight\n  }, sourceMargin);\n  const targetOutsidePoint = getOutsidePoint(targetSide, {\n    point: targetPoint,\n    x0: tx0,\n    y0: ty0,\n    width: targetWidth,\n    height: targetHeight\n  }, targetMargin);\n  const {\n    x: sox,\n    y: soy\n  } = sourceOutsidePoint;\n  const {\n    x: tox,\n    y: toy\n  } = targetOutsidePoint;\n  const tcx = (tx0 + tx1) / 2;\n  const tcy = (ty0 + ty1) / 2;\n  const scx = (sx0 + sx1) / 2;\n  const scy = (sy0 + sy1) / 2;\n  const middleOfVerticalSides = (scx < tcx ? sx1 + tx0 : tx1 + sx0) / 2;\n  const middleOfHorizontalSides = (scy < tcy ? sy1 + ty0 : ty1 + sy0) / 2;\n  const sourceBBox = new g.Rect(sx0, sy0, sourceWidth, sourceHeight);\n  const targetBBox = new g.Rect(tx0, ty0, targetWidth, targetHeight);\n  const inflatedSourceBBox = sourceBBox.clone().inflate(sourceMargin);\n  const inflatedTargetBBox = targetBBox.clone().inflate(targetMargin);\n  if (sourceSide === 'left' && targetSide === 'right') {\n    if (smx0 <= tmx1) {\n      let y = middleOfHorizontalSides;\n      if (sox <= tmx0) {\n        if (ty1 >= smy0 && toy < soy) {\n          y = Math.min(tmy0, smy0);\n        } else if (ty0 <= smy1 && toy >= soy) {\n          y = Math.max(tmy1, smy1);\n        }\n      }\n      return [{\n        x: sox,\n        y: soy\n      }, {\n        x: sox,\n        y\n      }, {\n        x: tox,\n        y\n      }, {\n        x: tox,\n        y: toy\n      }];\n    }\n    const x = (sox + tox) / 2;\n    return [{\n      x,\n      y: soy\n    }, {\n      x,\n      y: toy\n    }];\n  } else if (sourceSide === 'right' && targetSide === 'left') {\n    if (sox >= tmx0) {\n      let y = middleOfHorizontalSides;\n      if (sox > tx1) {\n        if (ty1 >= smy0 && toy < soy) {\n          y = Math.min(tmy0, smy0);\n        } else if (ty0 <= smy1 && toy >= soy) {\n          y = Math.max(tmy1, smy1);\n        }\n      }\n      return [{\n        x: sox,\n        y: soy\n      }, {\n        x: sox,\n        y\n      }, {\n        x: tox,\n        y\n      }, {\n        x: tox,\n        y: toy\n      }];\n    }\n    const x = (sox + tox) / 2;\n    return [{\n      x,\n      y: soy\n    }, {\n      x,\n      y: toy\n    }];\n  } else if (sourceSide === 'top' && targetSide === 'bottom') {\n    const isPointInsideSource = g.intersection.rectWithRect(inflatedSourceBBox, targetBBox);\n    if (soy < toy) {\n      let x = middleOfVerticalSides;\n      let y = soy;\n      if (isPointInsideSource) {\n        y = Math.min(y, tmy0);\n      }\n      if (tx1 >= smx0 && tox < sox) {\n        x = Math.min(tmx0, smx0);\n      } else if (tx0 <= smx1 && tox >= sox) {\n        x = Math.max(tmx1, smx1);\n      }\n      return [{\n        x: sox,\n        y\n      }, {\n        x,\n        y\n      }, {\n        x,\n        y: toy\n      }, {\n        x: tox,\n        y: toy\n      }];\n    }\n    const y = (soy + toy) / 2;\n    return [{\n      x: sox,\n      y\n    }, {\n      x: tox,\n      y\n    }];\n  } else if (sourceSide === 'bottom' && targetSide === 'top') {\n    const isPointInsideSource = g.intersection.rectWithRect(inflatedSourceBBox, targetBBox);\n    if (soy > toy) {\n      let x = middleOfVerticalSides;\n      let y = soy;\n      if (isPointInsideSource) {\n        y = Math.max(y, tmy1);\n      }\n      if (tx1 >= smx0 && tox < sox) {\n        x = Math.min(tmx0, smx0);\n      } else if (tx0 <= smx1 && tox >= sox) {\n        x = Math.max(tmx1, smx1);\n      }\n      return [{\n        x: sox,\n        y\n      }, {\n        x,\n        y\n      }, {\n        x,\n        y: toy\n      }, {\n        x: tox,\n        y: toy\n      }];\n    }\n    const y = (soy + toy) / 2;\n    return [{\n      x: sox,\n      y\n    }, {\n      x: tox,\n      y\n    }];\n  } else if (sourceSide === 'top' && targetSide === 'top') {\n    const useUShapeConnection = targetInSourceBBox || g.intersection.rectWithRect(inflatedSourceBBox, targetBBox) || soy <= ty0 && (inflatedSourceBBox.bottomRight().x <= tox || inflatedSourceBBox.bottomLeft().x >= tox) || soy >= ty0 && (inflatedTargetBBox.bottomRight().x <= sox || inflatedTargetBBox.bottomLeft().x >= sox);\n    if (useUShapeConnection) {\n      return [{\n        x: sox,\n        y: Math.min(soy, toy)\n      }, {\n        x: tox,\n        y: Math.min(soy, toy)\n      }];\n    }\n    let x;\n    let y1 = Math.min((sy1 + ty0) / 2, toy);\n    let y2 = Math.min((sy0 + ty1) / 2, soy);\n    if (toy < soy) {\n      if (tox > sox) {\n        x = Math.min(sox, tmx0);\n      } else {\n        x = Math.max(sox, tmx1);\n      }\n    } else {\n      if (tox >= sox) {\n        x = Math.max(tox, smx1);\n      } else {\n        x = Math.min(tox, smx0);\n      }\n    }\n    return [{\n      x: sox,\n      y: y2\n    }, {\n      x,\n      y: y2\n    }, {\n      x,\n      y: y1\n    }, {\n      x: tox,\n      y: y1\n    }];\n  } else if (sourceSide === 'bottom' && targetSide === 'bottom') {\n    const useUShapeConnection = targetInSourceBBox || g.intersection.rectWithRect(inflatedSourceBBox, targetBBox) || soy >= toy && (inflatedSourceBBox.topRight().x <= tox || inflatedSourceBBox.topLeft().x >= tox) || soy <= toy && (inflatedTargetBBox.topRight().x <= sox || inflatedTargetBBox.topLeft().x >= sox);\n    if (useUShapeConnection) {\n      return [{\n        x: sox,\n        y: Math.max(soy, toy)\n      }, {\n        x: tox,\n        y: Math.max(soy, toy)\n      }];\n    }\n    let x;\n    let y1 = Math.max((sy0 + ty1) / 2, toy);\n    let y2 = Math.max((sy1 + ty0) / 2, soy);\n    if (toy > soy) {\n      if (tox > sox) {\n        x = Math.min(sox, tmx0);\n      } else {\n        x = Math.max(sox, tmx1);\n      }\n    } else {\n      if (tox >= sox) {\n        x = Math.max(tox, smx1);\n      } else {\n        x = Math.min(tox, smx0);\n      }\n    }\n    return [{\n      x: sox,\n      y: y2\n    }, {\n      x,\n      y: y2\n    }, {\n      x,\n      y: y1\n    }, {\n      x: tox,\n      y: y1\n    }];\n  } else if (sourceSide === 'left' && targetSide === 'left') {\n    const useUShapeConnection = targetInSourceBBox || g.intersection.rectWithRect(inflatedSourceBBox, targetBBox) || sox <= tox && (inflatedSourceBBox.bottomRight().y <= toy || inflatedSourceBBox.topRight().y >= toy) || sox >= tox && (inflatedTargetBBox.bottomRight().y <= soy || inflatedTargetBBox.topRight().y >= soy);\n    if (useUShapeConnection) {\n      return [{\n        x: Math.min(sox, tox),\n        y: soy\n      }, {\n        x: Math.min(sox, tox),\n        y: toy\n      }];\n    }\n    let y;\n    let x1 = Math.min((sx1 + tx0) / 2, tox);\n    let x2 = Math.min((sx0 + tx1) / 2, sox);\n    if (tox > sox) {\n      if (toy <= soy) {\n        y = Math.min(smy0, toy);\n      } else {\n        y = Math.max(smy1, toy);\n      }\n    } else {\n      if (toy >= soy) {\n        y = Math.min(tmy0, soy);\n      } else {\n        y = Math.max(tmy1, soy);\n      }\n    }\n    return [{\n      x: x2,\n      y: soy\n    }, {\n      x: x2,\n      y\n    }, {\n      x: x1,\n      y\n    }, {\n      x: x1,\n      y: toy\n    }];\n  } else if (sourceSide === 'right' && targetSide === 'right') {\n    const useUShapeConnection = targetInSourceBBox || g.intersection.rectWithRect(inflatedSourceBBox, targetBBox) || sox >= tox && (inflatedSourceBBox.bottomLeft().y <= toy || inflatedSourceBBox.topLeft().y >= toy) || sox <= tox && (inflatedTargetBBox.bottomLeft().y <= soy || inflatedTargetBBox.topLeft().y >= soy);\n    if (useUShapeConnection) {\n      return [{\n        x: Math.max(sox, tox),\n        y: soy\n      }, {\n        x: Math.max(sox, tox),\n        y: toy\n      }];\n    }\n    let y;\n    let x1 = Math.max((sx0 + tx1) / 2, tox);\n    let x2 = Math.max((sx1 + tx0) / 2, sox);\n    if (tox <= sox) {\n      if (toy <= soy) {\n        y = Math.min(smy0, toy);\n      } else {\n        y = Math.max(smy1, toy);\n      }\n    } else {\n      if (toy >= soy) {\n        y = Math.min(tmy0, soy);\n      } else {\n        y = Math.max(tmy1, soy);\n      }\n    }\n    return [{\n      x: x2,\n      y: soy\n    }, {\n      x: x2,\n      y\n    }, {\n      x: x1,\n      y\n    }, {\n      x: x1,\n      y: toy\n    }];\n  } else if (sourceSide === 'top' && targetSide === 'right') {\n    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n    // The target point is inside the source element\n    if (isPointInsideSource) {\n      if (sox <= tmx1) {\n        const x = Math.max(sox + sourceMargin, tox);\n        const y = Math.min(smy0, tmy0);\n\n        // Target anchor is on the right side of the source anchor\n        return [{\n          x: sox,\n          y\n        }, {\n          x: x,\n          y\n        }, {\n          x: x,\n          y: toy\n        }];\n      }\n\n      // Target anchor is on the left side of the source anchor\n      // Subtract the `sourceMargin` since the source anchor is on the right side of the target anchor\n      const anchorMiddleX = (sox - sourceMargin + tox) / 2;\n      return [{\n        x: sox,\n        y: soy\n      }, {\n        x: anchorMiddleX,\n        y: soy\n      }, {\n        x: anchorMiddleX,\n        y: toy\n      }];\n    }\n    if (smy0 > toy) {\n      if (sox < tox) {\n        let y = tmy0;\n        if (tmy1 <= smy0 && tmx1 >= sox) {\n          y = middleOfHorizontalSides;\n        }\n        return [{\n          x: sox,\n          y\n        }, {\n          x: tox,\n          y\n        }, {\n          x: tox,\n          y: toy\n        }];\n      }\n      return [{\n        x: sox,\n        y: toy\n      }];\n    }\n    const x = Math.max(middleOfVerticalSides, tmx1);\n    if (sox > tox && sy1 >= toy) {\n      return [{\n        x: sox,\n        y: soy\n      }, {\n        x,\n        y: soy\n      }, {\n        x,\n        y: toy\n      }];\n    }\n    if (x > smx0 && soy < ty1) {\n      const y = Math.min(smy0, tmy0);\n      const x = Math.max(smx1, tmx1);\n      return [{\n        x: sox,\n        y\n      }, {\n        x,\n        y\n      }, {\n        x,\n        y: toy\n      }];\n    }\n    return [{\n      x: sox,\n      y: soy\n    }, {\n      x,\n      y: soy\n    }, {\n      x,\n      y: toy\n    }];\n  } else if (sourceSide === 'top' && targetSide === 'left') {\n    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n    // The target point is inside the source element\n    if (isPointInsideSource) {\n      if (sox >= tmx0) {\n        const x = Math.min(sox - sourceMargin, tox);\n        const y = Math.min(smy0, tmy0);\n\n        // Target anchor is on the left side of the source anchor\n        return [{\n          x: sox,\n          y\n        }, {\n          x: x,\n          y\n        }, {\n          x: x,\n          y: toy\n        }];\n      }\n\n      // Target anchor is on the right side of the source anchor\n      // Add the `sourceMargin` since the source anchor is on the left side of the target anchor\n      const anchorMiddleX = (sox + sourceMargin + tox) / 2;\n      return [{\n        x: sox,\n        y: soy\n      }, {\n        x: anchorMiddleX,\n        y: soy\n      }, {\n        x: anchorMiddleX,\n        y: toy\n      }];\n    }\n    if (smy0 > toy) {\n      if (sox > tox) {\n        let y = tmy0;\n        if (tmy1 <= smy0 && tmx0 <= sox) {\n          y = middleOfHorizontalSides;\n        }\n        return [{\n          x: sox,\n          y\n        }, {\n          x: tox,\n          y\n        }, {\n          x: tox,\n          y: toy\n        }];\n      }\n      return [{\n        x: sox,\n        y: toy\n      }];\n    }\n    const x = Math.min(tmx0, middleOfVerticalSides);\n    if (sox < tox && sy1 >= toy) {\n      return [{\n        x: sox,\n        y: soy\n      }, {\n        x,\n        y: soy\n      }, {\n        x,\n        y: toy\n      }];\n    }\n    if (x < smx1 && soy < ty1) {\n      const y = Math.min(smy0, tmy0);\n      const x = Math.min(smx0, tmx0);\n      return [{\n        x: sox,\n        y\n      }, {\n        x,\n        y\n      }, {\n        x,\n        y: toy\n      }];\n    }\n    return [{\n      x: sox,\n      y: soy\n    }, {\n      x,\n      y: soy\n    }, {\n      x,\n      y: toy\n    }];\n  } else if (sourceSide === 'bottom' && targetSide === 'right') {\n    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n    // The target point is inside the source element\n    if (isPointInsideSource) {\n      if (sox <= tmx1) {\n        const x = Math.max(sox + sourceMargin, tox);\n        const y = Math.max(smy1, tmy1);\n\n        // Target anchor is on the right side of the source anchor\n        return [{\n          x: sox,\n          y\n        }, {\n          x,\n          y\n        }, {\n          x,\n          y: toy\n        }];\n      }\n\n      // Target anchor is on the left side of the source anchor\n      // Subtract the `sourceMargin` since the source anchor is on the right side of the target anchor\n      const anchorMiddleX = (sox - sourceMargin + tox) / 2;\n      return [{\n        x: sox,\n        y: soy\n      }, {\n        x: anchorMiddleX,\n        y: soy\n      }, {\n        x: anchorMiddleX,\n        y: toy\n      }];\n    }\n    if (smy1 < toy) {\n      if (sox < tox) {\n        let y = tmy1;\n        if (tmy0 >= smy1 && tmx1 >= sox) {\n          y = middleOfHorizontalSides;\n        }\n        return [{\n          x: sox,\n          y\n        }, {\n          x: tox,\n          y\n        }, {\n          x: tox,\n          y: toy\n        }];\n      }\n      return [{\n        x: sox,\n        y: toy\n      }];\n    }\n    const x = Math.max(middleOfVerticalSides, tmx1);\n    if (sox > tox && sy0 <= toy) {\n      return [{\n        x: sox,\n        y: soy\n      }, {\n        x,\n        y: soy\n      }, {\n        x,\n        y: toy\n      }];\n    }\n    if (x > smx0 && soy > ty0) {\n      const y = Math.max(smy1, tmy1);\n      const x = Math.max(smx1, tmx1);\n      return [{\n        x: sox,\n        y\n      }, {\n        x,\n        y\n      }, {\n        x,\n        y: toy\n      }];\n    }\n    return [{\n      x: sox,\n      y: soy\n    }, {\n      x,\n      y: soy\n    }, {\n      x,\n      y: toy\n    }];\n  } else if (sourceSide === 'bottom' && targetSide === 'left') {\n    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n    // The target point is inside the source element\n    if (isPointInsideSource) {\n      if (sox >= tmx0) {\n        const x = Math.min(sox - sourceMargin, tox);\n        const y = Math.max(smy1, tmy1);\n\n        // Target anchor is on the left side of the source anchor\n        return [{\n          x: sox,\n          y\n        }, {\n          x,\n          y\n        }, {\n          x,\n          y: toy\n        }];\n      }\n\n      // Target anchor is on the right side of the source anchor\n      // Add the `sourceMargin` since the source anchor is on the left side of the target anchor\n      const anchorMiddleX = (sox + sourceMargin + tox) / 2;\n      return [{\n        x: sox,\n        y: soy\n      }, {\n        x: anchorMiddleX,\n        y: soy\n      }, {\n        x: anchorMiddleX,\n        y: toy\n      }];\n    }\n    if (smy1 < toy) {\n      if (sox > tox) {\n        let y = tmy1;\n        if (tmy0 >= smy1 && tmx0 <= sox) {\n          y = middleOfHorizontalSides;\n        }\n        return [{\n          x: sox,\n          y\n        }, {\n          x: tox,\n          y\n        }, {\n          x: tox,\n          y: toy\n        }];\n      }\n      return [{\n        x: sox,\n        y: toy\n      }];\n    }\n    const x = Math.min(tmx0, middleOfVerticalSides);\n    if (sox < tox && sy0 <= toy) {\n      return [{\n        x: sox,\n        y: soy\n      }, {\n        x,\n        y: soy\n      }, {\n        x,\n        y: toy\n      }];\n    }\n    if (x < smx1 && soy > ty0) {\n      const y = Math.max(smy1, tmy1);\n      const x = Math.min(smx0, tmx0);\n      return [{\n        x: sox,\n        y\n      }, {\n        x,\n        y\n      }, {\n        x,\n        y: toy\n      }];\n    }\n    return [{\n      x: sox,\n      y: soy\n    }, {\n      x,\n      y: soy\n    }, {\n      x,\n      y: toy\n    }];\n  } else if (sourceSide === 'left' && targetSide === 'bottom') {\n    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n    // The target point is inside the source element\n    if (isPointInsideSource) {\n      if (soy <= tmy1) {\n        const x = Math.min(smx0, tmx0);\n        const y = Math.max(soy + sourceMargin, toy);\n        return [{\n          x,\n          y: soy\n        }, {\n          x,\n          y\n        }, {\n          x: tox,\n          y\n        }];\n      }\n\n      // Target anchor is above the source anchor\n      const anchorMiddleY = (soy - sourceMargin + toy) / 2;\n      return [{\n        x: sox,\n        y: soy\n      }, {\n        x: sox,\n        y: anchorMiddleY\n      }, {\n        x: tox,\n        y: anchorMiddleY\n      }];\n    }\n    if (smx0 > tox) {\n      if (soy < toy) {\n        let x = tmx0;\n        if (tmx1 <= smx0 && tmy1 >= soy) {\n          x = middleOfVerticalSides;\n        }\n        return [{\n          x,\n          y: soy\n        }, {\n          x,\n          y: toy\n        }, {\n          x: tox,\n          y: toy\n        }];\n      }\n      return [{\n        x: tox,\n        y: soy\n      }];\n    }\n    const y = Math.max(tmy1, middleOfHorizontalSides);\n    if (soy > toy && sx1 >= tox) {\n      return [{\n        x: sox,\n        y: soy\n      }, {\n        x: sox,\n        y\n      }, {\n        x: tox,\n        y\n      }];\n    }\n    if (y > smy0 && sox < tx1) {\n      const x = Math.min(smx0, tmx0);\n      const y = Math.max(smy1, tmy1);\n      return [{\n        x,\n        y: soy\n      }, {\n        x,\n        y\n      }, {\n        x: tox,\n        y\n      }];\n    }\n    return [{\n      x: sox,\n      y: soy\n    }, {\n      x: sox,\n      y\n    }, {\n      x: tox,\n      y\n    }];\n  } else if (sourceSide === 'left' && targetSide === 'top') {\n    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n    // The target point is inside the source element\n    if (isPointInsideSource) {\n      if (soy >= tmy0) {\n        const y = Math.min(soy - sourceMargin, toy);\n        const x = Math.min(smx0, tmx0);\n\n        // Target anchor is on the top side of the source anchor\n        return [{\n          x,\n          y: soy\n        }, {\n          x,\n          y\n        }, {\n          x: tox,\n          y\n        }];\n      }\n\n      // Target anchor is below the source anchor\n      // Add the `sourceMargin` since the source anchor is above the target anchor\n      const anchorMiddleY = (soy + sourceMargin + toy) / 2;\n      return [{\n        x: sox,\n        y: soy\n      }, {\n        x: sox,\n        y: anchorMiddleY\n      }, {\n        x: tox,\n        y: anchorMiddleY\n      }];\n    }\n    if (smx0 > tox) {\n      if (soy > toy) {\n        let x = tmx0;\n        if (tmx1 <= smx0 && tmy0 <= soy) {\n          x = middleOfVerticalSides;\n        }\n        return [{\n          x,\n          y: soy\n        }, {\n          x,\n          y: toy\n        }, {\n          x: tox,\n          y: toy\n        }];\n      }\n      return [{\n        x: tox,\n        y: soy\n      }];\n    }\n    const y = Math.min(tmy0, middleOfHorizontalSides);\n    if (soy < toy && sx1 >= tox) {\n      return [{\n        x: sox,\n        y: soy\n      }, {\n        x: sox,\n        y\n      }, {\n        x: tox,\n        y\n      }];\n    }\n    if (y < smy1 && sox < tx1) {\n      const x = Math.min(smx0, tmx0);\n      const y = Math.min(smy0, tmy0);\n      return [{\n        x,\n        y: soy\n      }, {\n        x,\n        y\n      }, {\n        x: tox,\n        y\n      }];\n    }\n    return [{\n      x: sox,\n      y: soy\n    }, {\n      x: sox,\n      y\n    }, {\n      x: tox,\n      y\n    }];\n  } else if (sourceSide === 'right' && targetSide === 'top') {\n    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n    // The target point is inside the source element\n    if (isPointInsideSource) {\n      if (soy >= tmy0) {\n        const x = Math.max(smx1, tmx1);\n        const y = Math.min(soy - sourceMargin, toy);\n\n        // Target anchor is on the top side of the source anchor\n        return [{\n          x,\n          y: soy\n        }, {\n          x,\n          y\n        },\n        // Path adjustment for right side start\n        {\n          x: tox,\n          y\n        }];\n      }\n\n      // Target anchor is below the source anchor\n      // Adjust sourceMargin calculation since the source anchor is now on the right\n      const anchorMiddleY = (soy + sourceMargin + toy) / 2;\n      return [{\n        x: sox,\n        y: soy\n      }, {\n        x: sox,\n        y: anchorMiddleY\n      }, {\n        x: tox,\n        y: anchorMiddleY\n      }];\n    }\n    if (smx1 < tox) {\n      if (soy > toy) {\n        let x = tmx1;\n        if (tmx0 >= smx1 && tmy0 <= soy) {\n          x = middleOfVerticalSides;\n        }\n        return [{\n          x,\n          y: soy\n        }, {\n          x,\n          y: toy\n        }, {\n          x: tox,\n          y: toy\n        }];\n      }\n      return [{\n        x: tox,\n        y: soy\n      }];\n    }\n    const y = Math.min(tmy0, middleOfHorizontalSides);\n    if (soy < toy && sx0 <= tox) {\n      return [{\n        x: sox,\n        y: soy\n      }, {\n        x: sox,\n        y\n      }, {\n        x: tox,\n        y\n      }];\n    }\n    if (y < smy1 && sox > tx0) {\n      const x = Math.max(smx1, tmx1);\n      const y = Math.min(smy0, tmy0);\n      return [{\n        x,\n        y: soy\n      }, {\n        x,\n        y\n      }, {\n        x: tox,\n        y\n      }];\n    }\n    return [{\n      x: sox,\n      y: soy\n    }, {\n      x: sox,\n      y\n    }, {\n      x: tox,\n      y\n    }];\n  } else if (sourceSide === 'right' && targetSide === 'bottom') {\n    const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n    // The target point is inside the source element\n    if (isPointInsideSource) {\n      if (soy <= tmy1) {\n        const x = Math.max(smx1, tmx1);\n        const y = Math.max(soy + sourceMargin, toy);\n        return [{\n          x,\n          y: soy\n        }, {\n          x,\n          y\n        }, {\n          x: tox,\n          y\n        }];\n      }\n\n      // Target anchor is above the source anchor\n      const anchorMiddleY = (soy - sourceMargin + toy) / 2;\n      return [{\n        x: sox,\n        y: soy\n      }, {\n        x: sox,\n        y: anchorMiddleY\n      }, {\n        x: tox,\n        y: anchorMiddleY\n      }];\n    }\n    if (smx1 < tox) {\n      if (soy < toy) {\n        let x = tmx1;\n        if (tmx0 >= smx1 && tmy1 >= soy) {\n          x = middleOfVerticalSides;\n        }\n        return [{\n          x,\n          y: soy\n        }, {\n          x,\n          y: toy\n        }, {\n          x: tox,\n          y: toy\n        }];\n      }\n      return [{\n        x: tox,\n        y: soy\n      }];\n    }\n    const y = Math.max(tmy1, middleOfHorizontalSides);\n    if (soy > toy && sx0 <= tox) {\n      return [{\n        x: sox,\n        y: soy\n      }, {\n        x: sox,\n        y\n      }, {\n        x: tox,\n        y\n      }];\n    }\n    if (y > smy0 && sox > tx0) {\n      const x = Math.max(smx1, tmx1);\n      const y = Math.max(smy1, tmy1);\n      return [{\n        x,\n        y: soy\n      }, {\n        x,\n        y\n      }, {\n        x: tox,\n        y\n      }];\n    }\n    return [{\n      x: sox,\n      y: soy\n    }, {\n      x: sox,\n      y\n    }, {\n      x: tox,\n      y\n    }];\n  }\n}\nfunction rightAngleRouter(vertices, opt, linkView) {\n  const {\n    sourceDirection = Directions.AUTO,\n    targetDirection = Directions.AUTO\n  } = opt;\n  const margin = opt.margin || 20;\n  const useVertices = opt.useVertices || false;\n  const isSourcePort = !!linkView.model.source().port;\n  const sourcePoint = pointDataFromAnchor(linkView.sourceView, linkView.sourceAnchor, linkView.sourceBBox, sourceDirection, isSourcePort, linkView.sourceAnchor, margin);\n  const isTargetPort = !!linkView.model.target().port;\n  const targetPoint = pointDataFromAnchor(linkView.targetView, linkView.targetAnchor, linkView.targetBBox, targetDirection, isTargetPort, linkView.targetAnchor, margin);\n  let resultVertices = [];\n  if (!useVertices || vertices.length === 0) {\n    return simplifyPoints(routeBetweenPoints(sourcePoint, targetPoint));\n  }\n  const verticesData = vertices.map(v => pointDataFromVertex(v));\n  const [firstVertex] = verticesData;\n  if (sourcePoint.view && sourcePoint.view.model.isElement() && sourcePoint.view.model.getBBox().inflate(margin).containsPoint(firstVertex.point)) {\n    const [fromDirection] = resolveSides(sourcePoint, firstVertex);\n    const toDirection = fromDirection;\n    const dummySource = pointDataFromVertex(sourcePoint.point);\n    // Points do not usually have margin. Here we create a point with a margin.\n    dummySource.margin = margin;\n    dummySource.direction = fromDirection;\n    firstVertex.direction = toDirection;\n    resultVertices.push(...routeBetweenPoints(dummySource, firstVertex, {\n      targetInSourceBBox: true\n    }), firstVertex.point);\n  } else {\n    // The first point responsible for the initial direction of the route\n    const next = verticesData[1] || targetPoint;\n    const direction = resolveInitialDirection(sourcePoint, firstVertex, next);\n    firstVertex.direction = direction;\n    resultVertices.push(...routeBetweenPoints(sourcePoint, firstVertex), firstVertex.point);\n  }\n  for (let i = 0; i < verticesData.length - 1; i++) {\n    const from = verticesData[i];\n    const to = verticesData[i + 1];\n    const segment = new g.Line(from.point, to.point);\n    const segmentAngle = getSegmentAngle(segment);\n    if (segmentAngle % 90 === 0) {\n      // Since the segment is horizontal or vertical, we can skip the routing and just connect them with a straight line\n      const toDirection = ANGLE_DIRECTION_MAP[segmentAngle];\n      const accessDirection = OPPOSITE_DIRECTIONS[toDirection];\n      if (toDirection !== from.direction) {\n        resultVertices.push(from.point, to.point);\n        to.direction = accessDirection;\n      } else {\n        const angle = g.normalizeAngle(segmentAngle - 90);\n        let dx = 0;\n        let dy = 0;\n        if (angle === 90) {\n          dy = -margin;\n        } else if (angle === 180) {\n          dx = -margin;\n        } else if (angle === 270) {\n          dy = margin;\n        } else if (angle === 0) {\n          dx = margin;\n        }\n        const p1 = {\n          x: from.point.x + dx,\n          y: from.point.y + dy\n        };\n        const p2 = {\n          x: to.point.x + dx,\n          y: to.point.y + dy\n        };\n        const segment2 = new g.Line(to.point, p2);\n        to.direction = ANGLE_DIRECTION_MAP[getSegmentAngle(segment2)];\n\n        // Constructing a loop\n        resultVertices.push(from.point, p1, p2, to.point);\n      }\n      continue;\n    }\n    const [fromDirection, toDirection] = resolveDirection(from, to);\n    from.direction = fromDirection;\n    to.direction = toDirection;\n    resultVertices.push(...routeBetweenPoints(from, to), to.point);\n  }\n  const lastVertex = verticesData[verticesData.length - 1];\n  if (targetPoint.view && targetPoint.view.model.isElement()) {\n    if (targetPoint.view.model.getBBox().inflate(margin).containsPoint(lastVertex.point)) {\n      const [fromDirection] = resolveDirection(lastVertex, targetPoint);\n      const dummyTarget = pointDataFromVertex(targetPoint.point);\n      const [, toDirection] = resolveSides(lastVertex, targetPoint);\n      // we are creating a point that has a margin\n      dummyTarget.margin = margin;\n      dummyTarget.direction = toDirection;\n      lastVertex.direction = fromDirection;\n      resultVertices.push(...routeBetweenPoints(lastVertex, dummyTarget));\n    } else {\n      // the last point of `simplified` array is the last defined vertex\n      // grab the penultimate point and construct a line segment from it to the last vertex\n      // this will ensure that the last segment continues in a straight line\n\n      const simplified = simplifyPoints(resultVertices);\n      const segment = new g.Line(simplified[simplified.length - 2], lastVertex.point);\n      const definedDirection = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(segment))];\n      lastVertex.direction = definedDirection;\n      let lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);\n      const [p1, p2] = simplifyPoints([...lastSegmentRoute, targetPoint.point]);\n      const lastSegment = new g.Line(p1, p2);\n      const roundedLastSegmentAngle = Math.round(getSegmentAngle(lastSegment));\n      const lastSegmentDirection = ANGLE_DIRECTION_MAP[roundedLastSegmentAngle];\n      if (lastSegmentDirection !== definedDirection && definedDirection === OPPOSITE_DIRECTIONS[lastSegmentDirection]) {\n        lastVertex.margin = margin;\n        lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);\n      }\n      resultVertices.push(...lastSegmentRoute);\n    }\n  } else {\n    // since the target is only a point we can apply the same logic as if we connected two verticesData\n    const [vertexDirection] = resolveDirection(lastVertex, targetPoint);\n    lastVertex.direction = vertexDirection;\n    resultVertices.push(...routeBetweenPoints(lastVertex, targetPoint));\n  }\n  return simplifyPoints(resultVertices);\n}\nfunction resolveDirection(from, to) {\n  const accessDirection = from.direction;\n  const isDirectionVertical = VERTICAL_DIRECTIONS.includes(accessDirection);\n  let sourceDirection = from.direction;\n  let targetDirection = to.direction;\n  if (isDirectionVertical) {\n    const isToAbove = from.point.y > to.point.y;\n    const dx = to.point.x - from.point.x;\n    if (accessDirection === Directions.BOTTOM) {\n      // If isToAbove === false and we need figure out if to go left or right\n      sourceDirection = isToAbove ? OPPOSITE_DIRECTIONS[accessDirection] : dx >= 0 ? Directions.RIGHT : Directions.LEFT;\n      if (dx > 0) {\n        targetDirection = isToAbove ? Directions.LEFT : Directions.TOP;\n      } else if (dx < 0) {\n        targetDirection = isToAbove ? Directions.RIGHT : Directions.TOP;\n      }\n    } else {\n      // If isToAbove === true and we need figure out if to go left or right\n      sourceDirection = isToAbove ? dx >= 0 ? Directions.RIGHT : Directions.LEFT : OPPOSITE_DIRECTIONS[accessDirection];\n      if (dx > 0) {\n        targetDirection = isToAbove ? Directions.BOTTOM : Directions.LEFT;\n      } else if (dx < 0) {\n        targetDirection = isToAbove ? Directions.BOTTOM : Directions.RIGHT;\n      }\n    }\n  } else {\n    const isToLeft = from.point.x > to.point.x;\n    const dy = to.point.y - from.point.y;\n    if (accessDirection === Directions.RIGHT) {\n      sourceDirection = isToLeft ? OPPOSITE_DIRECTIONS[accessDirection] : dy >= 0 ? Directions.BOTTOM : Directions.TOP;\n      if (dy > 0) {\n        targetDirection = isToLeft ? Directions.TOP : Directions.LEFT;\n      } else if (dy < 0) {\n        targetDirection = isToLeft ? Directions.BOTTOM : Directions.LEFT;\n      }\n    } else {\n      sourceDirection = isToLeft ? dy >= 0 ? Directions.BOTTOM : Directions.TOP : OPPOSITE_DIRECTIONS[accessDirection];\n      if (dy > 0) {\n        targetDirection = isToLeft ? Directions.RIGHT : Directions.TOP;\n      } else if (dy < 0) {\n        targetDirection = isToLeft ? Directions.RIGHT : Directions.BOTTOM;\n      }\n    }\n  }\n  return [sourceDirection, targetDirection];\n}\nrightAngleRouter.Directions = Directions;\nexport const rightAngle = rightAngleRouter;","map":{"version":3,"names":["g","Directions","AUTO","LEFT","RIGHT","TOP","BOTTOM","ANCHOR_SIDE","MAGNET_SIDE","DEFINED_DIRECTIONS","OPPOSITE_DIRECTIONS","VERTICAL_DIRECTIONS","ANGLE_DIRECTION_MAP","getSegmentAngle","line","angle","simplifyPoints","points","Polyline","simplify","threshold","resolveSides","source","target","point","sourcePoint","x0","sx0","y0","sy0","view","sourceView","bbox","sourceBBox","direction","sourceDirection","targetPoint","tx0","ty0","targetView","targetBBox","targetDirection","sourceSide","sourceLinkAnchorBBox","Rect","includes","sideNearestToPoint","model","isLink","getDirectionForLinkConnection","getBBox","targetSide","targetLinkAnchorBBox","resolveForTopSourceSide","nextInLine","width","height","anchor","margin","sx1","sy1","smx0","smx1","smy0","x","ax","tx","ty","resolveForBottomSourceSide","smy1","resolveForLeftSourceSide","y","ay","resolveForRightSourceSide","resolveInitialDirection","linkOrigin","connectionPoint","linkView","tangent","getTangentAtLength","getClosestPointLength","roundedAngle","Math","round","pointDataFromAnchor","isPort","fallBackAnchor","isElement","fromRectUnion","pointDataFromVertex","Point","getOutsidePoint","side","pointData","outsidePoint","clone","routeBetweenPoints","opt","sourceWidth","sourceHeight","sourceMargin","targetWidth","targetHeight","targetMargin","targetInSourceBBox","tx1","ty1","tmx0","tmx1","tmy0","tmy1","sourceOutsidePoint","targetOutsidePoint","sox","soy","tox","toy","tcx","tcy","scx","scy","middleOfVerticalSides","middleOfHorizontalSides","inflatedSourceBBox","inflate","inflatedTargetBBox","min","max","isPointInsideSource","intersection","rectWithRect","useUShapeConnection","bottomRight","bottomLeft","y1","y2","topRight","topLeft","x1","x2","containsPoint","anchorMiddleX","anchorMiddleY","rightAngleRouter","vertices","useVertices","isSourcePort","port","sourceAnchor","isTargetPort","targetAnchor","resultVertices","length","verticesData","map","v","firstVertex","fromDirection","toDirection","dummySource","push","next","i","from","to","segment","Line","segmentAngle","accessDirection","normalizeAngle","dx","dy","p1","p2","segment2","resolveDirection","lastVertex","dummyTarget","simplified","definedDirection","lastSegmentRoute","lastSegment","roundedLastSegmentAngle","lastSegmentDirection","vertexDirection","isDirectionVertical","isToAbove","isToLeft","rightAngle"],"sources":["D:/react-vcx7m6/node_modules/@joint/core/src/routers/rightAngle.mjs"],"sourcesContent":["import * as g from '../g/index.mjs';\n\nconst Directions = {\n    AUTO: 'auto',\n    LEFT: 'left',\n    RIGHT: 'right',\n    TOP: 'top',\n    BOTTOM: 'bottom',\n    ANCHOR_SIDE: 'anchor-side',\n    MAGNET_SIDE: 'magnet-side'\n};\n\nconst DEFINED_DIRECTIONS = [Directions.LEFT, Directions.RIGHT, Directions.TOP, Directions.BOTTOM];\n\nconst OPPOSITE_DIRECTIONS = {\n    [Directions.LEFT]: Directions.RIGHT,\n    [Directions.RIGHT]: Directions.LEFT,\n    [Directions.TOP]: Directions.BOTTOM,\n    [Directions.BOTTOM]: Directions.TOP\n};\n\nconst VERTICAL_DIRECTIONS = [Directions.TOP, Directions.BOTTOM];\n\nconst ANGLE_DIRECTION_MAP = {\n    0: Directions.RIGHT,\n    180: Directions.LEFT,\n    270: Directions.TOP,\n    90: Directions.BOTTOM\n};\n\nfunction getSegmentAngle(line) {\n    // TODO: the angle() method is general and therefore unnecessarily heavy for orthogonal links\n    return line.angle();\n}\n\nfunction simplifyPoints(points) {\n    // TODO: use own more efficient implementation (filter points that do not change direction).\n    // To simplify segments that are almost aligned (start and end points differ by e.g. 0.5px), use a threshold of 1.\n    return new g.Polyline(points).simplify({ threshold: 1 }).points;\n}\n\nfunction resolveSides(source, target) {\n    const { point: sourcePoint, x0: sx0, y0: sy0, view: sourceView, bbox: sourceBBox, direction: sourceDirection } = source;\n    const { point: targetPoint, x0: tx0, y0: ty0, view: targetView, bbox: targetBBox, direction: targetDirection } = target;\n\n    let sourceSide;\n\n    if (!sourceView) {\n        const sourceLinkAnchorBBox = new g.Rect(sx0, sy0, 0, 0);\n        sourceSide = DEFINED_DIRECTIONS.includes(sourceDirection) ? sourceDirection : sourceLinkAnchorBBox.sideNearestToPoint(targetPoint);\n    } else if (sourceView.model.isLink()) {\n        sourceSide = getDirectionForLinkConnection(targetPoint, sourcePoint, sourceView);\n    } else if (sourceDirection === Directions.ANCHOR_SIDE) {\n        sourceSide = sourceBBox.sideNearestToPoint(sourcePoint);\n    } else if (sourceDirection === Directions.MAGNET_SIDE) {\n        sourceSide = sourceView.model.getBBox().sideNearestToPoint(sourcePoint);\n    } else {\n        sourceSide = sourceDirection;\n    }\n\n    let targetSide;\n\n    if (!targetView) {\n        const targetLinkAnchorBBox = new g.Rect(tx0, ty0, 0, 0);\n        targetSide = DEFINED_DIRECTIONS.includes(targetDirection) ? targetDirection : targetLinkAnchorBBox.sideNearestToPoint(sourcePoint);\n    } else if (targetView.model.isLink()) {\n        targetSide = getDirectionForLinkConnection(sourcePoint, targetPoint, targetView);\n    } else if (targetDirection === Directions.ANCHOR_SIDE) {\n        targetSide = targetBBox.sideNearestToPoint(targetPoint);\n    } else if (targetDirection === Directions.MAGNET_SIDE) {\n        targetSide = targetView.model.getBBox().sideNearestToPoint(targetPoint);\n    } else {\n        targetSide = targetDirection;\n    }\n\n    return [sourceSide, targetSide];\n}\n\nfunction resolveForTopSourceSide(source, target, nextInLine) {\n    const { x0: sx0, y0: sy0, width, height, point: anchor, margin } = source;\n    const sx1 = sx0 + width;\n    const sy1 = sy0 + height;\n    const smx0 = sx0 - margin;\n    const smx1 = sx1 + margin;\n    const smy0 = sy0 - margin;\n\n    const { x: ax } = anchor;\n    const { x0: tx, y0: ty } = target;\n\n    if (tx === ax && ty < sy0) return Directions.BOTTOM;\n    if (tx < ax && ty < smy0) {\n        if (nextInLine.point.x === ax) return Directions.BOTTOM;\n        return Directions.RIGHT;\n    }\n    if (tx > ax && ty < smy0) {\n        if (nextInLine.point.x === ax) return Directions.BOTTOM;\n        return Directions.LEFT;\n    }\n    if (tx < smx0 && ty >= sy0) return Directions.TOP;\n    if (tx > smx1 && ty >= sy0) return Directions.TOP;\n    if (tx >= smx0 && tx <= ax && ty > sy1) {\n        if (nextInLine.point.x < tx) {\n            return Directions.RIGHT;\n        }\n\n        return Directions.LEFT;\n    }\n    if (tx <= smx1 && tx >= ax && ty > sy1) {\n        if (nextInLine.point.x < tx) {\n            return Directions.RIGHT;\n        }\n\n        return Directions.LEFT;\n    }\n\n    return Directions.TOP;\n}\n\nfunction resolveForBottomSourceSide(source, target, nextInLine) {\n    const { x0: sx0, y0: sy0, width, height, point: anchor, margin } = source;\n    const sx1 = sx0 + width;\n    const sy1 = sy0 + height;\n    const smx0 = sx0 - margin;\n    const smx1 = sx1 + margin;\n    const smy1 = sy1 + margin;\n\n    const { x: ax } = anchor;\n    const { x0: tx, y0: ty } = target;\n\n    if (tx === ax && ty > sy1) return Directions.TOP;\n    if (tx < ax && ty > smy1) {\n        if (nextInLine.point.x === ax) return Directions.TOP;\n        return Directions.RIGHT;\n    }\n    if (tx > ax && ty > smy1) {\n        if (nextInLine.point.x === ax) return Directions.TOP;\n        return Directions.LEFT;\n    }\n    if (tx < smx0 && ty <= sy1) return Directions.BOTTOM;\n    if (tx > smx1 && ty <= sy1) return Directions.BOTTOM;\n    if (tx >= smx0 && tx <= ax && ty < sy0) {\n        if (nextInLine.point.x < tx) {\n            return Directions.RIGHT;\n        }\n\n        return Directions.LEFT;\n    }\n    if (tx <= smx1 && tx >= ax && ty < sy0) {\n        if (nextInLine.point.x < tx) {\n            return Directions.RIGHT;\n        }\n\n        return Directions.LEFT;\n    }\n\n    return Directions.BOTTOM;\n}\n\nfunction resolveForLeftSourceSide(source, target, nextInLine) {\n    const { y0: sy0, x0: sx0, width, height, point: anchor, margin } = source;\n    const sx1 = sx0 + width;\n    const sy1 = sy0 + height;\n    const smx0 = sx0 - margin;\n    const smy0 = sy0 - margin;\n    const smy1 = sy1 + margin;\n\n    const { x: ax, y: ay } = anchor;\n    const { x0: tx, y0: ty } = target;\n\n    if (tx < ax && ty === ay) return Directions.RIGHT;\n    if (tx <= smx0 && ty < ay) return Directions.BOTTOM;\n    if (tx <= smx0 && ty > ay) return Directions.TOP;\n    if (tx >= sx0 && ty <= smy0) return Directions.LEFT;\n    if (tx >= sx0 && ty >= smy1) return Directions.LEFT;\n    if (tx > sx1 && ty >= smy0 && ty <= ay) {\n        if (nextInLine.point.y < ty) {\n            return Directions.BOTTOM;\n        }\n\n        return Directions.TOP;\n    }\n    if (tx > sx1 && ty <= smy1 && ty >= ay) {\n        if (nextInLine.point.y < ty) {\n            return Directions.BOTTOM;\n        }\n\n        return Directions.TOP;\n    }\n\n    return Directions.LEFT;\n}\n\nfunction resolveForRightSourceSide(source, target, nextInLine) {\n    const { y0: sy0, x0: sx0, width, height, point: anchor, margin } = source;\n    const sx1 = sx0 + width;\n    const sy1 = sy0 + height;\n    const smx1 = sx1 + margin;\n    const smy0 = sy0 - margin;\n    const smy1 = sy1 + margin;\n\n    const { x: ax, y: ay } = anchor;\n    const { x0: tx, y0: ty } = target;\n\n    if (tx > ax && ty === ay) return Directions.LEFT;\n    if (tx >= smx1 && ty < ay) return Directions.BOTTOM;\n    if (tx >= smx1 && ty > ay) return Directions.TOP;\n    if (tx <= sx1 && ty <= smy0) return Directions.RIGHT;\n    if (tx <= sx1 && ty >= smy1) return Directions.RIGHT;\n    if (tx < sx0 && ty >= smy0 && ty <= ay) {\n        if (nextInLine.point.y < ty) {\n            return Directions.BOTTOM;\n        }\n\n        return Directions.TOP;\n    }\n    if (tx < sx0 && ty <= smy1 && ty >= ay) {\n        if (nextInLine.point.y < ty) {\n            return Directions.BOTTOM;\n        }\n\n        return Directions.TOP;\n    }\n\n    return Directions.RIGHT;\n}\n\nfunction resolveInitialDirection(source, target, nextInLine) {\n    const [sourceSide] = resolveSides(source, target);\n\n    switch (sourceSide) {\n        case Directions.TOP:\n            return resolveForTopSourceSide(source, target, nextInLine);\n        case Directions.RIGHT:\n            return resolveForRightSourceSide(source, target, nextInLine);\n        case Directions.BOTTOM:\n            return resolveForBottomSourceSide(source, target, nextInLine);\n        case Directions.LEFT:\n            return resolveForLeftSourceSide(source, target, nextInLine);\n    }\n}\n\nfunction getDirectionForLinkConnection(linkOrigin, connectionPoint, linkView) {\n    const tangent = linkView.getTangentAtLength(linkView.getClosestPointLength(connectionPoint));\n    const roundedAngle = Math.round(getSegmentAngle(tangent) / 90) * 90;\n\n    if (roundedAngle % 180 === 0 && linkOrigin.y === connectionPoint.y) {\n        return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;\n    } else if (linkOrigin.x === connectionPoint.x) {\n        return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;\n    }\n\n    switch (roundedAngle) {\n        case 0:\n        case 180:\n        case 360:\n            return linkOrigin.y < connectionPoint.y ? Directions.TOP : Directions.BOTTOM;\n        case 90:\n        case 270:\n            return linkOrigin.x < connectionPoint.x ? Directions.LEFT : Directions.RIGHT;\n    }\n}\n\nfunction pointDataFromAnchor(view, point, bbox, direction, isPort, fallBackAnchor, margin) {\n    if (direction === Directions.AUTO) {\n        direction = isPort ? Directions.MAGNET_SIDE : Directions.ANCHOR_SIDE;\n    }\n\n    const isElement = view && view.model.isElement();\n\n    const {\n        x: x0,\n        y: y0,\n        width = 0,\n        height = 0\n    } = isElement ? g.Rect.fromRectUnion(bbox, view.model.getBBox()) : fallBackAnchor;\n\n    return {\n        point,\n        x0,\n        y0,\n        view,\n        bbox,\n        width,\n        height,\n        direction,\n        margin: isElement ? margin : 0\n    };\n}\n\nfunction pointDataFromVertex({ x, y }) {\n    const point = new g.Point(x, y);\n\n    return {\n        point,\n        x0: point.x,\n        y0: point.y,\n        view: null,\n        bbox: new g.Rect(x, y, 0, 0),\n        width: 0,\n        height: 0,\n        direction: null,\n        margin: 0\n    };\n}\n\nfunction getOutsidePoint(side, pointData, margin) {\n    const outsidePoint = pointData.point.clone();\n\n    const { x0, y0, width, height } = pointData;\n\n    switch (side) {\n        case 'left':\n            outsidePoint.x = x0 - margin;\n            break;\n        case 'right':\n            outsidePoint.x = x0 + width + margin;\n            break;\n        case 'top':\n            outsidePoint.y = y0 - margin;\n            break;\n        case 'bottom':\n            outsidePoint.y = y0 + height + margin;\n            break;\n    }\n\n    return outsidePoint;\n}\n\nfunction routeBetweenPoints(source, target, opt = {}) {\n    const { point: sourcePoint, x0: sx0, y0: sy0, width: sourceWidth, height: sourceHeight, margin: sourceMargin } = source;\n    const { point: targetPoint, x0: tx0, y0: ty0, width: targetWidth, height: targetHeight, margin: targetMargin } = target;\n    const { targetInSourceBBox = false } = opt;\n\n    const tx1 = tx0 + targetWidth;\n    const ty1 = ty0 + targetHeight;\n    const sx1 = sx0 + sourceWidth;\n    const sy1 = sy0 + sourceHeight;\n\n    // Key coordinates including the margin\n    const smx0 = sx0 - sourceMargin;\n    const smx1 = sx1 + sourceMargin;\n    const smy0 = sy0 - sourceMargin;\n    const smy1 = sy1 + sourceMargin;\n\n    const tmx0 = tx0 - targetMargin;\n    const tmx1 = tx1 + targetMargin;\n    const tmy0 = ty0 - targetMargin;\n    const tmy1 = ty1 + targetMargin;\n\n    const [sourceSide, targetSide] = resolveSides(source, target);\n\n    const sourceOutsidePoint = getOutsidePoint(sourceSide, { point: sourcePoint, x0: sx0, y0: sy0, width: sourceWidth, height: sourceHeight }, sourceMargin);\n    const targetOutsidePoint = getOutsidePoint(targetSide, { point: targetPoint, x0: tx0, y0: ty0, width: targetWidth, height: targetHeight }, targetMargin);\n\n    const { x: sox, y: soy } = sourceOutsidePoint;\n    const { x: tox, y: toy } = targetOutsidePoint;\n    const tcx = (tx0 + tx1) / 2;\n    const tcy = (ty0 + ty1) / 2;\n    const scx = (sx0 + sx1) / 2;\n    const scy = (sy0 + sy1) / 2;\n    const middleOfVerticalSides = (scx < tcx ? (sx1 + tx0) : (tx1 + sx0)) / 2;\n    const middleOfHorizontalSides = (scy < tcy ? (sy1 + ty0) : (ty1 + sy0)) / 2;\n\n    const sourceBBox = new g.Rect(sx0, sy0, sourceWidth, sourceHeight);\n    const targetBBox = new g.Rect(tx0, ty0, targetWidth, targetHeight);\n    const inflatedSourceBBox = sourceBBox.clone().inflate(sourceMargin);\n    const inflatedTargetBBox = targetBBox.clone().inflate(targetMargin);\n\n    if (sourceSide === 'left' && targetSide === 'right') {\n        if (smx0 <= tmx1) {\n            let y = middleOfHorizontalSides;\n            if (sox <= tmx0) {\n                if (ty1 >= smy0 && toy < soy) {\n                    y = Math.min(tmy0, smy0);\n                } else if (ty0 <= smy1 && toy >= soy) {\n                    y = Math.max(tmy1, smy1);\n                }\n            }\n            return [\n                { x: sox, y: soy },\n                { x: sox, y },\n                { x: tox, y },\n                { x: tox, y: toy }\n            ];\n        }\n\n        const x = (sox + tox) / 2;\n        return [\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'right' && targetSide === 'left') {\n        if (sox >= tmx0) {\n            let y = middleOfHorizontalSides;\n            if (sox > tx1) {\n                if (ty1 >= smy0 && toy < soy) {\n                    y = Math.min(tmy0, smy0);\n                } else if (ty0 <= smy1 && toy >= soy) {\n                    y = Math.max(tmy1, smy1);\n                }\n            }\n\n            return [\n                { x: sox, y: soy },\n                { x: sox, y },\n                { x: tox, y },\n                { x: tox, y: toy }\n            ];\n        }\n\n        const x = (sox + tox) / 2;\n        return [\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'top' && targetSide === 'bottom') {\n        const isPointInsideSource = g.intersection.rectWithRect(inflatedSourceBBox, targetBBox);\n\n        if (soy < toy) {\n            let x = middleOfVerticalSides;\n            let y = soy;\n\n            if (isPointInsideSource) {\n                y = Math.min(y, tmy0);\n            }\n\n            if (tx1 >= smx0 && tox < sox) {\n                x = Math.min(tmx0, smx0);\n            } else if (tx0 <= smx1 && tox >= sox) {\n                x = Math.max(tmx1, smx1);\n            }\n\n            return [\n                { x: sox, y },\n                { x, y },\n                { x, y: toy },\n                { x: tox, y: toy }\n            ];\n        }\n        const y = (soy + toy) / 2;\n        return [\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    } else if (sourceSide === 'bottom' && targetSide === 'top') {\n        const isPointInsideSource = g.intersection.rectWithRect(inflatedSourceBBox, targetBBox);\n\n        if (soy > toy) {\n            let x = middleOfVerticalSides;\n            let y = soy;\n\n            if (isPointInsideSource) {\n                y = Math.max(y, tmy1);\n            }\n\n            if (tx1 >= smx0 && tox < sox) {\n                x = Math.min(tmx0, smx0);\n            } else if (tx0 <= smx1 && tox >= sox) {\n                x = Math.max(tmx1, smx1);\n            }\n\n            return [\n                { x: sox, y },\n                { x, y },\n                { x, y: toy },\n                { x: tox, y: toy }\n            ];\n        }\n        const y = (soy + toy) / 2;\n        return [\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    } else if (sourceSide === 'top' && targetSide === 'top') {\n        const useUShapeConnection =\n            targetInSourceBBox ||\n            g.intersection.rectWithRect(inflatedSourceBBox, targetBBox) ||\n            (soy <= ty0 && (inflatedSourceBBox.bottomRight().x <= tox || inflatedSourceBBox.bottomLeft().x >= tox)) ||\n            (soy >= ty0 && (inflatedTargetBBox.bottomRight().x <= sox || inflatedTargetBBox.bottomLeft().x >= sox));\n\n        if (useUShapeConnection) {\n            return [\n                { x: sox, y: Math.min(soy, toy) },\n                { x: tox, y: Math.min(soy, toy) }\n            ];\n        }\n\n        let x;\n        let y1 = Math.min((sy1 + ty0) / 2, toy);\n        let y2 = Math.min((sy0 + ty1) / 2, soy);\n\n        if (toy < soy) {\n            if (tox > sox) {\n                x = Math.min(sox, tmx0);\n            } else {\n                x = Math.max(sox, tmx1);\n            }\n        } else {\n            if (tox >= sox) {\n                x = Math.max(tox, smx1);\n            } else {\n                x = Math.min(tox, smx0);\n            }\n        }\n\n        return [\n            { x: sox, y: y2 },\n            { x, y: y2 },\n            { x, y: y1 },\n            { x: tox, y: y1 }\n        ];\n    } else if (sourceSide === 'bottom' && targetSide === 'bottom') {\n        const useUShapeConnection =\n            targetInSourceBBox ||\n            g.intersection.rectWithRect(inflatedSourceBBox, targetBBox) ||\n            (soy >= toy && (inflatedSourceBBox.topRight().x <= tox || inflatedSourceBBox.topLeft().x >= tox)) ||\n            (soy <= toy && (inflatedTargetBBox.topRight().x <= sox || inflatedTargetBBox.topLeft().x >= sox));\n\n        if (useUShapeConnection) {\n            return [\n                { x: sox, y: Math.max(soy, toy) },\n                { x: tox, y: Math.max(soy, toy) }\n            ];\n        }\n\n        let x;\n        let y1 = Math.max((sy0 + ty1) / 2, toy);\n        let y2 = Math.max((sy1 + ty0) / 2, soy);\n\n        if (toy > soy) {\n            if (tox > sox) {\n                x = Math.min(sox, tmx0);\n            } else {\n                x = Math.max(sox, tmx1);\n            }\n        } else {\n            if (tox >= sox) {\n                x = Math.max(tox, smx1);\n            } else {\n                x = Math.min(tox, smx0);\n            }\n        }\n\n        return [\n            { x: sox, y: y2 },\n            { x, y: y2 },\n            { x, y: y1 },\n            { x: tox, y: y1 }\n        ];\n    } else if (sourceSide === 'left' && targetSide === 'left') {\n        const useUShapeConnection = \n            targetInSourceBBox ||\n            g.intersection.rectWithRect(inflatedSourceBBox, targetBBox) ||\n            (sox <= tox && (inflatedSourceBBox.bottomRight().y <= toy || inflatedSourceBBox.topRight().y >= toy)) ||\n            (sox >= tox && (inflatedTargetBBox.bottomRight().y <= soy || inflatedTargetBBox.topRight().y >= soy));\n\n        if (useUShapeConnection) {\n            return [\n                { x: Math.min(sox, tox), y: soy },\n                { x: Math.min(sox, tox), y: toy }\n            ];\n        }\n\n        let y;\n        let x1 = Math.min((sx1 + tx0) / 2, tox);\n        let x2 = Math.min((sx0 + tx1) / 2, sox);\n\n        if (tox > sox) {\n            if (toy <= soy) {\n                y = Math.min(smy0, toy);\n            } else {\n                y = Math.max(smy1, toy);\n            }\n        } else {\n            if (toy >= soy) {\n                y = Math.min(tmy0, soy);\n            } else {\n                y = Math.max(tmy1, soy);\n            }\n        }\n\n        return [\n            { x: x2, y: soy },\n            { x: x2, y },\n            { x: x1, y },\n            { x: x1, y: toy }\n        ];\n    } else if (sourceSide === 'right' && targetSide === 'right') {\n        const useUShapeConnection =\n            targetInSourceBBox ||\n            g.intersection.rectWithRect(inflatedSourceBBox, targetBBox) ||\n            (sox >= tox && (inflatedSourceBBox.bottomLeft().y <= toy || inflatedSourceBBox.topLeft().y >= toy)) ||\n            (sox <= tox && (inflatedTargetBBox.bottomLeft().y <= soy || inflatedTargetBBox.topLeft().y >= soy));\n\n        if (useUShapeConnection) {\n            return [\n                { x: Math.max(sox, tox), y: soy },\n                { x: Math.max(sox, tox), y: toy }\n            ];\n        }\n\n        let y;\n        let x1 = Math.max((sx0 + tx1) / 2, tox);\n        let x2 = Math.max((sx1 + tx0) / 2, sox);\n\n        if (tox <= sox) {\n            if (toy <= soy) {\n                y = Math.min(smy0, toy);\n            } else {\n                y = Math.max(smy1, toy);\n            }\n        } else {\n            if (toy >= soy) {\n                y = Math.min(tmy0, soy);\n            } else {\n                y = Math.max(tmy1, soy);\n            }\n        }\n\n        return [\n            { x: x2, y: soy },\n            { x: x2, y },\n            { x: x1, y },\n            { x: x1, y: toy }\n        ];\n    } else if (sourceSide === 'top' && targetSide === 'right') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (sox <= tmx1) {\n                const x = Math.max(sox + sourceMargin, tox);\n                const y = Math.min(smy0, tmy0);\n\n                // Target anchor is on the right side of the source anchor\n                return [\n                    { x: sox, y },\n                    { x: x, y },\n                    { x: x, y: toy }\n                ];\n            }\n\n            // Target anchor is on the left side of the source anchor\n            // Subtract the `sourceMargin` since the source anchor is on the right side of the target anchor\n            const anchorMiddleX = (sox - sourceMargin + tox) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: anchorMiddleX, y: soy },\n                { x: anchorMiddleX, y: toy }\n            ];\n        }\n\n        if (smy0 > toy) {\n            if (sox < tox) {\n                let y = tmy0;\n\n                if (tmy1 <= smy0 && tmx1 >= sox) {\n                    y = middleOfHorizontalSides;\n                }\n\n                return [\n                    { x: sox, y },\n                    { x: tox, y },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: sox, y: toy }];\n        }\n\n        const x = Math.max(middleOfVerticalSides, tmx1);\n\n        if (sox > tox && sy1 >= toy) {\n            return [\n                { x: sox, y: soy },\n                { x, y: soy },\n                { x, y: toy }\n            ];\n        }\n\n        if (x > smx0 && soy < ty1) {\n            const y = Math.min(smy0, tmy0);\n            const x = Math.max(smx1, tmx1);\n            return [\n                { x: sox, y },\n                { x, y },\n                { x, y: toy }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'top' && targetSide === 'left') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (sox >= tmx0) {\n                const x = Math.min(sox - sourceMargin, tox);\n                const y = Math.min(smy0, tmy0);\n\n                // Target anchor is on the left side of the source anchor\n                return [\n                    { x: sox, y },\n                    { x: x, y },\n                    { x: x, y: toy }\n                ];\n            }\n\n            // Target anchor is on the right side of the source anchor\n            // Add the `sourceMargin` since the source anchor is on the left side of the target anchor\n            const anchorMiddleX = (sox + sourceMargin + tox) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: anchorMiddleX, y: soy },\n                { x: anchorMiddleX, y: toy }\n            ];\n        }\n\n        if (smy0 > toy) {\n            if (sox > tox) {\n                let y = tmy0;\n\n                if (tmy1 <= smy0 && tmx0 <= sox) {\n                    y = middleOfHorizontalSides;\n                }\n\n                return [\n                    { x: sox, y },\n                    { x: tox, y },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: sox, y: toy }];\n        }\n\n        const x = Math.min(tmx0, middleOfVerticalSides);\n\n        if (sox < tox && sy1 >= toy) {\n            return [\n                { x: sox, y: soy },\n                { x, y: soy },\n                { x, y: toy }];\n        }\n\n        if (x < smx1 && soy < ty1) {\n            const y = Math.min(smy0, tmy0);\n            const x = Math.min(smx0, tmx0);\n            return [\n                { x: sox, y },\n                { x, y },\n                { x, y: toy }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'bottom' && targetSide === 'right') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (sox <= tmx1) {\n                const x = Math.max(sox + sourceMargin, tox);\n                const y = Math.max(smy1, tmy1);\n\n                // Target anchor is on the right side of the source anchor\n                return [\n                    { x: sox, y },\n                    { x, y },\n                    { x, y: toy }\n                ];\n            }\n\n            // Target anchor is on the left side of the source anchor\n            // Subtract the `sourceMargin` since the source anchor is on the right side of the target anchor\n            const anchorMiddleX = (sox - sourceMargin + tox) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: anchorMiddleX, y: soy },\n                { x: anchorMiddleX, y: toy }\n            ];\n        }\n\n        if (smy1 < toy) {\n            if (sox < tox) {\n                let y = tmy1;\n\n                if (tmy0 >= smy1 && tmx1 >= sox) {\n                    y = middleOfHorizontalSides;\n                }\n\n                return [\n                    { x: sox, y },\n                    { x: tox, y },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: sox, y: toy }];\n        }\n\n        const x = Math.max(middleOfVerticalSides, tmx1);\n\n        if (sox > tox && sy0 <= toy) {\n            return [\n                { x: sox, y: soy },\n                { x, y: soy },\n                { x, y: toy }\n            ];\n        }\n\n        if (x > smx0 && soy > ty0) {\n            const y = Math.max(smy1, tmy1);\n            const x = Math.max(smx1, tmx1);\n            return [\n                { x: sox, y },\n                { x, y },\n                { x, y: toy }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'bottom' && targetSide === 'left') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (sox >= tmx0) {\n                const x = Math.min(sox - sourceMargin, tox);\n                const y = Math.max(smy1, tmy1);\n\n                // Target anchor is on the left side of the source anchor\n                return [\n                    { x: sox, y },\n                    { x, y },\n                    { x, y: toy }\n                ];\n            }\n\n            // Target anchor is on the right side of the source anchor\n            // Add the `sourceMargin` since the source anchor is on the left side of the target anchor\n            const anchorMiddleX = (sox + sourceMargin + tox) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: anchorMiddleX, y: soy },\n                { x: anchorMiddleX, y: toy }\n            ];\n        }\n\n        if (smy1 < toy) {\n            if (sox > tox) {\n                let y = tmy1;\n\n                if (tmy0 >= smy1 && tmx0 <= sox) {\n                    y = middleOfHorizontalSides;\n                }\n\n                return [\n                    { x: sox, y },\n                    { x: tox, y },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: sox, y: toy }];\n        }\n\n        const x = Math.min(tmx0, middleOfVerticalSides);\n\n        if (sox < tox && sy0 <= toy) {\n            return [\n                { x: sox, y: soy },\n                { x, y: soy },\n                { x, y: toy }\n            ];\n        }\n\n        if (x < smx1 && soy > ty0) {\n            const y = Math.max(smy1, tmy1);\n            const x = Math.min(smx0, tmx0);\n            return [\n                { x: sox, y },\n                { x, y },\n                { x, y: toy }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x, y: soy },\n            { x, y: toy }\n        ];\n    } else if (sourceSide === 'left' && targetSide === 'bottom') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (soy <= tmy1) {\n                const x = Math.min(smx0, tmx0);\n                const y = Math.max(soy + sourceMargin, toy);\n\n                return [\n                    { x, y: soy },\n                    { x, y },\n                    { x: tox, y }\n                ];\n            }\n\n            // Target anchor is above the source anchor\n            const anchorMiddleY = (soy - sourceMargin + toy) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: sox, y: anchorMiddleY },\n                { x: tox, y: anchorMiddleY }\n            ];\n        }\n\n        if (smx0 > tox) {\n            if (soy < toy) {\n                let x = tmx0;\n\n                if (tmx1 <= smx0 && tmy1 >= soy) {\n                    x = middleOfVerticalSides;\n                }\n\n                return [\n                    { x, y: soy },\n                    { x, y: toy },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: tox, y: soy }];\n        }\n\n        const y = Math.max(tmy1, middleOfHorizontalSides);\n\n        if (soy > toy && sx1 >= tox) {\n            return [\n                { x: sox, y: soy },\n                { x: sox, y },\n                { x: tox, y }\n            ];\n        }\n\n        if (y > smy0 && sox < tx1) {\n            const x = Math.min(smx0, tmx0);\n            const y = Math.max(smy1, tmy1);\n\n            return [\n                { x, y: soy },\n                { x, y },\n                { x: tox, y }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    } else if (sourceSide === 'left' && targetSide === 'top') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (soy >= tmy0) {\n                const y = Math.min(soy - sourceMargin, toy);\n                const x = Math.min(smx0, tmx0);\n\n                // Target anchor is on the top side of the source anchor\n                return [\n                    { x, y: soy },\n                    { x, y },\n                    { x: tox, y }\n                ];\n            }\n\n            // Target anchor is below the source anchor\n            // Add the `sourceMargin` since the source anchor is above the target anchor\n            const anchorMiddleY = (soy + sourceMargin + toy) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: sox, y: anchorMiddleY },\n                { x: tox, y: anchorMiddleY }\n            ];\n        }\n\n        if (smx0 > tox) {\n            if (soy > toy) {\n                let x = tmx0;\n\n                if (tmx1 <= smx0 && tmy0 <= soy) {\n                    x = middleOfVerticalSides;\n                }\n\n                return [\n                    { x, y: soy },\n                    { x, y: toy },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: tox, y: soy }];\n        }\n\n        const y = Math.min(tmy0, middleOfHorizontalSides);\n\n        if (soy < toy && sx1 >= tox) {\n            return [\n                { x: sox, y: soy },\n                { x: sox, y },\n                { x: tox, y }];\n        }\n\n        if (y < smy1 && sox < tx1) {\n            const x = Math.min(smx0, tmx0);\n            const y = Math.min(smy0, tmy0);\n            return [\n                { x, y: soy },\n                { x, y },\n                { x: tox, y }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    } else if (sourceSide === 'right' && targetSide === 'top') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (soy >= tmy0) {\n                const x = Math.max(smx1, tmx1);\n                const y = Math.min(soy - sourceMargin, toy);\n\n                // Target anchor is on the top side of the source anchor\n                return [\n                    { x, y: soy },\n                    { x, y }, // Path adjustment for right side start\n                    { x: tox, y }\n                ];\n            }\n\n            // Target anchor is below the source anchor\n            // Adjust sourceMargin calculation since the source anchor is now on the right\n            const anchorMiddleY = (soy + sourceMargin + toy) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: sox, y: anchorMiddleY },\n                { x: tox, y: anchorMiddleY }\n            ];\n        }\n\n        if (smx1 < tox) {\n            if (soy > toy) {\n                let x = tmx1;\n\n                if (tmx0 >= smx1 && tmy0 <= soy) {\n                    x = middleOfVerticalSides;\n                }\n\n                return [\n                    { x, y: soy },\n                    { x, y: toy },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: tox, y: soy }];\n        }\n\n        const y = Math.min(tmy0, middleOfHorizontalSides);\n\n        if (soy < toy && sx0 <= tox) {\n            return [\n                { x: sox, y: soy },\n                { x: sox, y },\n                { x: tox, y }];\n        }\n\n        if (y < smy1 && sox > tx0) {\n            const x = Math.max(smx1, tmx1);\n            const y = Math.min(smy0, tmy0);\n\n            return [\n                { x, y: soy },\n                { x, y },\n                { x: tox, y }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    } else if (sourceSide === 'right' && targetSide === 'bottom') {\n        const isPointInsideSource = inflatedSourceBBox.containsPoint(targetPoint);\n\n        // The target point is inside the source element\n        if (isPointInsideSource) {\n            if (soy <= tmy1) {\n                const x = Math.max(smx1, tmx1);\n                const y = Math.max(soy + sourceMargin, toy);\n\n                return [\n                    { x, y: soy },\n                    { x, y },\n                    { x: tox, y }\n                ];\n            }\n\n            // Target anchor is above the source anchor\n            const anchorMiddleY = (soy - sourceMargin + toy) / 2;\n\n            return [\n                { x: sox, y: soy },\n                { x: sox, y: anchorMiddleY },\n                { x: tox, y: anchorMiddleY }\n            ];\n        }\n\n        if (smx1 < tox) {\n            if (soy < toy) {\n                let x = tmx1;\n\n                if (tmx0 >= smx1 && tmy1 >= soy) {\n                    x = middleOfVerticalSides;\n                }\n\n                return [\n                    { x, y: soy },\n                    { x, y: toy },\n                    { x: tox, y: toy }\n                ];\n            }\n\n            return [{ x: tox, y: soy }];\n        }\n\n        const y = Math.max(tmy1, middleOfHorizontalSides);\n\n        if (soy > toy && sx0 <= tox) {\n            return [\n                { x: sox, y: soy },\n                { x: sox, y },\n                { x: tox, y }\n            ];\n        }\n\n        if (y > smy0 && sox > tx0) {\n            const x = Math.max(smx1, tmx1);\n            const y = Math.max(smy1, tmy1);\n\n            return [\n                { x, y: soy },\n                { x, y },\n                { x: tox, y }\n            ];\n        }\n\n        return [\n            { x: sox, y: soy },\n            { x: sox, y },\n            { x: tox, y }\n        ];\n    }\n}\n\nfunction rightAngleRouter(vertices, opt, linkView) {\n    const { sourceDirection = Directions.AUTO, targetDirection = Directions.AUTO } = opt;\n    const margin = opt.margin || 20;\n    const useVertices = opt.useVertices || false;\n\n    const isSourcePort = !!linkView.model.source().port;\n    const sourcePoint = pointDataFromAnchor(linkView.sourceView, linkView.sourceAnchor, linkView.sourceBBox, sourceDirection, isSourcePort, linkView.sourceAnchor, margin);\n\n    const isTargetPort = !!linkView.model.target().port;\n    const targetPoint = pointDataFromAnchor(linkView.targetView, linkView.targetAnchor, linkView.targetBBox, targetDirection, isTargetPort, linkView.targetAnchor, margin);\n\n    let resultVertices = [];\n\n    if (!useVertices || vertices.length === 0) {\n        return simplifyPoints(routeBetweenPoints(sourcePoint, targetPoint));\n    }\n\n    const verticesData = vertices.map((v) => pointDataFromVertex(v));\n    const [firstVertex] = verticesData;\n\n    if (sourcePoint.view && sourcePoint.view.model.isElement() && sourcePoint.view.model.getBBox().inflate(margin).containsPoint(firstVertex.point)) {\n        const [fromDirection] = resolveSides(sourcePoint, firstVertex);\n        const toDirection = fromDirection;\n        const dummySource = pointDataFromVertex(sourcePoint.point);\n        // Points do not usually have margin. Here we create a point with a margin.\n        dummySource.margin = margin;\n        dummySource.direction = fromDirection;\n        firstVertex.direction = toDirection;\n\n        resultVertices.push(...routeBetweenPoints(dummySource, firstVertex, { targetInSourceBBox: true }), firstVertex.point);\n    } else {\n        // The first point responsible for the initial direction of the route\n        const next = verticesData[1] || targetPoint;\n        const direction = resolveInitialDirection(sourcePoint, firstVertex, next);\n        firstVertex.direction = direction;\n\n        resultVertices.push(...routeBetweenPoints(sourcePoint, firstVertex), firstVertex.point);\n    }\n\n    for (let i = 0; i < verticesData.length - 1; i++) {\n        const from = verticesData[i];\n        const to = verticesData[i + 1];\n\n        const segment = new g.Line(from.point, to.point);\n        const segmentAngle = getSegmentAngle(segment);\n        if (segmentAngle % 90 === 0) {\n            // Since the segment is horizontal or vertical, we can skip the routing and just connect them with a straight line\n            const toDirection = ANGLE_DIRECTION_MAP[segmentAngle];\n            const accessDirection = OPPOSITE_DIRECTIONS[toDirection];\n\n            if (toDirection !== from.direction) {\n                resultVertices.push(from.point, to.point);\n                to.direction = accessDirection;\n            } else {\n                const angle = g.normalizeAngle(segmentAngle - 90);\n\n                let dx = 0;\n                let dy = 0;\n\n                if (angle === 90) {\n                    dy = -margin;\n                } else if (angle === 180) {\n                    dx = -margin;\n                } else if (angle === 270) {\n                    dy = margin;\n                } else if (angle === 0) {\n                    dx = margin;\n                }\n\n                const p1 = { x: from.point.x + dx, y: from.point.y + dy };\n                const p2 = { x: to.point.x + dx, y: to.point.y + dy };\n\n                const segment2 = new g.Line(to.point, p2);\n                to.direction = ANGLE_DIRECTION_MAP[getSegmentAngle(segment2)];\n\n                // Constructing a loop\n                resultVertices.push(from.point, p1, p2, to.point);\n            }\n\n            continue;\n        }\n\n        const [fromDirection, toDirection] = resolveDirection(from, to);\n\n        from.direction = fromDirection;\n        to.direction = toDirection;\n\n        resultVertices.push(...routeBetweenPoints(from, to), to.point);\n    }\n\n    const lastVertex = verticesData[verticesData.length - 1];\n\n    if (targetPoint.view && targetPoint.view.model.isElement()) {\n        if (targetPoint.view.model.getBBox().inflate(margin).containsPoint(lastVertex.point)) {\n            const [fromDirection] = resolveDirection(lastVertex, targetPoint);\n            const dummyTarget = pointDataFromVertex(targetPoint.point);\n            const [, toDirection] = resolveSides(lastVertex, targetPoint);\n            // we are creating a point that has a margin\n            dummyTarget.margin = margin;\n            dummyTarget.direction = toDirection;\n            lastVertex.direction = fromDirection;\n\n            resultVertices.push(...routeBetweenPoints(lastVertex, dummyTarget));\n        } else {\n            // the last point of `simplified` array is the last defined vertex\n            // grab the penultimate point and construct a line segment from it to the last vertex\n            // this will ensure that the last segment continues in a straight line\n\n            const simplified = simplifyPoints(resultVertices);\n            const segment = new g.Line(simplified[simplified.length - 2], lastVertex.point);\n            const definedDirection = ANGLE_DIRECTION_MAP[Math.round(getSegmentAngle(segment))];\n            lastVertex.direction = definedDirection;\n\n            let lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);\n            const [p1, p2] = simplifyPoints([...lastSegmentRoute, targetPoint.point]);\n\n            const lastSegment = new g.Line(p1, p2);\n            const roundedLastSegmentAngle = Math.round(getSegmentAngle(lastSegment));\n            const lastSegmentDirection = ANGLE_DIRECTION_MAP[roundedLastSegmentAngle];\n\n            if (lastSegmentDirection !== definedDirection && definedDirection === OPPOSITE_DIRECTIONS[lastSegmentDirection]) {\n                lastVertex.margin = margin;\n                lastSegmentRoute = routeBetweenPoints(lastVertex, targetPoint);\n            }\n\n            resultVertices.push(...lastSegmentRoute);\n        }\n    } else {\n        // since the target is only a point we can apply the same logic as if we connected two verticesData\n        const [vertexDirection] = resolveDirection(lastVertex, targetPoint);\n        lastVertex.direction = vertexDirection;\n\n        resultVertices.push(...routeBetweenPoints(lastVertex, targetPoint));\n    }\n\n    return simplifyPoints(resultVertices);\n}\n\nfunction resolveDirection(from, to) {\n    const accessDirection = from.direction;\n    const isDirectionVertical = VERTICAL_DIRECTIONS.includes(accessDirection);\n\n    let sourceDirection = from.direction;\n    let targetDirection = to.direction;\n\n    if (isDirectionVertical) {\n        const isToAbove = from.point.y > to.point.y;\n        const dx = to.point.x - from.point.x;\n\n        if (accessDirection === Directions.BOTTOM) {\n            // If isToAbove === false and we need figure out if to go left or right\n            sourceDirection = isToAbove ? OPPOSITE_DIRECTIONS[accessDirection] : dx >= 0 ? Directions.RIGHT : Directions.LEFT;\n\n            if (dx > 0) {\n                targetDirection = isToAbove ? Directions.LEFT : Directions.TOP;\n            } else if (dx < 0) {\n                targetDirection = isToAbove ? Directions.RIGHT : Directions.TOP;\n            }\n        } else {\n            // If isToAbove === true and we need figure out if to go left or right\n            sourceDirection = isToAbove ? dx >= 0 ? Directions.RIGHT : Directions.LEFT : OPPOSITE_DIRECTIONS[accessDirection];\n\n            if (dx > 0) {\n                targetDirection = isToAbove ? Directions.BOTTOM : Directions.LEFT;\n            } else if (dx < 0) {\n                targetDirection = isToAbove ? Directions.BOTTOM : Directions.RIGHT;\n            }\n        }\n    } else {\n        const isToLeft = from.point.x > to.point.x;\n        const dy = to.point.y - from.point.y;\n\n        if (accessDirection === Directions.RIGHT) {\n            sourceDirection = isToLeft ? OPPOSITE_DIRECTIONS[accessDirection] : dy >= 0 ? Directions.BOTTOM : Directions.TOP;\n\n            if (dy > 0) {\n                targetDirection = isToLeft ? Directions.TOP : Directions.LEFT;\n            } else if (dy < 0) {\n                targetDirection = isToLeft ? Directions.BOTTOM : Directions.LEFT;\n            }\n        } else {\n            sourceDirection = isToLeft ? dy >= 0 ? Directions.BOTTOM : Directions.TOP : OPPOSITE_DIRECTIONS[accessDirection];\n\n            if (dy > 0) {\n                targetDirection = isToLeft ? Directions.RIGHT : Directions.TOP;\n            } else if (dy < 0) {\n                targetDirection = isToLeft ? Directions.RIGHT : Directions.BOTTOM;\n            }\n        }\n    }\n\n    return [sourceDirection, targetDirection];\n}\n\nrightAngleRouter.Directions = Directions;\n\nexport const rightAngle = rightAngleRouter;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}